/**
 * skylark-uglifyjs - A version of uglifyjs that ported to running on skylarkjs.
 * @author Hudaokeji Co.,Ltd
 * @version v0.9.0
 * @link www.skylarkjs.org
 * @license MIT
 */
define(["./utils"],function(t){"use strict";const{all:e,HOP:n,List:o,MAP:i,noop:a,DEF_BITPROPS:r,return_true:s,return_this:l}=t;var u;function c(t,e,o,i){void 0===i&&(i=h);var a=e=e?e.split(/\s+/):[];i&&i.PROPS&&(e=e.concat(i.PROPS));var r=["return function AST_",t,"(props){","this._bits=0;","if(props){"];e.forEach(function(t){r.push("this.",t,"=props.",t,";")}),r.push("}");var s=Object.create(i&&i.prototype);(o.initialize||s.initialize)&&r.push("this.initialize();"),r.push("};");var l=new Function(r.join(""))();for(var u in l.prototype=s,l.prototype.CTOR=l,l.prototype.TYPE=l.TYPE=t,i&&(l.BASE=i,i.SUBCLASSES.push(l)),l.DEFMETHOD=function(t,e){this.prototype[t]=e},l.PROPS=e,l.SELF_PROPS=a,l.SUBCLASSES=[],o)n(o,u)&&(/^\$/.test(u)?l[u.substr(1)]=o[u]:l.DEFMETHOD(u,o[u]));return"undefined"!=typeof exports&&(exports["AST_"+t]=l),l}var f=c("Token","type value line col pos endline endcol endpos nlb comments_before comments_after file raw",{},null),h=c("Node","start end",{_clone:function(t){if(t){var e=this.clone();return e.transform(new Je(function(t){if(t!==e)return t.clone(!0)}))}return new this.CTOR(this)},clone:function(t){return this._clone(t)},$documentation:"Base class of all AST nodes",$propdoc:{start:"[AST_Token] The first token of this node",end:"[AST_Token] The last token of this node"},equals:function(t){return this.TYPE==t.TYPE&&this._equals(t)},walk:function(t){t.visit(this)},_validate:function(){if("Node"==this.TYPE)throw new Error("should not instantiate AST_Node")},validate:function(){var t=this.CTOR;do{t.prototype._validate.call(this)}while(t=t.BASE)},validate_ast:function(){var t={};this.walk(new He(function(e){if(e.validate_visited===t)throw new Error(string_template("cannot reuse AST_{TYPE} from [{start}]",e));e.validate_visited=t}))}},null);r(h,["_optimized","_squeezed","call_only","collapse_scanning","defined","evaluating","falsy","in_arg","in_bool","is_undefined","inlined","length_read","nested","new","optional","private","pure","redundant","single_use","static","terminal","truthy","uses_eval","uses_with"]),(h.log_function=function(t,e){if("function"==typeof t){var n=Object.create(null);h.info=e?function(t,e){o("INFO: "+string_template(t,e))}:a,h.warn=function(t,e){o("WARN: "+string_template(t,e))}}else h.info=h.warn=a;function o(e){n[e]||(n[e]=!0,t(e))}})();var d=[];function p(t,n){return t.length==n.length&&e(t,function(t,e){return t.equals(n[e])})}function m(t,e){return t===e||(null==t?null==e:t instanceof h&&e instanceof h&&t.equals(e))}h.enable_validation=function(){h.disable_validation(),function t(e){if(e.SUBCLASSES.forEach(t),n(e.prototype,"transform")){var i=e.prototype.transform;e.prototype.transform=function(t,e){var n=i.call(this,t,e);if(n instanceof h)n.validate();else if(!(null===n||e&&o.is_op(n)))throw new Error("invalid transformed value: "+n);return n},d.push(function(){e.prototype.transform=i})}}(this)},h.disable_validation=function(){for(var t;t=d.pop();)t()};var _=c("Statement",null,{$documentation:"Base class of all statements",_validate:function(){if("Statement"==this.TYPE)throw new Error("should not instantiate AST_Statement")}}),S=c("Debugger",null,{$documentation:"Represents a debugger statement",_equals:s},_),b=c("Directive","quote value",{$documentation:'Represents a directive, like "use strict";',$propdoc:{quote:"[string?] the original quote character",value:"[string] The value of this directive as a plain string (it's not an AST_String!)"},_equals:function(t){return this.value==t.value},_validate:function(){if(null!=this.quote){if("string"!=typeof this.quote)throw new Error("quote must be string");if(!/^["']$/.test(this.quote))throw new Error("invalid quote: "+this.quote)}if("string"!=typeof this.value)throw new Error("value must be string")}},_),v=c("EmptyStatement",null,{$documentation:"The empty statement (empty block or simply a semicolon)",_equals:s},_);function w(t){return t instanceof _&&!(t instanceof rt)&&!(t instanceof z)}function y(t,e,n,o,i){if(n=n?"contain":"be",!(t instanceof h))throw new Error(e+" must "+n+" AST_Node");if(t instanceof Ft)throw new Error(e+" cannot "+n+" AST_DefaultValue");if(t instanceof ne)throw new Error(e+" cannot "+n+" AST_Destructured");if(t instanceof Ge&&!i)throw new Error(e+" cannot "+n+" AST_Hole");if(t instanceof Ut&&!o)throw new Error(e+" cannot "+n+" AST_Spread");if(w(t))throw new Error(e+" cannot "+n+" AST_Statement");if(t instanceof pe)throw new Error(e+" cannot "+n+" AST_SymbolDeclaration")}function A(t,e){y(t[e],e)}var T=c("SimpleStatement","body",{$documentation:"A statement consisting of an expression, i.e. a = 1 + 2",$propdoc:{body:"[AST_Node] an expression node (should not be instanceof AST_Statement)"},_equals:function(t){return this.body.equals(t.body)},walk:function(t){var e=this;t.visit(e,function(){e.body.walk(t)})},_validate:function(){A(this,"body")}},_),E=c("BlockScope","_var_names enclosed functions make_def parent_scope variables",{$documentation:"Base class for all statements introducing a lexical scope",$propdoc:{enclosed:"[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any inner scopes",functions:"[Dictionary/S] like `variables`, but only lists function declarations",parent_scope:"[AST_Scope?/S] link to the parent scope",variables:"[Dictionary/S] a map of name ---\x3e SymbolDef for all variables/functions defined in this scope"},clone:function(t){var e=this._clone(t);return this.enclosed&&(e.enclosed=this.enclosed.slice()),this.functions&&(e.functions=this.functions.clone()),this.variables&&(e.variables=this.variables.clone()),e},pinned:function(){return this.resolve().pinned()},resolve:function(){return this.parent_scope.resolve()},_validate:function(){if("BlockScope"==this.TYPE)throw new Error("should not instantiate AST_BlockScope");if(null!=this.parent_scope){if(!(this.parent_scope instanceof E))throw new Error("parent_scope must be AST_BlockScope");if(!(this.resolve()instanceof Y))throw new Error("must be contained within AST_Scope")}}},_);function g(t,e){t.body.forEach(function(t){t.walk(e)})}var k=c("Block","body",{$documentation:"A body of statements (usually braced)",$propdoc:{body:"[AST_Statement*] an array of statements"},_equals:function(t){return p(this.body,t.body)},walk:function(t){var e=this;t.visit(e,function(){g(e,t)})},_validate:function(){if("Block"==this.TYPE)throw new Error("should not instantiate AST_Block");this.body.forEach(function(t){if(!w(t))throw new Error("body must contain AST_Statement")})}},E),x=c("BlockStatement",null,{$documentation:"A block statement"},k),$=c("StatementWithBody","body",{$documentation:"Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",$propdoc:{body:"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"},_validate:function(){if("StatementWithBody"==this.TYPE)throw new Error("should not instantiate AST_StatementWithBody");if(!w(this.body))throw new Error("body must be AST_Statement")}},E),q=c("LabeledStatement","label",{$documentation:"Statement with a label",$propdoc:{label:"[AST_Label] a label definition"},_equals:function(t){return this.label.equals(t.label)&&this.body.equals(t.body)},walk:function(t){var e=this;t.visit(e,function(){e.label.walk(t),e.body.walk(t)})},clone:function(t){var e=this._clone(t);if(t){var n=e.label,o=this.label;e.walk(new He(function(t){if(t instanceof St){if(!t.label||t.label.thedef!==o)return;return t.label.thedef=n,n.references.push(t),!0}if(t instanceof Y)return!0}))}return e},_validate:function(){if(!(this.label instanceof ge))throw new Error("label must be AST_Label")}},$),D=c("IterationStatement",null,{$documentation:"Internal class.  All loops inherit from it.",_validate:function(){if("IterationStatement"==this.TYPE)throw new Error("should not instantiate AST_IterationStatement")}},$),N=c("DWLoop","condition",{$documentation:"Base class for do/while statements",$propdoc:{condition:"[AST_Node] the loop condition.  Should not be instanceof AST_Statement"},_equals:function(t){return this.body.equals(t.body)&&this.condition.equals(t.condition)},_validate:function(){if("DWLoop"==this.TYPE)throw new Error("should not instantiate AST_DWLoop");A(this,"condition")}},D),C=c("Do",null,{$documentation:"A `do` statement",walk:function(t){var e=this;t.visit(e,function(){e.body.walk(t),e.condition.walk(t)})}},N),P=c("While",null,{$documentation:"A `while` statement",walk:function(t){var e=this;t.visit(e,function(){e.condition.walk(t),e.body.walk(t)})}},N),B=c("For","init condition step",{$documentation:"A `for` statement",$propdoc:{init:"[AST_Node?] the `for` initialization code, or null if empty",condition:"[AST_Node?] the `for` termination clause, or null if empty",step:"[AST_Node?] the `for` update clause, or null if empty"},_equals:function(t){return m(this.init,t.init)&&m(this.condition,t.condition)&&m(this.step,t.step)&&this.body.equals(t.body)},walk:function(t){var e=this;t.visit(e,function(){e.init&&e.init.walk(t),e.condition&&e.condition.walk(t),e.step&&e.step.walk(t),e.body.walk(t)})},_validate:function(){if(null!=this.init){if(!(this.init instanceof h))throw new Error("init must be AST_Node");if(w(this.init)&&!(this.init instanceof $t))throw new Error("init cannot be AST_Statement")}null!=this.condition&&A(this,"condition"),null!=this.step&&A(this,"step")}},D),L=c("ForEnumeration","init object",{$documentation:"Base class for enumeration loops, i.e. `for ... in`, `for ... of` & `for await ... of`",$propdoc:{init:"[AST_Node] the assignment target during iteration",object:"[AST_Node] the object to iterate over"},_equals:function(t){return this.init.equals(t.init)&&this.object.equals(t.object)&&this.body.equals(t.body)},walk:function(t){var e=this;t.visit(e,function(){e.init.walk(t),e.object.walk(t),e.body.walk(t)})},_validate:function(){if("ForEnumeration"==this.TYPE)throw new Error("should not instantiate AST_ForEnumeration");if(this.init instanceof $t){if(1!=this.init.definitions.length)throw new Error("init must have single declaration")}else oe(this.init,function(t){if(!(t instanceof Gt||t instanceof ke))throw new Error("init must be assignable: "+t.TYPE)});A(this,"object")}},D),O=c("ForIn",null,{$documentation:"A `for ... in` statement"},L),j=c("ForOf",null,{$documentation:"A `for ... of` statement"},L),F=c("ForAwaitOf",null,{$documentation:"A `for await ... of` statement"},j),I=c("With","expression",{$documentation:"A `with` statement",$propdoc:{expression:"[AST_Node] the `with` expression"},_equals:function(t){return this.expression.equals(t.expression)&&this.body.equals(t.body)},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t),e.body.walk(t)})},_validate:function(){A(this,"expression")}},$),Y=c("Scope","fn_defs may_call_this uses_eval uses_with",{$documentation:"Base class for all statements introducing a lambda scope",$propdoc:{uses_eval:"[boolean/S] tells whether this scope contains a direct call to the global `eval`",uses_with:"[boolean/S] tells whether this scope uses the `with` statement"},pinned:function(){return this.uses_eval||this.uses_with},resolve:l,_validate:function(){if("Scope"==this.TYPE)throw new Error("should not instantiate AST_Scope")}},k),R=c("Toplevel","globals",{$documentation:"The toplevel scope",$propdoc:{globals:"[Dictionary/S] a map of name ---\x3e SymbolDef for all undeclared names"},wrap:function(t){var e=this.body;return u.parse(["(function(exports){'$ORIG';})(typeof ",t,"=='undefined'?(",t,"={}):",t,");"].join(""),{filename:"wrap="+JSON.stringify(t)}).transform(new Je(function(t){if(t instanceof b&&"$ORIG"==t.value)return o.splice(e)}))},enclose:function(t){"string"!=typeof t&&(t="");var e=t.indexOf(":");e<0&&(e=t.length);var n=this.body;return u.parse(["(function(",t.slice(0,e),'){"$ORIG"})(',t.slice(e+1),")"].join(""),{filename:"enclose="+JSON.stringify(t)}).transform(new Je(function(t){if(t instanceof b&&"$ORIG"==t.value)return o.splice(n)}))}},Y),V=c("ClassInitBlock",null,{$documentation:"Value for `class` static initialization blocks"},Y),G=c("Lambda","argnames length_read rest safe_ids uses_arguments",{$documentation:"Base class for functions",$propdoc:{argnames:"[(AST_DefaultValue|AST_Destructured|AST_SymbolFunarg)*] array of function arguments and/or destructured literals",length_read:"[boolean/S] whether length property of this function is accessed",rest:"[(AST_Destructured|AST_SymbolFunarg)?] rest parameter, or null if absent",uses_arguments:"[boolean|number/S] whether this function accesses the arguments array"},each_argname:function(t){var e=new He(function(n){return n instanceof Ft?(n.name.walk(e),!0):n instanceof ae?(n.value.walk(e),!0):void(n instanceof ve&&t(n))});this.argnames.forEach(function(t){t.walk(e)}),this.rest&&this.rest.walk(e)},_equals:function(t){return m(this.rest,t.rest)&&m(this.name,t.name)&&m(this.value,t.value)&&p(this.argnames,t.argnames)&&p(this.body,t.body)},walk:function(t){var e=this;t.visit(e,function(){e.name&&e.name.walk(t),e.argnames.forEach(function(e){e.walk(t)}),e.rest&&e.rest.walk(t),g(e,t)})},_validate:function(){if("Lambda"==this.TYPE)throw new Error("should not instantiate AST_Lambda");this.argnames.forEach(function(t){oe(t,function(t){if(!(t instanceof ve))throw new Error("argnames must be AST_SymbolFunarg[]")},!0)}),null!=this.rest&&oe(this.rest,function(t){if(!(t instanceof ve))throw new Error("rest must be AST_SymbolFunarg")})}},Y),W=c("Accessor",null,{$documentation:"A getter/setter function",_validate:function(){if(null!=this.name)throw new Error("name must be null")}},G),z=c("LambdaExpression","inlined",{$documentation:"Base class for function expressions",$propdoc:{inlined:"[boolean/S] whether this function has been inlined"},_validate:function(){if("LambdaExpression"==this.TYPE)throw new Error("should not instantiate AST_LambdaExpression")}},G);function U(t){return t instanceof M||t instanceof H}var M=c("Arrow","value",{$documentation:"An arrow function expression",$propdoc:{value:"[AST_Node?] simple return expression, or null if using function body."},walk:function(t){var e=this;t.visit(e,function(){e.argnames.forEach(function(e){e.walk(t)}),e.rest&&e.rest.walk(t),e.value?e.value.walk(t):g(e,t)})},_validate:function(){if(null!=this.name)throw new Error("name must be null");if(this.uses_arguments)throw new Error("uses_arguments must be false");if(null!=this.value&&(A(this,"value"),this.body.length))throw new Error("body must be empty if value exists")}},z),H=c("AsyncArrow","value",{$documentation:"An asynchronous arrow function expression",$propdoc:{value:"[AST_Node?] simple return expression, or null if using function body."},walk:function(t){var e=this;t.visit(e,function(){e.argnames.forEach(function(e){e.walk(t)}),e.rest&&e.rest.walk(t),e.value?e.value.walk(t):g(e,t)})},_validate:function(){if(null!=this.name)throw new Error("name must be null");if(this.uses_arguments)throw new Error("uses_arguments must be false");if(null!=this.value&&(A(this,"value"),this.body.length))throw new Error("body must be empty if value exists")}},z),J=c("AsyncFunction","name",{$documentation:"An asynchronous function expression",$propdoc:{name:"[AST_SymbolLambda?] the name of this function, or null if not specified"},_validate:function(){if(null!=this.name&&!(this.name instanceof ye))throw new Error("name must be AST_SymbolLambda")}},z),K=c("AsyncGeneratorFunction","name",{$documentation:"An asynchronous generator function expression",$propdoc:{name:"[AST_SymbolLambda?] the name of this function, or null if not specified"},_validate:function(){if(null!=this.name&&!(this.name instanceof ye))throw new Error("name must be AST_SymbolLambda")}},z),Q=c("Function","name",{$documentation:"A function expression",$propdoc:{name:"[AST_SymbolLambda?] the name of this function, or null if not specified"},_validate:function(){if(null!=this.name&&!(this.name instanceof ye))throw new Error("name must be AST_SymbolLambda")}},z),X=c("GeneratorFunction","name",{$documentation:"A generator function expression",$propdoc:{name:"[AST_SymbolLambda?] the name of this function, or null if not specified"},_validate:function(){if(null!=this.name&&!(this.name instanceof ye))throw new Error("name must be AST_SymbolLambda")}},z),Z=c("LambdaDefinition","inlined name",{$documentation:"Base class for function definitions",$propdoc:{inlined:"[boolean/S] whether this function has been inlined",name:"[AST_SymbolDefun] the name of this function"},_validate:function(){if("LambdaDefinition"==this.TYPE)throw new Error("should not instantiate AST_LambdaDefinition");if(!(this.name instanceof we))throw new Error("name must be AST_SymbolDefun")}},G),tt=c("AsyncDefun",null,{$documentation:"An asynchronous function definition"},Z),et=c("AsyncGeneratorDefun",null,{$documentation:"An asynchronous generator function definition"},Z),nt=c("Defun",null,{$documentation:"A function definition"},Z),ot=c("GeneratorDefun",null,{$documentation:"A generator function definition"},Z),it=c("Class","extends name properties",{$documentation:"Base class for class literals",$propdoc:{extends:"[AST_Node?] the super class, or null if not specified",properties:"[AST_ClassProperty*] array of class properties"},_equals:function(t){return m(this.name,t.name)&&m(this.extends,t.extends)&&p(this.properties,t.properties)},resolve:function(t){return t?this:this.parent_scope.resolve()},walk:function(t){var e=this;t.visit(e,function(){e.name&&e.name.walk(t),e.extends&&e.extends.walk(t),e.properties.forEach(function(e){e.walk(t)})})},_validate:function(){if("Class"==this.TYPE)throw new Error("should not instantiate AST_Class");null!=this.extends&&A(this,"extends"),this.properties.forEach(function(t){if(!(t instanceof st))throw new Error("properties must contain AST_ClassProperty")})}},E),at=c("DefClass",null,{$documentation:"A class definition",$propdoc:{name:"[AST_SymbolDefClass] the name of this class"},_validate:function(){if(!(this.name instanceof Ae))throw new Error("name must be AST_SymbolDefClass")}},it),rt=c("ClassExpression",null,{$documentation:"A class expression",$propdoc:{name:"[AST_SymbolClass?] the name of this class, or null if not specified"},_validate:function(){if(null!=this.name&&!(this.name instanceof Te))throw new Error("name must be AST_SymbolClass")}},it),st=c("ClassProperty","key private static value",{$documentation:"Base class for `class` properties",$propdoc:{key:"[string|AST_Node?] property name (AST_Node for computed property, null for initialization block)",private:"[boolean] whether this is a private property",static:"[boolean] whether this is a static property",value:"[AST_Node?] property value (AST_Accessor for getters/setters, AST_LambdaExpression for methods, null if not specified for fields)"},_equals:function(t){return!this.private==!t.private&&!this.static==!t.static&&m(this.key,t.key)&&m(this.value,t.value)},walk:function(t){var e=this;t.visit(e,function(){e.key instanceof h&&e.key.walk(t),e.value&&e.value.walk(t)})},_validate:function(){if("ClassProperty"==this.TYPE)throw new Error("should not instantiate AST_ClassProperty");if(this instanceof ht){if(null!=this.key)throw new Error("key must be null")}else if("string"!=typeof this.key){if(!(this.key instanceof h))throw new Error("key must be string or AST_Node");A(this,"key")}if(null!=this.value&&!(this.value instanceof h))throw new Error("value must be AST_Node")}}),lt=c("ClassField",null,{$documentation:"A `class` field",_validate:function(){null!=this.value&&A(this,"value")}},st),ut=c("ClassGetter",null,{$documentation:"A `class` getter",_validate:function(){if(!(this.value instanceof W))throw new Error("value must be AST_Accessor")}},st),ct=c("ClassSetter",null,{$documentation:"A `class` setter",_validate:function(){if(!(this.value instanceof W))throw new Error("value must be AST_Accessor")}},st),ft=c("ClassMethod",null,{$documentation:"A `class` method",_validate:function(){if(!(this.value instanceof z))throw new Error("value must be AST_LambdaExpression");if(U(this.value))throw new Error("value cannot be AST_Arrow or AST_AsyncArrow");if(null!=this.value.name)throw new Error("name of class method's lambda must be null")}},st),ht=c("ClassInit",null,{$documentation:"A `class` static initialization block",_validate:function(){if(!this.static)throw new Error("static must be true");if(!(this.value instanceof V))throw new Error("value must be AST_ClassInitBlock")},initialize:function(){this.static=!0}},st),dt=c("Jump",null,{$documentation:"Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)",_validate:function(){if("Jump"==this.TYPE)throw new Error("should not instantiate AST_Jump")}},_),pt=c("Exit","value",{$documentation:"Base class for “exits” (`return` and `throw`)",$propdoc:{value:"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"},_equals:function(t){return m(this.value,t.value)},walk:function(t){var e=this;t.visit(e,function(){e.value&&e.value.walk(t)})},_validate:function(){if("Exit"==this.TYPE)throw new Error("should not instantiate AST_Exit")}},dt),mt=c("Return",null,{$documentation:"A `return` statement",_validate:function(){null!=this.value&&A(this,"value")}},pt),_t=c("Throw",null,{$documentation:"A `throw` statement",_validate:function(){A(this,"value")}},pt),St=c("LoopControl","label",{$documentation:"Base class for loop control statements (`break` and `continue`)",$propdoc:{label:"[AST_LabelRef?] the label, or null if none"},_equals:function(t){return m(this.label,t.label)},walk:function(t){var e=this;t.visit(e,function(){e.label&&e.label.walk(t)})},_validate:function(){if("LoopControl"==this.TYPE)throw new Error("should not instantiate AST_LoopControl");if(null!=this.label&&!(this.label instanceof $e))throw new Error("label must be AST_LabelRef")}},dt),bt=c("Break",null,{$documentation:"A `break` statement"},St),vt=c("Continue",null,{$documentation:"A `continue` statement"},St),wt=c("If","condition alternative",{$documentation:"A `if` statement",$propdoc:{condition:"[AST_Node] the `if` condition",alternative:"[AST_Statement?] the `else` part, or null if not present"},_equals:function(t){return this.body.equals(t.body)&&this.condition.equals(t.condition)&&m(this.alternative,t.alternative)},walk:function(t){var e=this;t.visit(e,function(){e.condition.walk(t),e.body.walk(t),e.alternative&&e.alternative.walk(t)})},_validate:function(){if(A(this,"condition"),null!=this.alternative&&!w(this.alternative))throw new Error("alternative must be AST_Statement")}},$),yt=c("Switch","expression",{$documentation:"A `switch` statement",$propdoc:{expression:"[AST_Node] the `switch` “discriminant”"},_equals:function(t){return this.expression.equals(t.expression)&&p(this.body,t.body)},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t),g(e,t)})},_validate:function(){A(this,"expression"),this.body.forEach(function(t){if(!(t instanceof At))throw new Error("body must be AST_SwitchBranch[]")})}},k),At=c("SwitchBranch",null,{$documentation:"Base class for `switch` branches",_validate:function(){if("SwitchBranch"==this.TYPE)throw new Error("should not instantiate AST_SwitchBranch")}},k),Tt=c("Default",null,{$documentation:"A `default` switch branch"},At),Et=c("Case","expression",{$documentation:"A `case` switch branch",$propdoc:{expression:"[AST_Node] the `case` expression"},_equals:function(t){return this.expression.equals(t.expression)&&p(this.body,t.body)},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t),g(e,t)})},_validate:function(){A(this,"expression")}},At),gt=c("Try","bcatch bfinally",{$documentation:"A `try` statement",$propdoc:{bcatch:"[AST_Catch?] the catch block, or null if not present",bfinally:"[AST_Finally?] the finally block, or null if not present"},_equals:function(t){return p(this.body,t.body)&&m(this.bcatch,t.bcatch)&&m(this.bfinally,t.bfinally)},walk:function(t){var e=this;t.visit(e,function(){g(e,t),e.bcatch&&e.bcatch.walk(t),e.bfinally&&e.bfinally.walk(t)})},_validate:function(){if(null!=this.bcatch&&!(this.bcatch instanceof kt))throw new Error("bcatch must be AST_Catch");if(null!=this.bfinally&&!(this.bfinally instanceof xt))throw new Error("bfinally must be AST_Finally")}},k),kt=c("Catch","argname",{$documentation:"A `catch` node; only makes sense as part of a `try` statement",$propdoc:{argname:"[(AST_Destructured|AST_SymbolCatch)?] symbol for the exception, or null if not present"},_equals:function(t){return m(this.argname,t.argname)&&p(this.body,t.body)},walk:function(t){var e=this;t.visit(e,function(){e.argname&&e.argname.walk(t),g(e,t)})},_validate:function(){null!=this.argname&&oe(this.argname,function(t){if(!(t instanceof Ee))throw new Error("argname must be AST_SymbolCatch")})}},k),xt=c("Finally",null,{$documentation:"A `finally` node; only makes sense as part of a `try` statement"},k),$t=c("Definitions","definitions",{$documentation:"Base class for `var` nodes (variable declarations/initializations)",$propdoc:{definitions:"[AST_VarDef*] array of variable definitions"},_equals:function(t){return p(this.definitions,t.definitions)},walk:function(t){var e=this;t.visit(e,function(){e.definitions.forEach(function(e){e.walk(t)})})},_validate:function(){if("Definitions"==this.TYPE)throw new Error("should not instantiate AST_Definitions");if(this.definitions.length<1)throw new Error("must have at least one definition")}},_),qt=c("Const",null,{$documentation:"A `const` statement",_validate:function(){this.definitions.forEach(function(t){if(!(t instanceof Ct))throw new Error("definitions must be AST_VarDef[]");oe(t.name,function(t){if(!(t instanceof me))throw new Error("name must be AST_SymbolConst")})})}},$t),Dt=c("Let",null,{$documentation:"A `let` statement",_validate:function(){this.definitions.forEach(function(t){if(!(t instanceof Ct))throw new Error("definitions must be AST_VarDef[]");oe(t.name,function(t){if(!(t instanceof Se))throw new Error("name must be AST_SymbolLet")})})}},$t),Nt=c("Var",null,{$documentation:"A `var` statement",_validate:function(){this.definitions.forEach(function(t){if(!(t instanceof Ct))throw new Error("definitions must be AST_VarDef[]");oe(t.name,function(t){if(!(t instanceof be))throw new Error("name must be AST_SymbolVar")})})}},$t),Ct=c("VarDef","name value",{$documentation:"A variable declaration; only appears in a AST_Definitions node",$propdoc:{name:"[AST_Destructured|AST_SymbolVar] name of the variable",value:"[AST_Node?] initializer, or null of there's no initializer"},_equals:function(t){return this.name.equals(t.name)&&m(this.value,t.value)},walk:function(t){var e=this;t.visit(e,function(){e.name.walk(t),e.value&&e.value.walk(t)})},_validate:function(){null!=this.value&&A(this,"value")}}),Pt=c("ExportDeclaration","body",{$documentation:"An `export` statement",$propdoc:{body:"[AST_DefClass|AST_Definitions|AST_LambdaDefinition] the statement to export"},_equals:function(t){return this.body.equals(t.body)},walk:function(t){var e=this;t.visit(e,function(){e.body.walk(t)})},_validate:function(){if(!(this.body instanceof at||this.body instanceof $t||this.body instanceof Z))throw new Error("body must be AST_DefClass, AST_Definitions or AST_LambdaDefinition")}},_),Bt=c("ExportDefault","body",{$documentation:"An `export default` statement",$propdoc:{body:"[AST_Node] the default export"},_equals:function(t){return this.body.equals(t.body)},walk:function(t){var e=this;t.visit(e,function(){e.body.walk(t)})},_validate:function(){this.body instanceof at||this.body instanceof Z||A(this,"body")}},_),Lt=c("ExportForeign","aliases keys path",{$documentation:"An `export ... from '...'` statement",$propdoc:{aliases:"[AST_String*] array of aliases to export",keys:"[AST_String*] array of keys to import",path:"[AST_String] the path to import module"},_equals:function(t){return this.path.equals(t.path)&&p(this.aliases,t.aliases)&&p(this.keys,t.keys)},_validate:function(){if(this.aliases.length!=this.keys.length)throw new Error("aliases:key length mismatch: "+this.aliases.length+" != "+this.keys.length);if(this.aliases.forEach(function(t){if(!(t instanceof Le))throw new Error("aliases must contain AST_String")}),this.keys.forEach(function(t){if(!(t instanceof Le))throw new Error("keys must contain AST_String")}),!(this.path instanceof Le))throw new Error("path must be AST_String")}},_),Ot=c("ExportReferences","properties",{$documentation:"An `export { ... }` statement",$propdoc:{properties:"[AST_SymbolExport*] array of aliases to export"},_equals:function(t){return p(this.properties,t.properties)},walk:function(t){var e=this;t.visit(e,function(){e.properties.forEach(function(e){e.walk(t)})})},_validate:function(){this.properties.forEach(function(t){if(!(t instanceof xe))throw new Error("properties must contain AST_SymbolExport")})}},_),jt=c("Import","all default path properties",{$documentation:"An `import` statement",$propdoc:{all:"[AST_SymbolImport?] the imported namespace, or null if not specified",default:"[AST_SymbolImport?] the alias for default `export`, or null if not specified",path:"[AST_String] the path to import module",properties:"[(AST_SymbolImport*)?] array of aliases, or null if not specified"},_equals:function(t){return this.path.equals(t.path)&&m(this.all,t.all)&&m(this.default,t.default)&&!this.properties==!t.properties&&(!this.properties||p(this.properties,t.properties))},walk:function(t){var e=this;t.visit(e,function(){e.all&&e.all.walk(t),e.default&&e.default.walk(t),e.properties&&e.properties.forEach(function(e){e.walk(t)})})},_validate:function(){if(null!=this.all){if(!(this.all instanceof _e))throw new Error("all must be AST_SymbolImport");if(null!=this.properties)throw new Error("cannot import both * and {} in the same statement")}if(null!=this.default){if(!(this.default instanceof _e))throw new Error("default must be AST_SymbolImport");if(""!==this.default.key.value)throw new Error("invalid default key: "+this.default.key.value)}if(!(this.path instanceof Le))throw new Error("path must be AST_String");null!=this.properties&&this.properties.forEach(function(t){if(!(t instanceof _e))throw new Error("properties must contain AST_SymbolImport")})}},_),Ft=c("DefaultValue","name value",{$documentation:"A default value declaration",$propdoc:{name:"[AST_Destructured|AST_SymbolDeclaration] name of the variable",value:"[AST_Node] value to assign if variable is `undefined`"},_equals:function(t){return this.name.equals(t.name)&&this.value.equals(t.value)},walk:function(t){var e=this;t.visit(e,function(){e.name.walk(t),e.value.walk(t)})},_validate:function(){A(this,"value")}});function It(t,e,n,o){t[e].forEach(function(t){y(t,e,!0,n,o)})}var Yt=c("Call","args expression optional pure terminal",{$documentation:"A function call expression",$propdoc:{args:"[AST_Node*] array of arguments",expression:"[AST_Node] expression to invoke as function",optional:"[boolean] whether the expression is optional chaining",pure:"[boolean/S] marker for side-effect-free call expression",terminal:"[boolean] whether the chain has ended"},_equals:function(t){return!this.optional==!t.optional&&this.expression.equals(t.expression)&&p(this.args,t.args)},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t),e.args.forEach(function(e){e.walk(t)})})},_validate:function(){A(this,"expression"),It(this,"args",!0)}}),Rt=c("New",null,{$documentation:"An object instantiation.  Derives from a function call since it has exactly the same properties",_validate:function(){if(this.optional)throw new Error("optional must be false");if(this.terminal)throw new Error("terminal must be false")}},Yt),Vt=c("Sequence","expressions",{$documentation:"A sequence expression (comma-separated expressions)",$propdoc:{expressions:"[AST_Node*] array of expressions (at least two)"},_equals:function(t){return p(this.expressions,t.expressions)},walk:function(t){var e=this;t.visit(e,function(){e.expressions.forEach(function(e){e.walk(t)})})},_validate:function(){if(this.expressions.length<2)throw new Error("expressions must contain multiple elements");It(this,"expressions")}});var Gt=c("PropAccess","expression optional property terminal",{$documentation:'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`',$propdoc:{expression:"[AST_Node] the “container” expression",optional:"[boolean] whether the expression is optional chaining",property:"[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node",terminal:"[boolean] whether the chain has ended"},_equals:function(t){return!this.optional==!t.optional&&m(this.property,t.property)&&this.expression.equals(t.expression)},get_property:function(){var t=this.property;return t instanceof Be?t.value:t instanceof Ht&&"void"==t.operator&&t.expression instanceof Be?void 0:t},_validate:function(){if("PropAccess"==this.TYPE)throw new Error("should not instantiate AST_PropAccess");A(this,"expression")}}),Wt=c("Dot","quoted",{$documentation:"A dotted property access expression",$propdoc:{quoted:"[boolean] whether property is transformed from a quoted string"},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t)})},_validate:function(){if("string"!=typeof this.property)throw new Error("property must be string")}},Gt),zt=c("Sub",null,{$documentation:'Index-style property access, i.e. `a["foo"]`',walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t),e.property.walk(t)})},_validate:function(){A(this,"property")}},Gt),Ut=c("Spread","expression",{$documentation:"Spread expression in array/object literals or function calls",$propdoc:{expression:"[AST_Node] expression to be expanded"},_equals:function(t){return this.expression.equals(t.expression)},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t)})},_validate:function(){A(this,"expression")}}),Mt=c("Unary","operator expression",{$documentation:"Base class for unary expressions",$propdoc:{operator:"[string] the operator",expression:"[AST_Node] expression that this unary operator applies to"},_equals:function(t){return this.operator==t.operator&&this.expression.equals(t.expression)},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t)})},_validate:function(){if("Unary"==this.TYPE)throw new Error("should not instantiate AST_Unary");if("string"!=typeof this.operator)throw new Error("operator must be string");A(this,"expression")}}),Ht=c("UnaryPrefix",null,{$documentation:"Unary prefix expression, i.e. `typeof i` or `++i`"},Mt),Jt=c("UnaryPostfix",null,{$documentation:"Unary postfix expression, i.e. `i++`"},Mt),Kt=c("Binary","operator left right",{$documentation:"Binary expression, i.e. `a + b`",$propdoc:{left:"[AST_Node] left-hand side expression",operator:"[string] the operator",right:"[AST_Node] right-hand side expression"},_equals:function(t){return this.operator==t.operator&&this.left.equals(t.left)&&this.right.equals(t.right)},walk:function(t){var e=this;t.visit(e,function(){e.left.walk(t),e.right.walk(t)})},_validate:function(){if(this instanceof Xt||A(this,"left"),"string"!=typeof this.operator)throw new Error("operator must be string");A(this,"right")}}),Qt=c("Conditional","condition consequent alternative",{$documentation:"Conditional expression using the ternary operator, i.e. `a ? b : c`",$propdoc:{condition:"[AST_Node]",consequent:"[AST_Node]",alternative:"[AST_Node]"},_equals:function(t){return this.condition.equals(t.condition)&&this.consequent.equals(t.consequent)&&this.alternative.equals(t.alternative)},walk:function(t){var e=this;t.visit(e,function(){e.condition.walk(t),e.consequent.walk(t),e.alternative.walk(t)})},_validate:function(){A(this,"condition"),A(this,"consequent"),A(this,"alternative")}}),Xt=c("Assign",null,{$documentation:"An assignment expression — `a = b + 5`",_validate:function(){if(this.operator.indexOf("=")<0)throw new Error('operator must contain "="');if(this.left instanceof ne){if("="!=this.operator)throw new Error("invalid destructuring operator: "+this.operator);oe(this.left,function(t){if(!(t instanceof Gt||t instanceof ke))throw new Error("left must be assignable: "+t.TYPE)})}else if(!(this.left instanceof We||this.left instanceof Re||this.left instanceof Gt&&!this.left.optional||this.left instanceof ke||this.left instanceof Ve))throw new Error("left must be assignable")}},Kt),Zt=c("Await","expression",{$documentation:"An await expression",$propdoc:{expression:"[AST_Node] expression with Promise to resolve on"},_equals:function(t){return this.expression.equals(t.expression)},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t)})},_validate:function(){A(this,"expression")}}),te=c("Yield","expression nested",{$documentation:"A yield expression",$propdoc:{expression:"[AST_Node?] return value for iterator, or null if undefined",nested:"[boolean] whether to iterate over expression as generator"},_equals:function(t){return!this.nested==!t.nested&&m(this.expression,t.expression)},walk:function(t){var e=this;t.visit(e,function(){e.expression&&e.expression.walk(t)})},_validate:function(){if(null!=this.expression)A(this,"expression");else if(this.nested)throw new Error("yield* must contain expression")}}),ee=c("Array","elements",{$documentation:"An array literal",$propdoc:{elements:"[AST_Node*] array of elements"},_equals:function(t){return p(this.elements,t.elements)},walk:function(t){var e=this;t.visit(e,function(){e.elements.forEach(function(e){e.walk(t)})})},_validate:function(){It(this,"elements",!0,!0)}}),ne=c("Destructured","rest",{$documentation:"Base class for destructured literal",$propdoc:{rest:"[(AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef)?] rest parameter, or null if absent"},_validate:function(){if("Destructured"==this.TYPE)throw new Error("should not instantiate AST_Destructured")}});function oe(t,e,n){if(t instanceof Ft&&n)return oe(t.name,e);if(t instanceof ne){if(null!=t.rest&&oe(t.rest,e),t instanceof ie)return t.elements.forEach(function(t){t instanceof Ge||oe(t,e,!0)});if(t instanceof re)return t.properties.forEach(function(t){oe(t.value,e,!0)})}e(t)}var ie=c("DestructuredArray","elements",{$documentation:"A destructured array literal",$propdoc:{elements:"[(AST_DefaultValue|AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef)*] array of elements"},_equals:function(t){return m(this.rest,t.rest)&&p(this.elements,t.elements)},walk:function(t){var e=this;t.visit(e,function(){e.elements.forEach(function(e){e.walk(t)}),e.rest&&e.rest.walk(t)})}},ne),ae=c("DestructuredKeyVal","key value",{$documentation:"A key: value destructured property",$propdoc:{key:"[string|AST_Node] property name.  For computed property this is an AST_Node.",value:"[AST_DefaultValue|AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef] property value"},_equals:function(t){return m(this.key,t.key)&&this.value.equals(t.value)},walk:function(t){var e=this;t.visit(e,function(){e.key instanceof h&&e.key.walk(t),e.value.walk(t)})},_validate:function(){if("string"!=typeof this.key){if(!(this.key instanceof h))throw new Error("key must be string or AST_Node");A(this,"key")}if(!(this.value instanceof h))throw new Error("value must be AST_Node")}}),re=c("DestructuredObject","properties",{$documentation:"A destructured object literal",$propdoc:{properties:"[AST_DestructuredKeyVal*] array of properties"},_equals:function(t){return m(this.rest,t.rest)&&p(this.properties,t.properties)},walk:function(t){var e=this;t.visit(e,function(){e.properties.forEach(function(e){e.walk(t)}),e.rest&&e.rest.walk(t)})},_validate:function(){this.properties.forEach(function(t){if(!(t instanceof ae))throw new Error("properties must be AST_DestructuredKeyVal[]")})}},ne),se=c("Object","properties",{$documentation:"An object literal",$propdoc:{properties:"[(AST_ObjectProperty|AST_Spread)*] array of properties"},_equals:function(t){return p(this.properties,t.properties)},walk:function(t){var e=this;t.visit(e,function(){e.properties.forEach(function(e){e.walk(t)})})},_validate:function(){this.properties.forEach(function(t){if(!(t instanceof le||t instanceof Ut))throw new Error("properties must contain AST_ObjectProperty and/or AST_Spread only")})}}),le=c("ObjectProperty","key value",{$documentation:"Base class for literal object properties",$propdoc:{key:"[string|AST_Node] property name.  For computed property this is an AST_Node.",value:"[AST_Node] property value.  For getters and setters this is an AST_Accessor."},_equals:function(t){return m(this.key,t.key)&&this.value.equals(t.value)},walk:function(t){var e=this;t.visit(e,function(){e.key instanceof h&&e.key.walk(t),e.value.walk(t)})},_validate:function(){if("ObjectProperty"==this.TYPE)throw new Error("should not instantiate AST_ObjectProperty");if("string"!=typeof this.key){if(!(this.key instanceof h))throw new Error("key must be string or AST_Node");A(this,"key")}if(!(this.value instanceof h))throw new Error("value must be AST_Node")}}),ue=c("ObjectKeyVal",null,{$documentation:"A key: value object property",_validate:function(){A(this,"value")}},le),ce=c("ObjectMethod",null,{$documentation:"A key(){} object property",_validate:function(){if(!(this.value instanceof z))throw new Error("value must be AST_LambdaExpression");if(U(this.value))throw new Error("value cannot be AST_Arrow or AST_AsyncArrow");if(null!=this.value.name)throw new Error("name of object method's lambda must be null")}},ue),fe=c("ObjectSetter",null,{$documentation:"An object setter property",_validate:function(){if(!(this.value instanceof W))throw new Error("value must be AST_Accessor")}},le),he=c("ObjectGetter",null,{$documentation:"An object getter property",_validate:function(){if(!(this.value instanceof W))throw new Error("value must be AST_Accessor")}},le),de=c("Symbol","scope name thedef",{$documentation:"Base class for all symbols",$propdoc:{name:"[string] name of this symbol",scope:"[AST_Scope/S] the current scope (not necessarily the definition scope)",thedef:"[SymbolDef/S] the definition of this symbol"},_equals:function(t){return this.thedef?this.thedef===t.thedef:this.name==t.name},_validate:function(){if("Symbol"==this.TYPE)throw new Error("should not instantiate AST_Symbol");if("string"!=typeof this.name)throw new Error("name must be string")}}),pe=c("SymbolDeclaration","init",{$documentation:"A declaration symbol (symbol in var, function name or argument, symbol in catch)"},de),me=c("SymbolConst",null,{$documentation:"Symbol defining a constant"},pe),_e=c("SymbolImport","key",{$documentation:"Symbol defined by an `import` statement",$propdoc:{key:"[AST_String] the original `export` name"},_equals:function(t){return this.name==t.name&&this.key.equals(t.key)},_validate:function(){if(!(this.key instanceof Le))throw new Error("key must be AST_String")}},me),Se=c("SymbolLet",null,{$documentation:"Symbol defining a lexical-scoped variable"},pe),be=c("SymbolVar",null,{$documentation:"Symbol defining a variable"},pe),ve=c("SymbolFunarg","unused",{$documentation:"Symbol naming a function argument"},be),we=c("SymbolDefun",null,{$documentation:"Symbol defining a function"},pe),ye=c("SymbolLambda",null,{$documentation:"Symbol naming a function expression"},pe),Ae=c("SymbolDefClass",null,{$documentation:"Symbol defining a class"},me),Te=c("SymbolClass",null,{$documentation:"Symbol naming a class expression"},me),Ee=c("SymbolCatch",null,{$documentation:"Symbol naming the exception in catch"},pe),ge=c("Label","references",{$documentation:"Symbol naming a label (declaration)",$propdoc:{references:"[AST_LoopControl*] a list of nodes referring to this label"},initialize:function(){this.references=[],this.thedef=this}},de),ke=c("SymbolRef","fixed in_arg redef",{$documentation:"Reference to some symbol (not definition/declaration)"},de),xe=c("SymbolExport","alias",{$documentation:"Reference in an `export` statement",$propdoc:{alias:"[AST_String] the `export` alias"},_equals:function(t){return this.name==t.name&&this.alias.equals(t.alias)},_validate:function(){if(!(this.alias instanceof Le))throw new Error("alias must be AST_String")}},ke),$e=c("LabelRef",null,{$documentation:"Reference to a label symbol"},de),qe=c("ObjectIdentity",null,{$documentation:"Base class for `super` & `this`",_equals:s,_validate:function(){if("ObjectIdentity"==this.TYPE)throw new Error("should not instantiate AST_ObjectIdentity")}},de),De=c("Super",null,{$documentation:"The `super` symbol",_validate:function(){if("super"!==this.name)throw new Error('name must be "super"')}},qe),Ne=c("This",null,{$documentation:"The `this` symbol",_validate:function(){if("This"==this.TYPE&&"this"!==this.name)throw new Error('name must be "this"')}},qe),Ce=c("NewTarget",null,{$documentation:"The `new.target` symbol",initialize:function(){this.name="new.target"},_validate:function(){if("new.target"!==this.name)throw new Error('name must be "new.target": '+this.name)}},Ne),Pe=c("Template","expressions strings tag",{$documentation:"A template literal, i.e. tag`str1${expr1}...strN${exprN}strN+1`",$propdoc:{expressions:"[AST_Node*] the placeholder expressions",strings:"[string*] the raw text segments",tag:"[AST_Node?] tag function, or null if absent"},_equals:function(t){return m(this.tag,t.tag)&&(n=this.strings,o=t.strings,n.length==o.length&&e(n,function(t,e){return t==o[e]}))&&p(this.expressions,t.expressions);var n,o},walk:function(t){var e=this;t.visit(e,function(){e.tag&&e.tag.walk(t),e.expressions.forEach(function(e){e.walk(t)})})},_validate:function(){if(this.expressions.length+1!=this.strings.length)throw new Error("malformed template with "+this.expressions.length+" placeholder(s) but "+this.strings.length+" text segment(s)");It(this,"expressions"),this.strings.forEach(function(t){if("string"!=typeof t)throw new Error("strings must contain string")}),null!=this.tag&&A(this,"tag")}}),Be=c("Constant",null,{$documentation:"Base class for all constants",_equals:function(t){return this.value===t.value},_validate:function(){if("Constant"==this.TYPE)throw new Error("should not instantiate AST_Constant")}}),Le=c("String","quote value",{$documentation:"A string literal",$propdoc:{quote:"[string?] the original quote character",value:"[string] the contents of this string"},_validate:function(){if(null!=this.quote){if("string"!=typeof this.quote)throw new Error("quote must be string");if(!/^["']$/.test(this.quote))throw new Error("invalid quote: "+this.quote)}if("string"!=typeof this.value)throw new Error("value must be string")}},Be),Oe=c("Number","value",{$documentation:"A number literal",$propdoc:{value:"[number] the numeric value"},_validate:function(){if("number"!=typeof this.value)throw new Error("value must be number");if(!isFinite(this.value))throw new Error("value must be finite");if(this.value<0)throw new Error("value cannot be negative")}},Be),je=c("BigInt","value",{$documentation:"A BigInt literal",$propdoc:{value:"[string] the numeric representation"},_validate:function(){if("string"!=typeof this.value)throw new Error("value must be string");if("-"==this.value[0])throw new Error("value cannot be negative")}},Be),Fe=c("RegExp","value",{$documentation:"A regexp literal",$propdoc:{value:"[RegExp] the actual regexp"},_equals:function(t){return""+this.value==""+t.value},_validate:function(){if(!(this.value instanceof RegExp))throw new Error("value must be RegExp")}},Be),Ie=c("Atom",null,{$documentation:"Base class for atoms",_equals:s,_validate:function(){if("Atom"==this.TYPE)throw new Error("should not instantiate AST_Atom")}},Be),Ye=c("Null",null,{$documentation:"The `null` atom",value:null},Ie),Re=c("NaN",null,{$documentation:"The impossible value",value:NaN},Ie),Ve=c("Undefined",null,{$documentation:"The `undefined` value",value:void 0},Ie),Ge=c("Hole",null,{$documentation:"A hole in an array",value:void 0},Ie),We=c("Infinity",null,{$documentation:"The `Infinity` value",value:1/0},Ie),ze=c("Boolean",null,{$documentation:"Base class for booleans",_validate:function(){if("Boolean"==this.TYPE)throw new Error("should not instantiate AST_Boolean")}},Ie),Ue=c("False",null,{$documentation:"The `false` atom",value:!1},ze),Me=c("True",null,{$documentation:"The `true` atom",value:!0},ze);function He(t){this.callback=t,this.directives=Object.create(null),this.stack=[]}function Je(t,e){He.call(this),this.before=t,this.after=e}return He.prototype={visit:function(t,e){this.push(t),!this.callback(t,e||a)&&e&&e(),this.pop()},parent:function(t){return this.stack[this.stack.length-2-(t||0)]},push:function(t){var e;t instanceof it?(this.directives=Object.create(this.directives),e="use strict"):t instanceof b?e=t.value:t instanceof G&&(this.directives=Object.create(this.directives)),e&&!this.directives[e]&&(this.directives[e]=t),this.stack.push(t)},pop:function(){var t=this.stack.pop();(t instanceof it||t instanceof G)&&(this.directives=Object.getPrototypeOf(this.directives))},self:function(){return this.stack[this.stack.length-1]},find_parent:function(t){for(var e=this.stack,n=e.length-1;--n>=0;){var o=e[n];if(o instanceof t)return o}},has_directive:function(t){var e=this.directives[t];if(e)return e;var n=this.stack[this.stack.length-1];if(n instanceof Y)for(var o=0;o<n.body.length;++o){var i=n.body[o];if(!(i instanceof b))break;if(i.value==t)return i}},loopcontrol_target:function(t){var e=this.stack;if(t.label)for(var n=e.length;--n>=0;){if((o=e[n])instanceof q&&o.label.name==t.label.name)return o.body}else for(n=e.length;--n>=0;){var o;if((o=e[n])instanceof D||t instanceof bt&&o instanceof yt)return o}},in_boolean_context:function(){for(var t,e=!0,n=0,o=this.self();t=this.parent(n++);o=t){if(t instanceof Kt)switch(t.operator){case"&&":case"||":t.left===o&&(e=!1);continue;default:return!1}if(!(t instanceof Qt)){if(t instanceof N)return t.condition===o;if(t instanceof B)return t.condition===o;if(t instanceof wt)return t.condition===o;if(t instanceof mt){if(t.in_bool)return!0;for(;t=this.parent(n++);)if(t instanceof G){if(t.name)return!1;if("Call"!=(t=this.parent(n++)).TYPE)return!1;break}}if(t instanceof Vt){if(t.tail_node()===o)continue;return!e||"d"}return t instanceof T?!e||"d":t instanceof Ht&&"!"==t.operator}if(t.condition===o)return!0}}},Je.prototype=new He,function(t){function e(t,e){return o(t,function(t){return t.transform(e,!0)})}function n(t,n){t.argnames=e(t.argnames,n),t.rest&&(t.rest=t.rest.transform(n)),t.value?t.value=t.value.transform(n):t.body=e(t.body,n)}t(h,a),t(q,function(t,e){t.label=t.label.transform(e),t.body=t.body.transform(e)}),t(T,function(t,e){t.body=t.body.transform(e)}),t(k,function(t,n){t.body=e(t.body,n)}),t(C,function(t,e){t.body=t.body.transform(e),t.condition=t.condition.transform(e)}),t(P,function(t,e){t.condition=t.condition.transform(e),t.body=t.body.transform(e)}),t(B,function(t,e){t.init&&(t.init=t.init.transform(e)),t.condition&&(t.condition=t.condition.transform(e)),t.step&&(t.step=t.step.transform(e)),t.body=t.body.transform(e)}),t(L,function(t,e){t.init=t.init.transform(e),t.object=t.object.transform(e),t.body=t.body.transform(e)}),t(I,function(t,e){t.expression=t.expression.transform(e),t.body=t.body.transform(e)}),t(pt,function(t,e){t.value&&(t.value=t.value.transform(e))}),t(St,function(t,e){t.label&&(t.label=t.label.transform(e))}),t(wt,function(t,e){t.condition=t.condition.transform(e),t.body=t.body.transform(e),t.alternative&&(t.alternative=t.alternative.transform(e))}),t(yt,function(t,n){t.expression=t.expression.transform(n),t.body=e(t.body,n)}),t(Et,function(t,n){t.expression=t.expression.transform(n),t.body=e(t.body,n)}),t(gt,function(t,n){t.body=e(t.body,n),t.bcatch&&(t.bcatch=t.bcatch.transform(n)),t.bfinally&&(t.bfinally=t.bfinally.transform(n))}),t(kt,function(t,n){t.argname&&(t.argname=t.argname.transform(n)),t.body=e(t.body,n)}),t($t,function(t,n){t.definitions=e(t.definitions,n)}),t(Ct,function(t,e){t.name=t.name.transform(e),t.value&&(t.value=t.value.transform(e))}),t(Ft,function(t,e){t.name=t.name.transform(e),t.value=t.value.transform(e)}),t(G,function(t,n){t.name&&(t.name=t.name.transform(n)),t.argnames=e(t.argnames,n),t.rest&&(t.rest=t.rest.transform(n)),t.body=e(t.body,n)}),t(M,n),t(H,n),t(it,function(t,n){t.name&&(t.name=t.name.transform(n)),t.extends&&(t.extends=t.extends.transform(n)),t.properties=e(t.properties,n)}),t(st,function(t,e){t.key instanceof h&&(t.key=t.key.transform(e)),t.value&&(t.value=t.value.transform(e))}),t(Yt,function(t,n){t.expression=t.expression.transform(n),t.args=e(t.args,n)}),t(Vt,function(t,n){t.expressions=e(t.expressions,n)}),t(Zt,function(t,e){t.expression=t.expression.transform(e)}),t(te,function(t,e){t.expression&&(t.expression=t.expression.transform(e))}),t(Wt,function(t,e){t.expression=t.expression.transform(e)}),t(zt,function(t,e){t.expression=t.expression.transform(e),t.property=t.property.transform(e)}),t(Ut,function(t,e){t.expression=t.expression.transform(e)}),t(Mt,function(t,e){t.expression=t.expression.transform(e)}),t(Kt,function(t,e){t.left=t.left.transform(e),t.right=t.right.transform(e)}),t(Qt,function(t,e){t.condition=t.condition.transform(e),t.consequent=t.consequent.transform(e),t.alternative=t.alternative.transform(e)}),t(ee,function(t,n){t.elements=e(t.elements,n)}),t(ie,function(t,n){t.elements=e(t.elements,n),t.rest&&(t.rest=t.rest.transform(n))}),t(ae,function(t,e){t.key instanceof h&&(t.key=t.key.transform(e)),t.value=t.value.transform(e)}),t(re,function(t,n){t.properties=e(t.properties,n),t.rest&&(t.rest=t.rest.transform(n))}),t(se,function(t,n){t.properties=e(t.properties,n)}),t(le,function(t,e){t.key instanceof h&&(t.key=t.key.transform(e)),t.value=t.value.transform(e)}),t(Pt,function(t,e){t.body=t.body.transform(e)}),t(Bt,function(t,e){t.body=t.body.transform(e)}),t(Ot,function(t,n){t.properties=e(t.properties,n)}),t(jt,function(t,n){t.all&&(t.all=t.all.transform(n)),t.default&&(t.default=t.default.transform(n)),t.properties&&(t.properties=e(t.properties,n))}),t(Pe,function(t,n){t.tag&&(t.tag=t.tag.transform(n)),t.expressions=e(t.expressions,n)})}(function(t,e){t.DEFMETHOD("transform",function(t,n){var o,i;return t.push(this),t.before&&(o=t.before(this,e,n)),void 0===o&&(e(o=this,t),t.after&&void 0!==(i=t.after(o,n))&&(o=i)),t.pop(),o})}),u={parse:null,DEFNODE:c,AST_Token:f,AST_Node:h,AST_Statement:_,AST_Debugger:S,AST_Directive:b,AST_EmptyStatement:v,AST_SimpleStatement:T,AST_BlockScope:E,AST_Block:k,AST_BlockStatement:x,AST_StatementWithBody:$,AST_LabeledStatement:q,AST_IterationStatement:D,AST_DWLoop:N,AST_Do:C,AST_While:P,AST_For:B,AST_ForEnumeration:L,AST_ForIn:O,AST_ForOf:j,AST_ForAwaitOf:F,AST_With:I,AST_Scope:Y,AST_Toplevel:R,AST_ClassInitBlock:V,AST_Lambda:G,AST_Accessor:W,AST_LambdaExpression:z,AST_Arrow:M,AST_AsyncArrow:H,AST_AsyncFunction:J,AST_Function:Q,AST_GeneratorFunction:X,AST_AsyncGeneratorFunction:K,AST_LambdaDefinition:Z,AST_AsyncDefun:tt,AST_AsyncGeneratorDefun:et,AST_Defun:nt,AST_GeneratorDefun:ot,AST_Class:it,AST_DefClass:at,AST_ClassExpression:rt,AST_ClassProperty:st,AST_ClassField:lt,AST_ClassGetter:ut,AST_ClassSetter:ct,AST_ClassMethod:ft,AST_ClassInit:ht,AST_Jump:dt,AST_Exit:pt,AST_Return:mt,AST_Throw:_t,AST_LoopControl:St,AST_Break:bt,AST_Continue:vt,AST_If:wt,AST_Switch:yt,AST_SwitchBranch:At,AST_Default:Tt,AST_Case:Et,AST_Try:gt,AST_Catch:kt,AST_Finally:xt,AST_Definitions:$t,AST_Const:qt,AST_Let:Dt,AST_Var:Nt,AST_VarDef:Ct,AST_ExportDeclaration:Pt,AST_ExportDefault:Bt,AST_ExportForeign:Lt,AST_ExportReferences:Ot,AST_Import:jt,AST_DefaultValue:Ft,AST_Call:Yt,AST_New:Rt,AST_Sequence:Vt,AST_PropAccess:Gt,AST_Dot:Wt,AST_Sub:zt,AST_Spread:Ut,AST_Unary:Mt,AST_UnaryPrefix:Ht,AST_UnaryPostfix:Jt,AST_Binary:Kt,AST_Conditional:Qt,AST_Assign:Xt,AST_Await:Zt,AST_Yield:te,AST_Array:ee,AST_Destructured:ne,AST_DestructuredArray:ie,AST_DestructuredKeyVal:ae,AST_DestructuredObject:re,AST_Object:se,AST_ObjectProperty:le,AST_ObjectKeyVal:ue,AST_ObjectMethod:ce,AST_ObjectSetter:fe,AST_ObjectGetter:he,AST_Symbol:de,AST_SymbolDeclaration:pe,AST_SymbolConst:me,AST_SymbolImport:_e,AST_SymbolLet:Se,AST_SymbolVar:be,AST_SymbolFunarg:ve,AST_SymbolDefun:we,AST_SymbolLambda:ye,AST_SymbolDefClass:Ae,AST_SymbolClass:Te,AST_SymbolCatch:Ee,AST_Label:ge,AST_SymbolRef:ke,AST_SymbolExport:xe,AST_LabelRef:$e,AST_ObjectIdentity:qe,AST_Super:De,AST_This:Ne,AST_NewTarget:Ce,AST_Template:Pe,AST_Constant:Be,AST_String:Le,AST_Number:Oe,AST_BigInt:je,AST_RegExp:Fe,AST_Atom:Ie,AST_Null:Ye,AST_NaN:Re,AST_Undefined:Ve,AST_Hole:Ge,AST_Infinity:We,AST_Boolean:ze,AST_False:Ue,AST_True:Me,first_in_statement:function(t,e,n){for(var o,i=t.parent(-1),a=0;o=t.parent(a++);i=o){if(U(o))return e&&o.value===i;if(o instanceof Kt){if(o.left===i)continue}else if("Call"==o.TYPE){if(o.expression===i)continue}else if(o instanceof Qt){if(o.condition===i)continue}else{if(o instanceof Bt)return n;if(o instanceof Gt){if(o.expression===i)continue}else if(o instanceof Vt){if(o.expressions[0]===i)continue}else{if(o instanceof T)return!0;if(o instanceof Pe){if(o.tag===i)continue}else if(o instanceof Jt&&o.expression===i)continue}}return!1}},root_expr:function(t){for(;t instanceof Gt;)t=t.expression;return t},is_arrow:U,is_generator:function(t){return t instanceof et||t instanceof K||t instanceof ot||t instanceof X},walk_lambda:function(t,e){U(t)&&t.value?t.value.walk(e):g(t,e)},walk_body:g,is_statement:w,is_async:function(t){return t instanceof H||t instanceof tt||t instanceof J||t instanceof et||t instanceof K},TreeWalker:He,TreeTransformer:Je}});
//# sourceMappingURL=sourcemaps/ast.js.map
