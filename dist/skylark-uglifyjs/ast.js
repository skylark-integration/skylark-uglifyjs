/**
 * skylark-uglifyjs - A version of uglifyjs that ported to running on skylarkjs.
 * @author Hudaokeji Co.,Ltd
 * @version v0.9.0
 * @link www.skylarkjs.org
 * @license MIT
 */
define(["./utils"],function(O){"use strict";const{all:j,HOP:F,List:I,noop:Y,DEF_BITPROPS:R,return_true:V,return_this:G}=O;var W;function t(t,e,n,o){void 0===o&&(o=u);var i,a=e=e?e.split(/\s+/):[],r=(o&&o.PROPS&&(e=e.concat(o.PROPS)),["return function AST_",t,"(props){","this._bits=0;","if(props){"]),s=(e.forEach(function(t){r.push("this.",t,"=props.",t,";")}),r.push("}"),Object.create(o&&o.prototype)),l=((n.initialize||s.initialize)&&r.push("this.initialize();"),r.push("};"),new Function(r.join(""))());for(i in l.prototype=s,(l.prototype.CTOR=l).prototype.TYPE=l.TYPE=t,o&&(l.BASE=o).SUBCLASSES.push(l),l.DEFMETHOD=function(t,e){this.prototype[t]=e},l.PROPS=e,l.SELF_PROPS=a,l.SUBCLASSES=[],n)F(n,i)&&(/^\$/.test(i)?l[i.substr(1)]=n[i]:l.DEFMETHOD(i,n[i]));return"undefined"!=typeof exports&&(exports["AST_"+t]=l),l}var O=t("Token","type value line col pos endline endcol endpos nlb comments_before comments_after file raw",{},null),u=t("Node","start end",{_clone:function(t){var e;return t?(e=this.clone()).transform(new Je(function(t){if(t!==e)return t.clone(!0)})):new this.CTOR(this)},clone:function(t){return this._clone(t)},$documentation:"Base class of all AST nodes",$propdoc:{start:"[AST_Token] The first token of this node",end:"[AST_Token] The last token of this node"},equals:function(t){return this.TYPE==t.TYPE&&this._equals(t)},walk:function(t){t.visit(this)},_validate:function(){if("Node"==this.TYPE)throw new Error("should not instantiate AST_Node")},validate:function(){for(var t=this.CTOR;t.prototype._validate.call(this),t=t.BASE;);},validate_ast:function(){var e={};this.walk(new B(function(t){if(t.validate_visited===e)throw new Error(string_template("cannot reuse AST_{TYPE} from [{start}]",t));t.validate_visited=e}))}},null),z=(R(u,["_optimized","_squeezed","call_only","collapse_scanning","defined","evaluating","falsy","in_arg","in_bool","is_undefined","inlined","length_read","nested","new","optional","private","pure","redundant","single_use","static","terminal","truthy","uses_eval","uses_with"]),(u.log_function=function(e,t){var n;function o(t){n[t]||(n[t]=!0,e(t))}"function"!=typeof e?u.info=u.warn=Y:(n=Object.create(null),u.info=t?function(t,e){o("INFO: "+string_template(t,e))}:Y,u.warn=function(t,e){o("WARN: "+string_template(t,e))})})(),[]);function o(t,n){return t.length==n.length&&j(t,function(t,e){return t.equals(n[e])})}function i(t,e){return t===e||(null==t?null==e:t instanceof u&&e instanceof u&&t.equals(e))}u.enable_validation=function(){u.disable_validation(),function t(e){var n;e.SUBCLASSES.forEach(t),F(e.prototype,"transform")&&(n=e.prototype.transform,e.prototype.transform=function(t,e){t=n.call(this,t,e);if(t instanceof u)t.validate();else if(!(null===t||e&&I.is_op(t)))throw new Error("invalid transformed value: "+t);return t},z.push(function(){e.prototype.transform=n}))}(this)},u.disable_validation=function(){for(var t;t=z.pop();)t()};var e=t("Statement",null,{$documentation:"Base class of all statements",_validate:function(){if("Statement"==this.TYPE)throw new Error("should not instantiate AST_Statement")}}),U=t("Debugger",null,{$documentation:"Represents a debugger statement",_equals:V},e),a=t("Directive","quote value",{$documentation:'Represents a directive, like "use strict";',$propdoc:{quote:"[string?] the original quote character",value:"[string] The value of this directive as a plain string (it's not an AST_String!)"},_equals:function(t){return this.value==t.value},_validate:function(){if(null!=this.quote){if("string"!=typeof this.quote)throw new Error("quote must be string");if(!/^["']$/.test(this.quote))throw new Error("invalid quote: "+this.quote)}if("string"!=typeof this.value)throw new Error("value must be string")}},e),H=t("EmptyStatement",null,{$documentation:"The empty statement (empty block or simply a semicolon)",_equals:V},e);function r(t){return t instanceof e&&!(t instanceof vt)&&!(t instanceof _)}function M(t,e,n,o,i){if(n=n?"contain":"be",!(t instanceof u))throw new Error(e+" must "+n+" AST_Node");if(t instanceof Mt)throw new Error(e+" cannot "+n+" AST_DefaultValue");if(t instanceof g)throw new Error(e+" cannot "+n+" AST_Destructured");if(t instanceof We&&!i)throw new Error(e+" cannot "+n+" AST_Hole");if(t instanceof ee&&!o)throw new Error(e+" cannot "+n+" AST_Spread");if(r(t))throw new Error(e+" cannot "+n+" AST_Statement");if(t instanceof D)throw new Error(e+" cannot "+n+" AST_SymbolDeclaration")}function n(t,e){M(t[e],e)}var J=t("SimpleStatement","body",{$documentation:"A statement consisting of an expression, i.e. a = 1 + 2",$propdoc:{body:"[AST_Node] an expression node (should not be instanceof AST_Statement)"},_equals:function(t){return this.body.equals(t.body)},walk:function(t){var e=this;t.visit(e,function(){e.body.walk(t)})},_validate:function(){n(this,"body")}},e),s=t("BlockScope","_var_names enclosed functions make_def parent_scope variables",{$documentation:"Base class for all statements introducing a lexical scope",$propdoc:{enclosed:"[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any inner scopes",functions:"[Dictionary/S] like `variables`, but only lists function declarations",parent_scope:"[AST_Scope?/S] link to the parent scope",variables:"[Dictionary/S] a map of name ---\x3e SymbolDef for all variables/functions defined in this scope"},clone:function(t){t=this._clone(t);return this.enclosed&&(t.enclosed=this.enclosed.slice()),this.functions&&(t.functions=this.functions.clone()),this.variables&&(t.variables=this.variables.clone()),t},pinned:function(){return this.resolve().pinned()},resolve:function(){return this.parent_scope.resolve()},_validate:function(){if("BlockScope"==this.TYPE)throw new Error("should not instantiate AST_BlockScope");if(null!=this.parent_scope){if(!(this.parent_scope instanceof s))throw new Error("parent_scope must be AST_BlockScope");if(!(this.resolve()instanceof d))throw new Error("must be contained within AST_Scope")}}},e);function l(t,e){t.body.forEach(function(t){t.walk(e)})}var c=t("Block","body",{$documentation:"A body of statements (usually braced)",$propdoc:{body:"[AST_Statement*] an array of statements"},_equals:function(t){return o(this.body,t.body)},walk:function(t){var e=this;t.visit(e,function(){l(e,t)})},_validate:function(){if("Block"==this.TYPE)throw new Error("should not instantiate AST_Block");this.body.forEach(function(t){if(!r(t))throw new Error("body must contain AST_Statement")})}},s),K=t("BlockStatement",null,{$documentation:"A block statement"},c),f=t("StatementWithBody","body",{$documentation:"Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",$propdoc:{body:"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"},_validate:function(){if("StatementWithBody"==this.TYPE)throw new Error("should not instantiate AST_StatementWithBody");if(!r(this.body))throw new Error("body must be AST_Statement")}},s),Q=t("LabeledStatement","label",{$documentation:"Statement with a label",$propdoc:{label:"[AST_Label] a label definition"},_equals:function(t){return this.label.equals(t.label)&&this.body.equals(t.body)},walk:function(t){var e=this;t.visit(e,function(){e.label.walk(t),e.body.walk(t)})},clone:function(t){var e,n,o=this._clone(t);return t&&(e=o.label,n=this.label,o.walk(new B(function(t){return t instanceof y?t.label&&t.label.thedef===n?((t.label.thedef=e).references.push(t),!0):void 0:t instanceof d||void 0}))),o},_validate:function(){if(!(this.label instanceof qe))throw new Error("label must be AST_Label")}},f),h=t("IterationStatement",null,{$documentation:"Internal class.  All loops inherit from it.",_validate:function(){if("IterationStatement"==this.TYPE)throw new Error("should not instantiate AST_IterationStatement")}},f),X=t("DWLoop","condition",{$documentation:"Base class for do/while statements",$propdoc:{condition:"[AST_Node] the loop condition.  Should not be instanceof AST_Statement"},_equals:function(t){return this.body.equals(t.body)&&this.condition.equals(t.condition)},_validate:function(){if("DWLoop"==this.TYPE)throw new Error("should not instantiate AST_DWLoop");n(this,"condition")}},h),Z=t("Do",null,{$documentation:"A `do` statement",walk:function(t){var e=this;t.visit(e,function(){e.body.walk(t),e.condition.walk(t)})}},X),tt=t("While",null,{$documentation:"A `while` statement",walk:function(t){var e=this;t.visit(e,function(){e.condition.walk(t),e.body.walk(t)})}},X),et=t("For","init condition step",{$documentation:"A `for` statement",$propdoc:{init:"[AST_Node?] the `for` initialization code, or null if empty",condition:"[AST_Node?] the `for` termination clause, or null if empty",step:"[AST_Node?] the `for` update clause, or null if empty"},_equals:function(t){return i(this.init,t.init)&&i(this.condition,t.condition)&&i(this.step,t.step)&&this.body.equals(t.body)},walk:function(t){var e=this;t.visit(e,function(){e.init&&e.init.walk(t),e.condition&&e.condition.walk(t),e.step&&e.step.walk(t),e.body.walk(t)})},_validate:function(){if(null!=this.init){if(!(this.init instanceof u))throw new Error("init must be AST_Node");if(r(this.init)&&!(this.init instanceof A))throw new Error("init cannot be AST_Statement")}null!=this.condition&&n(this,"condition"),null!=this.step&&n(this,"step")}},h),nt=t("ForEnumeration","init object",{$documentation:"Base class for enumeration loops, i.e. `for ... in`, `for ... of` & `for await ... of`",$propdoc:{init:"[AST_Node] the assignment target during iteration",object:"[AST_Node] the object to iterate over"},_equals:function(t){return this.init.equals(t.init)&&this.object.equals(t.object)&&this.body.equals(t.body)},walk:function(t){var e=this;t.visit(e,function(){e.init.walk(t),e.object.walk(t),e.body.walk(t)})},_validate:function(){if("ForEnumeration"==this.TYPE)throw new Error("should not instantiate AST_ForEnumeration");if(this.init instanceof A){if(1!=this.init.definitions.length)throw new Error("init must have single declaration")}else k(this.init,function(t){if(!(t instanceof E||t instanceof De))throw new Error("init must be assignable: "+t.TYPE)});n(this,"object")}},h),ot=t("ForIn",null,{$documentation:"A `for ... in` statement"},nt),it=t("ForOf",null,{$documentation:"A `for ... of` statement"},nt),at=t("ForAwaitOf",null,{$documentation:"A `for await ... of` statement"},it),rt=t("With","expression",{$documentation:"A `with` statement",$propdoc:{expression:"[AST_Node] the `with` expression"},_equals:function(t){return this.expression.equals(t.expression)&&this.body.equals(t.body)},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t),e.body.walk(t)})},_validate:function(){n(this,"expression")}},f),d=t("Scope","fn_defs may_call_this uses_eval uses_with",{$documentation:"Base class for all statements introducing a lambda scope",$propdoc:{uses_eval:"[boolean/S] tells whether this scope contains a direct call to the global `eval`",uses_with:"[boolean/S] tells whether this scope uses the `with` statement"},pinned:function(){return this.uses_eval||this.uses_with},resolve:G,_validate:function(){if("Scope"==this.TYPE)throw new Error("should not instantiate AST_Scope")}},c),st=t("Toplevel","globals",{$documentation:"The toplevel scope",$propdoc:{globals:"[Dictionary/S] a map of name ---\x3e SymbolDef for all undeclared names"},wrap:function(t){var e=this.body;return W.parse(["(function(exports){'$ORIG';})(typeof ",t,"=='undefined'?(",t,"={}):",t,");"].join(""),{filename:"wrap="+JSON.stringify(t)}).transform(new Je(function(t){if(t instanceof a&&"$ORIG"==t.value)return I.splice(e)}))},enclose:function(t){var e=(t="string"!=typeof t?"":t).indexOf(":"),n=(e<0&&(e=t.length),this.body);return W.parse(["(function(",t.slice(0,e),'){"$ORIG"})(',t.slice(e+1),")"].join(""),{filename:"enclose="+JSON.stringify(t)}).transform(new Je(function(t){if(t instanceof a&&"$ORIG"==t.value)return I.splice(n)}))}},d),lt=t("ClassInitBlock",null,{$documentation:"Value for `class` static initialization blocks"},d),p=t("Lambda","argnames length_read rest safe_ids uses_arguments",{$documentation:"Base class for functions",$propdoc:{argnames:"[(AST_DefaultValue|AST_Destructured|AST_SymbolFunarg)*] array of function arguments and/or destructured literals",length_read:"[boolean/S] whether length property of this function is accessed",rest:"[(AST_Destructured|AST_SymbolFunarg)?] rest parameter, or null if absent",uses_arguments:"[boolean|number/S] whether this function accesses the arguments array"},each_argname:function(e){var n=new B(function(t){return t instanceof Mt?(t.name.walk(n),!0):t instanceof he?(t.value.walk(n),!0):void(t instanceof Te&&e(t))});this.argnames.forEach(function(t){t.walk(n)}),this.rest&&this.rest.walk(n)},_equals:function(t){return i(this.rest,t.rest)&&i(this.name,t.name)&&i(this.value,t.value)&&o(this.argnames,t.argnames)&&o(this.body,t.body)},walk:function(e){var t=this;e.visit(t,function(){t.name&&t.name.walk(e),t.argnames.forEach(function(t){t.walk(e)}),t.rest&&t.rest.walk(e),l(t,e)})},_validate:function(){if("Lambda"==this.TYPE)throw new Error("should not instantiate AST_Lambda");this.argnames.forEach(function(t){k(t,function(t){if(!(t instanceof Te))throw new Error("argnames must be AST_SymbolFunarg[]")},!0)}),null!=this.rest&&k(this.rest,function(t){if(!(t instanceof Te))throw new Error("rest must be AST_SymbolFunarg")})}},d),m=t("Accessor",null,{$documentation:"A getter/setter function",_validate:function(){if(null!=this.name)throw new Error("name must be null")}},p),_=t("LambdaExpression","inlined",{$documentation:"Base class for function expressions",$propdoc:{inlined:"[boolean/S] whether this function has been inlined"},_validate:function(){if("LambdaExpression"==this.TYPE)throw new Error("should not instantiate AST_LambdaExpression")}},p);function S(t){return t instanceof ut||t instanceof ct}var ut=t("Arrow","value",{$documentation:"An arrow function expression",$propdoc:{value:"[AST_Node?] simple return expression, or null if using function body."},walk:function(e){var t=this;e.visit(t,function(){t.argnames.forEach(function(t){t.walk(e)}),t.rest&&t.rest.walk(e),t.value?t.value.walk(e):l(t,e)})},_validate:function(){if(null!=this.name)throw new Error("name must be null");if(this.uses_arguments)throw new Error("uses_arguments must be false");if(null!=this.value&&(n(this,"value"),this.body.length))throw new Error("body must be empty if value exists")}},_),ct=t("AsyncArrow","value",{$documentation:"An asynchronous arrow function expression",$propdoc:{value:"[AST_Node?] simple return expression, or null if using function body."},walk:function(e){var t=this;e.visit(t,function(){t.argnames.forEach(function(t){t.walk(e)}),t.rest&&t.rest.walk(e),t.value?t.value.walk(e):l(t,e)})},_validate:function(){if(null!=this.name)throw new Error("name must be null");if(this.uses_arguments)throw new Error("uses_arguments must be false");if(null!=this.value&&(n(this,"value"),this.body.length))throw new Error("body must be empty if value exists")}},_),ft=t("AsyncFunction","name",{$documentation:"An asynchronous function expression",$propdoc:{name:"[AST_SymbolLambda?] the name of this function, or null if not specified"},_validate:function(){if(null!=this.name&&!(this.name instanceof ge))throw new Error("name must be AST_SymbolLambda")}},_),ht=t("AsyncGeneratorFunction","name",{$documentation:"An asynchronous generator function expression",$propdoc:{name:"[AST_SymbolLambda?] the name of this function, or null if not specified"},_validate:function(){if(null!=this.name&&!(this.name instanceof ge))throw new Error("name must be AST_SymbolLambda")}},_),dt=t("Function","name",{$documentation:"A function expression",$propdoc:{name:"[AST_SymbolLambda?] the name of this function, or null if not specified"},_validate:function(){if(null!=this.name&&!(this.name instanceof ge))throw new Error("name must be AST_SymbolLambda")}},_),pt=t("GeneratorFunction","name",{$documentation:"A generator function expression",$propdoc:{name:"[AST_SymbolLambda?] the name of this function, or null if not specified"},_validate:function(){if(null!=this.name&&!(this.name instanceof ge))throw new Error("name must be AST_SymbolLambda")}},_),b=t("LambdaDefinition","inlined name",{$documentation:"Base class for function definitions",$propdoc:{inlined:"[boolean/S] whether this function has been inlined",name:"[AST_SymbolDefun] the name of this function"},_validate:function(){if("LambdaDefinition"==this.TYPE)throw new Error("should not instantiate AST_LambdaDefinition");if(!(this.name instanceof Ee))throw new Error("name must be AST_SymbolDefun")}},p),mt=t("AsyncDefun",null,{$documentation:"An asynchronous function definition"},b),_t=t("AsyncGeneratorDefun",null,{$documentation:"An asynchronous generator function definition"},b),St=t("Defun",null,{$documentation:"A function definition"},b),bt=t("GeneratorDefun",null,{$documentation:"A generator function definition"},b),w=t("Class","extends name properties",{$documentation:"Base class for class literals",$propdoc:{extends:"[AST_Node?] the super class, or null if not specified",properties:"[AST_ClassProperty*] array of class properties"},_equals:function(t){return i(this.name,t.name)&&i(this.extends,t.extends)&&o(this.properties,t.properties)},resolve:function(t){return t?this:this.parent_scope.resolve()},walk:function(e){var t=this;e.visit(t,function(){t.name&&t.name.walk(e),t.extends&&t.extends.walk(e),t.properties.forEach(function(t){t.walk(e)})})},_validate:function(){if("Class"==this.TYPE)throw new Error("should not instantiate AST_Class");null!=this.extends&&n(this,"extends"),this.properties.forEach(function(t){if(!(t instanceof v))throw new Error("properties must contain AST_ClassProperty")})}},s),wt=t("DefClass",null,{$documentation:"A class definition",$propdoc:{name:"[AST_SymbolDefClass] the name of this class"},_validate:function(){if(!(this.name instanceof ke))throw new Error("name must be AST_SymbolDefClass")}},w),vt=t("ClassExpression",null,{$documentation:"A class expression",$propdoc:{name:"[AST_SymbolClass?] the name of this class, or null if not specified"},_validate:function(){if(null!=this.name&&!(this.name instanceof xe))throw new Error("name must be AST_SymbolClass")}},w),v=t("ClassProperty","key private static value",{$documentation:"Base class for `class` properties",$propdoc:{key:"[string|AST_Node?] property name (AST_Node for computed property, null for initialization block)",private:"[boolean] whether this is a private property",static:"[boolean] whether this is a static property",value:"[AST_Node?] property value (AST_Accessor for getters/setters, AST_LambdaExpression for methods, null if not specified for fields)"},_equals:function(t){return!this.private==!t.private&&!this.static==!t.static&&i(this.key,t.key)&&i(this.value,t.value)},walk:function(t){var e=this;t.visit(e,function(){e.key instanceof u&&e.key.walk(t),e.value&&e.value.walk(t)})},_validate:function(){if("ClassProperty"==this.TYPE)throw new Error("should not instantiate AST_ClassProperty");if(this instanceof gt){if(null!=this.key)throw new Error("key must be null")}else if("string"!=typeof this.key){if(!(this.key instanceof u))throw new Error("key must be string or AST_Node");n(this,"key")}if(null!=this.value&&!(this.value instanceof u))throw new Error("value must be AST_Node")}}),yt=t("ClassField",null,{$documentation:"A `class` field",_validate:function(){null!=this.value&&n(this,"value")}},v),At=t("ClassGetter",null,{$documentation:"A `class` getter",_validate:function(){if(!(this.value instanceof m))throw new Error("value must be AST_Accessor")}},v),Tt=t("ClassSetter",null,{$documentation:"A `class` setter",_validate:function(){if(!(this.value instanceof m))throw new Error("value must be AST_Accessor")}},v),Et=t("ClassMethod",null,{$documentation:"A `class` method",_validate:function(){if(!(this.value instanceof _))throw new Error("value must be AST_LambdaExpression");if(S(this.value))throw new Error("value cannot be AST_Arrow or AST_AsyncArrow");if(null!=this.value.name)throw new Error("name of class method's lambda must be null")}},v),gt=t("ClassInit",null,{$documentation:"A `class` static initialization block",_validate:function(){if(!this.static)throw new Error("static must be true");if(!(this.value instanceof lt))throw new Error("value must be AST_ClassInitBlock")},initialize:function(){this.static=!0}},v),kt=t("Jump",null,{$documentation:"Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)",_validate:function(){if("Jump"==this.TYPE)throw new Error("should not instantiate AST_Jump")}},e),xt=t("Exit","value",{$documentation:"Base class for “exits” (`return` and `throw`)",$propdoc:{value:"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"},_equals:function(t){return i(this.value,t.value)},walk:function(t){var e=this;t.visit(e,function(){e.value&&e.value.walk(t)})},_validate:function(){if("Exit"==this.TYPE)throw new Error("should not instantiate AST_Exit")}},kt),$t=t("Return",null,{$documentation:"A `return` statement",_validate:function(){null!=this.value&&n(this,"value")}},xt),qt=t("Throw",null,{$documentation:"A `throw` statement",_validate:function(){n(this,"value")}},xt),y=t("LoopControl","label",{$documentation:"Base class for loop control statements (`break` and `continue`)",$propdoc:{label:"[AST_LabelRef?] the label, or null if none"},_equals:function(t){return i(this.label,t.label)},walk:function(t){var e=this;t.visit(e,function(){e.label&&e.label.walk(t)})},_validate:function(){if("LoopControl"==this.TYPE)throw new Error("should not instantiate AST_LoopControl");if(null!=this.label&&!(this.label instanceof Ce))throw new Error("label must be AST_LabelRef")}},kt),Dt=t("Break",null,{$documentation:"A `break` statement"},y),Nt=t("Continue",null,{$documentation:"A `continue` statement"},y),Ct=t("If","condition alternative",{$documentation:"A `if` statement",$propdoc:{condition:"[AST_Node] the `if` condition",alternative:"[AST_Statement?] the `else` part, or null if not present"},_equals:function(t){return this.body.equals(t.body)&&this.condition.equals(t.condition)&&i(this.alternative,t.alternative)},walk:function(t){var e=this;t.visit(e,function(){e.condition.walk(t),e.body.walk(t),e.alternative&&e.alternative.walk(t)})},_validate:function(){if(n(this,"condition"),null!=this.alternative&&!r(this.alternative))throw new Error("alternative must be AST_Statement")}},f),Pt=t("Switch","expression",{$documentation:"A `switch` statement",$propdoc:{expression:"[AST_Node] the `switch` “discriminant”"},_equals:function(t){return this.expression.equals(t.expression)&&o(this.body,t.body)},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t),l(e,t)})},_validate:function(){n(this,"expression"),this.body.forEach(function(t){if(!(t instanceof Bt))throw new Error("body must be AST_SwitchBranch[]")})}},c),Bt=t("SwitchBranch",null,{$documentation:"Base class for `switch` branches",_validate:function(){if("SwitchBranch"==this.TYPE)throw new Error("should not instantiate AST_SwitchBranch")}},c),Lt=t("Default",null,{$documentation:"A `default` switch branch"},Bt),Ot=t("Case","expression",{$documentation:"A `case` switch branch",$propdoc:{expression:"[AST_Node] the `case` expression"},_equals:function(t){return this.expression.equals(t.expression)&&o(this.body,t.body)},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t),l(e,t)})},_validate:function(){n(this,"expression")}},Bt),jt=t("Try","bcatch bfinally",{$documentation:"A `try` statement",$propdoc:{bcatch:"[AST_Catch?] the catch block, or null if not present",bfinally:"[AST_Finally?] the finally block, or null if not present"},_equals:function(t){return o(this.body,t.body)&&i(this.bcatch,t.bcatch)&&i(this.bfinally,t.bfinally)},walk:function(t){var e=this;t.visit(e,function(){l(e,t),e.bcatch&&e.bcatch.walk(t),e.bfinally&&e.bfinally.walk(t)})},_validate:function(){if(null!=this.bcatch&&!(this.bcatch instanceof Ft))throw new Error("bcatch must be AST_Catch");if(null!=this.bfinally&&!(this.bfinally instanceof It))throw new Error("bfinally must be AST_Finally")}},c),Ft=t("Catch","argname",{$documentation:"A `catch` node; only makes sense as part of a `try` statement",$propdoc:{argname:"[(AST_Destructured|AST_SymbolCatch)?] symbol for the exception, or null if not present"},_equals:function(t){return i(this.argname,t.argname)&&o(this.body,t.body)},walk:function(t){var e=this;t.visit(e,function(){e.argname&&e.argname.walk(t),l(e,t)})},_validate:function(){null!=this.argname&&k(this.argname,function(t){if(!(t instanceof $e))throw new Error("argname must be AST_SymbolCatch")})}},c),It=t("Finally",null,{$documentation:"A `finally` node; only makes sense as part of a `try` statement"},c),A=t("Definitions","definitions",{$documentation:"Base class for `var` nodes (variable declarations/initializations)",$propdoc:{definitions:"[AST_VarDef*] array of variable definitions"},_equals:function(t){return o(this.definitions,t.definitions)},walk:function(e){var t=this;e.visit(t,function(){t.definitions.forEach(function(t){t.walk(e)})})},_validate:function(){if("Definitions"==this.TYPE)throw new Error("should not instantiate AST_Definitions");if(this.definitions.length<1)throw new Error("must have at least one definition")}},e),Yt=t("Const",null,{$documentation:"A `const` statement",_validate:function(){this.definitions.forEach(function(t){if(!(t instanceof T))throw new Error("definitions must be AST_VarDef[]");k(t.name,function(t){if(!(t instanceof we))throw new Error("name must be AST_SymbolConst")})})}},A),Rt=t("Let",null,{$documentation:"A `let` statement",_validate:function(){this.definitions.forEach(function(t){if(!(t instanceof T))throw new Error("definitions must be AST_VarDef[]");k(t.name,function(t){if(!(t instanceof ye))throw new Error("name must be AST_SymbolLet")})})}},A),Vt=t("Var",null,{$documentation:"A `var` statement",_validate:function(){this.definitions.forEach(function(t){if(!(t instanceof T))throw new Error("definitions must be AST_VarDef[]");k(t.name,function(t){if(!(t instanceof Ae))throw new Error("name must be AST_SymbolVar")})})}},A),T=t("VarDef","name value",{$documentation:"A variable declaration; only appears in a AST_Definitions node",$propdoc:{name:"[AST_Destructured|AST_SymbolVar] name of the variable",value:"[AST_Node?] initializer, or null of there's no initializer"},_equals:function(t){return this.name.equals(t.name)&&i(this.value,t.value)},walk:function(t){var e=this;t.visit(e,function(){e.name.walk(t),e.value&&e.value.walk(t)})},_validate:function(){null!=this.value&&n(this,"value")}}),Gt=t("ExportDeclaration","body",{$documentation:"An `export` statement",$propdoc:{body:"[AST_DefClass|AST_Definitions|AST_LambdaDefinition] the statement to export"},_equals:function(t){return this.body.equals(t.body)},walk:function(t){var e=this;t.visit(e,function(){e.body.walk(t)})},_validate:function(){if(!(this.body instanceof wt||this.body instanceof A||this.body instanceof b))throw new Error("body must be AST_DefClass, AST_Definitions or AST_LambdaDefinition")}},e),Wt=t("ExportDefault","body",{$documentation:"An `export default` statement",$propdoc:{body:"[AST_Node] the default export"},_equals:function(t){return this.body.equals(t.body)},walk:function(t){var e=this;t.visit(e,function(){e.body.walk(t)})},_validate:function(){this.body instanceof wt||this.body instanceof b||n(this,"body")}},e),zt=t("ExportForeign","aliases keys path",{$documentation:"An `export ... from '...'` statement",$propdoc:{aliases:"[AST_String*] array of aliases to export",keys:"[AST_String*] array of keys to import",path:"[AST_String] the path to import module"},_equals:function(t){return this.path.equals(t.path)&&o(this.aliases,t.aliases)&&o(this.keys,t.keys)},_validate:function(){if(this.aliases.length!=this.keys.length)throw new Error("aliases:key length mismatch: "+this.aliases.length+" != "+this.keys.length);if(this.aliases.forEach(function(t){if(!(t instanceof C))throw new Error("aliases must contain AST_String")}),this.keys.forEach(function(t){if(!(t instanceof C))throw new Error("keys must contain AST_String")}),!(this.path instanceof C))throw new Error("path must be AST_String")}},e),Ut=t("ExportReferences","properties",{$documentation:"An `export { ... }` statement",$propdoc:{properties:"[AST_SymbolExport*] array of aliases to export"},_equals:function(t){return o(this.properties,t.properties)},walk:function(e){var t=this;e.visit(t,function(){t.properties.forEach(function(t){t.walk(e)})})},_validate:function(){this.properties.forEach(function(t){if(!(t instanceof Ne))throw new Error("properties must contain AST_SymbolExport")})}},e),Ht=t("Import","all default path properties",{$documentation:"An `import` statement",$propdoc:{all:"[AST_SymbolImport?] the imported namespace, or null if not specified",default:"[AST_SymbolImport?] the alias for default `export`, or null if not specified",path:"[AST_String] the path to import module",properties:"[(AST_SymbolImport*)?] array of aliases, or null if not specified"},_equals:function(t){return this.path.equals(t.path)&&i(this.all,t.all)&&i(this.default,t.default)&&!this.properties==!t.properties&&(!this.properties||o(this.properties,t.properties))},walk:function(e){var t=this;e.visit(t,function(){t.all&&t.all.walk(e),t.default&&t.default.walk(e),t.properties&&t.properties.forEach(function(t){t.walk(e)})})},_validate:function(){if(null!=this.all){if(!(this.all instanceof ve))throw new Error("all must be AST_SymbolImport");if(null!=this.properties)throw new Error("cannot import both * and {} in the same statement")}if(null!=this.default){if(!(this.default instanceof ve))throw new Error("default must be AST_SymbolImport");if(""!==this.default.key.value)throw new Error("invalid default key: "+this.default.key.value)}if(!(this.path instanceof C))throw new Error("path must be AST_String");null!=this.properties&&this.properties.forEach(function(t){if(!(t instanceof ve))throw new Error("properties must contain AST_SymbolImport")})}},e),Mt=t("DefaultValue","name value",{$documentation:"A default value declaration",$propdoc:{name:"[AST_Destructured|AST_SymbolDeclaration] name of the variable",value:"[AST_Node] value to assign if variable is `undefined`"},_equals:function(t){return this.name.equals(t.name)&&this.value.equals(t.value)},walk:function(t){var e=this;t.visit(e,function(){e.name.walk(t),e.value.walk(t)})},_validate:function(){n(this,"value")}});function Jt(t,e,n,o){t[e].forEach(function(t){M(t,e,!0,n,o)})}var Kt=t("Call","args expression optional pure terminal",{$documentation:"A function call expression",$propdoc:{args:"[AST_Node*] array of arguments",expression:"[AST_Node] expression to invoke as function",optional:"[boolean] whether the expression is optional chaining",pure:"[boolean/S] marker for side-effect-free call expression",terminal:"[boolean] whether the chain has ended"},_equals:function(t){return!this.optional==!t.optional&&this.expression.equals(t.expression)&&o(this.args,t.args)},walk:function(e){var t=this;e.visit(t,function(){t.expression.walk(e),t.args.forEach(function(t){t.walk(e)})})},_validate:function(){n(this,"expression"),Jt(this,"args",!0)}}),Qt=t("New",null,{$documentation:"An object instantiation.  Derives from a function call since it has exactly the same properties",_validate:function(){if(this.optional)throw new Error("optional must be false");if(this.terminal)throw new Error("terminal must be false")}},Kt),Xt=t("Sequence","expressions",{$documentation:"A sequence expression (comma-separated expressions)",$propdoc:{expressions:"[AST_Node*] array of expressions (at least two)"},_equals:function(t){return o(this.expressions,t.expressions)},walk:function(e){var t=this;e.visit(t,function(){t.expressions.forEach(function(t){t.walk(e)})})},_validate:function(){if(this.expressions.length<2)throw new Error("expressions must contain multiple elements");Jt(this,"expressions")}});var E=t("PropAccess","expression optional property terminal",{$documentation:'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`',$propdoc:{expression:"[AST_Node] the “container” expression",optional:"[boolean] whether the expression is optional chaining",property:"[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node",terminal:"[boolean] whether the chain has ended"},_equals:function(t){return!this.optional==!t.optional&&i(this.property,t.property)&&this.expression.equals(t.expression)},get_property:function(){var t=this.property;return t instanceof N?t.value:t instanceof oe&&"void"==t.operator&&t.expression instanceof N?void 0:t},_validate:function(){if("PropAccess"==this.TYPE)throw new Error("should not instantiate AST_PropAccess");n(this,"expression")}}),Zt=t("Dot","quoted",{$documentation:"A dotted property access expression",$propdoc:{quoted:"[boolean] whether property is transformed from a quoted string"},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t)})},_validate:function(){if("string"!=typeof this.property)throw new Error("property must be string")}},E),te=t("Sub",null,{$documentation:'Index-style property access, i.e. `a["foo"]`',walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t),e.property.walk(t)})},_validate:function(){n(this,"property")}},E),ee=t("Spread","expression",{$documentation:"Spread expression in array/object literals or function calls",$propdoc:{expression:"[AST_Node] expression to be expanded"},_equals:function(t){return this.expression.equals(t.expression)},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t)})},_validate:function(){n(this,"expression")}}),ne=t("Unary","operator expression",{$documentation:"Base class for unary expressions",$propdoc:{operator:"[string] the operator",expression:"[AST_Node] expression that this unary operator applies to"},_equals:function(t){return this.operator==t.operator&&this.expression.equals(t.expression)},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t)})},_validate:function(){if("Unary"==this.TYPE)throw new Error("should not instantiate AST_Unary");if("string"!=typeof this.operator)throw new Error("operator must be string");n(this,"expression")}}),oe=t("UnaryPrefix",null,{$documentation:"Unary prefix expression, i.e. `typeof i` or `++i`"},ne),ie=t("UnaryPostfix",null,{$documentation:"Unary postfix expression, i.e. `i++`"},ne),ae=t("Binary","operator left right",{$documentation:"Binary expression, i.e. `a + b`",$propdoc:{left:"[AST_Node] left-hand side expression",operator:"[string] the operator",right:"[AST_Node] right-hand side expression"},_equals:function(t){return this.operator==t.operator&&this.left.equals(t.left)&&this.right.equals(t.right)},walk:function(t){var e=this;t.visit(e,function(){e.left.walk(t),e.right.walk(t)})},_validate:function(){if(this instanceof se||n(this,"left"),"string"!=typeof this.operator)throw new Error("operator must be string");n(this,"right")}}),re=t("Conditional","condition consequent alternative",{$documentation:"Conditional expression using the ternary operator, i.e. `a ? b : c`",$propdoc:{condition:"[AST_Node]",consequent:"[AST_Node]",alternative:"[AST_Node]"},_equals:function(t){return this.condition.equals(t.condition)&&this.consequent.equals(t.consequent)&&this.alternative.equals(t.alternative)},walk:function(t){var e=this;t.visit(e,function(){e.condition.walk(t),e.consequent.walk(t),e.alternative.walk(t)})},_validate:function(){n(this,"condition"),n(this,"consequent"),n(this,"alternative")}}),se=t("Assign",null,{$documentation:"An assignment expression — `a = b + 5`",_validate:function(){if(this.operator.indexOf("=")<0)throw new Error('operator must contain "="');if(this.left instanceof g){if("="!=this.operator)throw new Error("invalid destructuring operator: "+this.operator);k(this.left,function(t){if(!(t instanceof E||t instanceof De))throw new Error("left must be assignable: "+t.TYPE)})}else if(!(this.left instanceof ze||this.left instanceof Ve||this.left instanceof E&&!this.left.optional||this.left instanceof De||this.left instanceof Ge))throw new Error("left must be assignable")}},ae),le=t("Await","expression",{$documentation:"An await expression",$propdoc:{expression:"[AST_Node] expression with Promise to resolve on"},_equals:function(t){return this.expression.equals(t.expression)},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t)})},_validate:function(){n(this,"expression")}}),ue=t("Yield","expression nested",{$documentation:"A yield expression",$propdoc:{expression:"[AST_Node?] return value for iterator, or null if undefined",nested:"[boolean] whether to iterate over expression as generator"},_equals:function(t){return!this.nested==!t.nested&&i(this.expression,t.expression)},walk:function(t){var e=this;t.visit(e,function(){e.expression&&e.expression.walk(t)})},_validate:function(){if(null!=this.expression)n(this,"expression");else if(this.nested)throw new Error("yield* must contain expression")}}),ce=t("Array","elements",{$documentation:"An array literal",$propdoc:{elements:"[AST_Node*] array of elements"},_equals:function(t){return o(this.elements,t.elements)},walk:function(e){var t=this;e.visit(t,function(){t.elements.forEach(function(t){t.walk(e)})})},_validate:function(){Jt(this,"elements",!0,!0)}}),g=t("Destructured","rest",{$documentation:"Base class for destructured literal",$propdoc:{rest:"[(AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef)?] rest parameter, or null if absent"},_validate:function(){if("Destructured"==this.TYPE)throw new Error("should not instantiate AST_Destructured")}});function k(t,e,n){if(t instanceof Mt&&n)return k(t.name,e);if(t instanceof g){if(null!=t.rest&&k(t.rest,e),t instanceof fe)return t.elements.forEach(function(t){t instanceof We||k(t,e,!0)});if(t instanceof de)return t.properties.forEach(function(t){k(t.value,e,!0)})}e(t)}var x,fe=t("DestructuredArray","elements",{$documentation:"A destructured array literal",$propdoc:{elements:"[(AST_DefaultValue|AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef)*] array of elements"},_equals:function(t){return i(this.rest,t.rest)&&o(this.elements,t.elements)},walk:function(e){var t=this;e.visit(t,function(){t.elements.forEach(function(t){t.walk(e)}),t.rest&&t.rest.walk(e)})}},g),he=t("DestructuredKeyVal","key value",{$documentation:"A key: value destructured property",$propdoc:{key:"[string|AST_Node] property name.  For computed property this is an AST_Node.",value:"[AST_DefaultValue|AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef] property value"},_equals:function(t){return i(this.key,t.key)&&this.value.equals(t.value)},walk:function(t){var e=this;t.visit(e,function(){e.key instanceof u&&e.key.walk(t),e.value.walk(t)})},_validate:function(){if("string"!=typeof this.key){if(!(this.key instanceof u))throw new Error("key must be string or AST_Node");n(this,"key")}if(!(this.value instanceof u))throw new Error("value must be AST_Node")}}),de=t("DestructuredObject","properties",{$documentation:"A destructured object literal",$propdoc:{properties:"[AST_DestructuredKeyVal*] array of properties"},_equals:function(t){return i(this.rest,t.rest)&&o(this.properties,t.properties)},walk:function(e){var t=this;e.visit(t,function(){t.properties.forEach(function(t){t.walk(e)}),t.rest&&t.rest.walk(e)})},_validate:function(){this.properties.forEach(function(t){if(!(t instanceof he))throw new Error("properties must be AST_DestructuredKeyVal[]")})}},g),pe=t("Object","properties",{$documentation:"An object literal",$propdoc:{properties:"[(AST_ObjectProperty|AST_Spread)*] array of properties"},_equals:function(t){return o(this.properties,t.properties)},walk:function(e){var t=this;e.visit(t,function(){t.properties.forEach(function(t){t.walk(e)})})},_validate:function(){this.properties.forEach(function(t){if(!(t instanceof $||t instanceof ee))throw new Error("properties must contain AST_ObjectProperty and/or AST_Spread only")})}}),$=t("ObjectProperty","key value",{$documentation:"Base class for literal object properties",$propdoc:{key:"[string|AST_Node] property name.  For computed property this is an AST_Node.",value:"[AST_Node] property value.  For getters and setters this is an AST_Accessor."},_equals:function(t){return i(this.key,t.key)&&this.value.equals(t.value)},walk:function(t){var e=this;t.visit(e,function(){e.key instanceof u&&e.key.walk(t),e.value.walk(t)})},_validate:function(){if("ObjectProperty"==this.TYPE)throw new Error("should not instantiate AST_ObjectProperty");if("string"!=typeof this.key){if(!(this.key instanceof u))throw new Error("key must be string or AST_Node");n(this,"key")}if(!(this.value instanceof u))throw new Error("value must be AST_Node")}}),me=t("ObjectKeyVal",null,{$documentation:"A key: value object property",_validate:function(){n(this,"value")}},$),_e=t("ObjectMethod",null,{$documentation:"A key(){} object property",_validate:function(){if(!(this.value instanceof _))throw new Error("value must be AST_LambdaExpression");if(S(this.value))throw new Error("value cannot be AST_Arrow or AST_AsyncArrow");if(null!=this.value.name)throw new Error("name of object method's lambda must be null")}},me),Se=t("ObjectSetter",null,{$documentation:"An object setter property",_validate:function(){if(!(this.value instanceof m))throw new Error("value must be AST_Accessor")}},$),be=t("ObjectGetter",null,{$documentation:"An object getter property",_validate:function(){if(!(this.value instanceof m))throw new Error("value must be AST_Accessor")}},$),q=t("Symbol","scope name thedef",{$documentation:"Base class for all symbols",$propdoc:{name:"[string] name of this symbol",scope:"[AST_Scope/S] the current scope (not necessarily the definition scope)",thedef:"[SymbolDef/S] the definition of this symbol"},_equals:function(t){return this.thedef?this.thedef===t.thedef:this.name==t.name},_validate:function(){if("Symbol"==this.TYPE)throw new Error("should not instantiate AST_Symbol");if("string"!=typeof this.name)throw new Error("name must be string")}}),D=t("SymbolDeclaration","init",{$documentation:"A declaration symbol (symbol in var, function name or argument, symbol in catch)"},q),we=t("SymbolConst",null,{$documentation:"Symbol defining a constant"},D),ve=t("SymbolImport","key",{$documentation:"Symbol defined by an `import` statement",$propdoc:{key:"[AST_String] the original `export` name"},_equals:function(t){return this.name==t.name&&this.key.equals(t.key)},_validate:function(){if(!(this.key instanceof C))throw new Error("key must be AST_String")}},we),ye=t("SymbolLet",null,{$documentation:"Symbol defining a lexical-scoped variable"},D),Ae=t("SymbolVar",null,{$documentation:"Symbol defining a variable"},D),Te=t("SymbolFunarg","unused",{$documentation:"Symbol naming a function argument"},Ae),Ee=t("SymbolDefun",null,{$documentation:"Symbol defining a function"},D),ge=t("SymbolLambda",null,{$documentation:"Symbol naming a function expression"},D),ke=t("SymbolDefClass",null,{$documentation:"Symbol defining a class"},we),xe=t("SymbolClass",null,{$documentation:"Symbol naming a class expression"},we),$e=t("SymbolCatch",null,{$documentation:"Symbol naming the exception in catch"},D),qe=t("Label","references",{$documentation:"Symbol naming a label (declaration)",$propdoc:{references:"[AST_LoopControl*] a list of nodes referring to this label"},initialize:function(){this.references=[],this.thedef=this}},q),De=t("SymbolRef","fixed in_arg redef",{$documentation:"Reference to some symbol (not definition/declaration)"},q),Ne=t("SymbolExport","alias",{$documentation:"Reference in an `export` statement",$propdoc:{alias:"[AST_String] the `export` alias"},_equals:function(t){return this.name==t.name&&this.alias.equals(t.alias)},_validate:function(){if(!(this.alias instanceof C))throw new Error("alias must be AST_String")}},De),Ce=t("LabelRef",null,{$documentation:"Reference to a label symbol"},q),Pe=t("ObjectIdentity",null,{$documentation:"Base class for `super` & `this`",_equals:V,_validate:function(){if("ObjectIdentity"==this.TYPE)throw new Error("should not instantiate AST_ObjectIdentity")}},q),Be=t("Super",null,{$documentation:"The `super` symbol",_validate:function(){if("super"!==this.name)throw new Error('name must be "super"')}},Pe),Le=t("This",null,{$documentation:"The `this` symbol",_validate:function(){if("This"==this.TYPE&&"this"!==this.name)throw new Error('name must be "this"')}},Pe),Oe=t("NewTarget",null,{$documentation:"The `new.target` symbol",initialize:function(){this.name="new.target"},_validate:function(){if("new.target"!==this.name)throw new Error('name must be "new.target": '+this.name)}},Le),je=t("Template","expressions strings tag",{$documentation:"A template literal, i.e. tag`str1${expr1}...strN${exprN}strN+1`",$propdoc:{expressions:"[AST_Node*] the placeholder expressions",strings:"[string*] the raw text segments",tag:"[AST_Node?] tag function, or null if absent"},_equals:function(t){return i(this.tag,t.tag)&&(e=this.strings,n=t.strings,e.length==n.length)&&j(e,function(t,e){return t==n[e]})&&o(this.expressions,t.expressions);var e,n},walk:function(e){var t=this;e.visit(t,function(){t.tag&&t.tag.walk(e),t.expressions.forEach(function(t){t.walk(e)})})},_validate:function(){if(this.expressions.length+1!=this.strings.length)throw new Error("malformed template with "+this.expressions.length+" placeholder(s) but "+this.strings.length+" text segment(s)");Jt(this,"expressions"),this.strings.forEach(function(t){if("string"!=typeof t)throw new Error("strings must contain string")}),null!=this.tag&&n(this,"tag")}}),N=t("Constant",null,{$documentation:"Base class for all constants",_equals:function(t){return this.value===t.value},_validate:function(){if("Constant"==this.TYPE)throw new Error("should not instantiate AST_Constant")}}),C=t("String","quote value",{$documentation:"A string literal",$propdoc:{quote:"[string?] the original quote character",value:"[string] the contents of this string"},_validate:function(){if(null!=this.quote){if("string"!=typeof this.quote)throw new Error("quote must be string");if(!/^["']$/.test(this.quote))throw new Error("invalid quote: "+this.quote)}if("string"!=typeof this.value)throw new Error("value must be string")}},N),Fe=t("Number","value",{$documentation:"A number literal",$propdoc:{value:"[number] the numeric value"},_validate:function(){if("number"!=typeof this.value)throw new Error("value must be number");if(!isFinite(this.value))throw new Error("value must be finite");if(this.value<0)throw new Error("value cannot be negative")}},N),Ie=t("BigInt","value",{$documentation:"A BigInt literal",$propdoc:{value:"[string] the numeric representation"},_validate:function(){if("string"!=typeof this.value)throw new Error("value must be string");if("-"==this.value[0])throw new Error("value cannot be negative")}},N),Ye=t("RegExp","value",{$documentation:"A regexp literal",$propdoc:{value:"[RegExp] the actual regexp"},_equals:function(t){return""+this.value==""+t.value},_validate:function(){if(!(this.value instanceof RegExp))throw new Error("value must be RegExp")}},N),P=t("Atom",null,{$documentation:"Base class for atoms",_equals:V,_validate:function(){if("Atom"==this.TYPE)throw new Error("should not instantiate AST_Atom")}},N),Re=t("Null",null,{$documentation:"The `null` atom",value:null},P),Ve=t("NaN",null,{$documentation:"The impossible value",value:NaN},P),Ge=t("Undefined",null,{$documentation:"The `undefined` value",value:void 0},P),We=t("Hole",null,{$documentation:"A hole in an array",value:void 0},P),ze=t("Infinity",null,{$documentation:"The `Infinity` value",value:1/0},P),Ue=t("Boolean",null,{$documentation:"Base class for booleans",_validate:function(){if("Boolean"==this.TYPE)throw new Error("should not instantiate AST_Boolean")}},P),He=t("False",null,{$documentation:"The `false` atom",value:!1},Ue),Me=t("True",null,{$documentation:"The `true` atom",value:!0},Ue);function B(t){this.callback=t,this.directives=Object.create(null),this.stack=[]}function Je(t,e){B.call(this),this.before=t,this.after=e}function L(t,e){return I(t,function(t){return t.transform(e,!0)})}function Ke(t,e){t.argnames=L(t.argnames,e),t.rest&&(t.rest=t.rest.transform(e)),t.value?t.value=t.value.transform(e):t.body=L(t.body,e)}return B.prototype={visit:function(t,e){this.push(t),!this.callback(t,e||Y)&&e&&e(),this.pop()},parent:function(t){return this.stack[this.stack.length-2-(t||0)]},push:function(t){var e;t instanceof w?(this.directives=Object.create(this.directives),e="use strict"):t instanceof a?e=t.value:t instanceof p&&(this.directives=Object.create(this.directives)),e&&!this.directives[e]&&(this.directives[e]=t),this.stack.push(t)},pop:function(){var t=this.stack.pop();(t instanceof w||t instanceof p)&&(this.directives=Object.getPrototypeOf(this.directives))},self:function(){return this.stack[this.stack.length-1]},find_parent:function(t){for(var e=this.stack,n=e.length-1;0<=--n;){var o=e[n];if(o instanceof t)return o}},has_directive:function(t){var e=this.directives[t];if(e)return e;var n=this.stack[this.stack.length-1];if(n instanceof d)for(var o=0;o<n.body.length;++o){var i=n.body[o];if(!(i instanceof a))break;if(i.value==t)return i}},loopcontrol_target:function(t){var e,n=this.stack;if(t.label){for(var o=n.length;0<=--o;)if((e=n[o])instanceof Q&&e.label.name==t.label.name)return e.body}else for(o=n.length;0<=--o;)if((e=n[o])instanceof h||t instanceof Dt&&e instanceof Pt)return e},in_boolean_context:function(){for(var t,e=!0,n=0,o=this.self();t=this.parent(n++);o=t){if(t instanceof ae)switch(t.operator){case"&&":case"||":t.left===o&&(e=!1);continue;default:return!1}if(!(t instanceof re)){if(t instanceof X)return t.condition===o;if(t instanceof et)return t.condition===o;if(t instanceof Ct)return t.condition===o;if(t instanceof $t){if(t.in_bool)return!0;for(;t=this.parent(n++);)if(t instanceof p){if(t.name)return!1;if("Call"!=(t=this.parent(n++)).TYPE)return!1;break}}if(t instanceof Xt){if(t.tail_node()===o)continue;return!e||"d"}return t instanceof J?!e||"d":t instanceof oe&&"!"==t.operator}if(t.condition===o)return!0}}},Je.prototype=new B,(x=function(t,o){t.DEFMETHOD("transform",function(t,e){var n;return t.push(this),void 0===(n=t.before?t.before(this,o,e):n)&&(o(n=this,t),t.after)&&void 0!==(e=t.after(n,e))&&(n=e),t.pop(),n})})(u,Y),x(Q,function(t,e){t.label=t.label.transform(e),t.body=t.body.transform(e)}),x(J,function(t,e){t.body=t.body.transform(e)}),x(c,function(t,e){t.body=L(t.body,e)}),x(Z,function(t,e){t.body=t.body.transform(e),t.condition=t.condition.transform(e)}),x(tt,function(t,e){t.condition=t.condition.transform(e),t.body=t.body.transform(e)}),x(et,function(t,e){t.init&&(t.init=t.init.transform(e)),t.condition&&(t.condition=t.condition.transform(e)),t.step&&(t.step=t.step.transform(e)),t.body=t.body.transform(e)}),x(nt,function(t,e){t.init=t.init.transform(e),t.object=t.object.transform(e),t.body=t.body.transform(e)}),x(rt,function(t,e){t.expression=t.expression.transform(e),t.body=t.body.transform(e)}),x(xt,function(t,e){t.value&&(t.value=t.value.transform(e))}),x(y,function(t,e){t.label&&(t.label=t.label.transform(e))}),x(Ct,function(t,e){t.condition=t.condition.transform(e),t.body=t.body.transform(e),t.alternative&&(t.alternative=t.alternative.transform(e))}),x(Pt,function(t,e){t.expression=t.expression.transform(e),t.body=L(t.body,e)}),x(Ot,function(t,e){t.expression=t.expression.transform(e),t.body=L(t.body,e)}),x(jt,function(t,e){t.body=L(t.body,e),t.bcatch&&(t.bcatch=t.bcatch.transform(e)),t.bfinally&&(t.bfinally=t.bfinally.transform(e))}),x(Ft,function(t,e){t.argname&&(t.argname=t.argname.transform(e)),t.body=L(t.body,e)}),x(A,function(t,e){t.definitions=L(t.definitions,e)}),x(T,function(t,e){t.name=t.name.transform(e),t.value&&(t.value=t.value.transform(e))}),x(Mt,function(t,e){t.name=t.name.transform(e),t.value=t.value.transform(e)}),x(p,function(t,e){t.name&&(t.name=t.name.transform(e)),t.argnames=L(t.argnames,e),t.rest&&(t.rest=t.rest.transform(e)),t.body=L(t.body,e)}),x(ut,Ke),x(ct,Ke),x(w,function(t,e){t.name&&(t.name=t.name.transform(e)),t.extends&&(t.extends=t.extends.transform(e)),t.properties=L(t.properties,e)}),x(v,function(t,e){t.key instanceof u&&(t.key=t.key.transform(e)),t.value&&(t.value=t.value.transform(e))}),x(Kt,function(t,e){t.expression=t.expression.transform(e),t.args=L(t.args,e)}),x(Xt,function(t,e){t.expressions=L(t.expressions,e)}),x(le,function(t,e){t.expression=t.expression.transform(e)}),x(ue,function(t,e){t.expression&&(t.expression=t.expression.transform(e))}),x(Zt,function(t,e){t.expression=t.expression.transform(e)}),x(te,function(t,e){t.expression=t.expression.transform(e),t.property=t.property.transform(e)}),x(ee,function(t,e){t.expression=t.expression.transform(e)}),x(ne,function(t,e){t.expression=t.expression.transform(e)}),x(ae,function(t,e){t.left=t.left.transform(e),t.right=t.right.transform(e)}),x(re,function(t,e){t.condition=t.condition.transform(e),t.consequent=t.consequent.transform(e),t.alternative=t.alternative.transform(e)}),x(ce,function(t,e){t.elements=L(t.elements,e)}),x(fe,function(t,e){t.elements=L(t.elements,e),t.rest&&(t.rest=t.rest.transform(e))}),x(he,function(t,e){t.key instanceof u&&(t.key=t.key.transform(e)),t.value=t.value.transform(e)}),x(de,function(t,e){t.properties=L(t.properties,e),t.rest&&(t.rest=t.rest.transform(e))}),x(pe,function(t,e){t.properties=L(t.properties,e)}),x($,function(t,e){t.key instanceof u&&(t.key=t.key.transform(e)),t.value=t.value.transform(e)}),x(Gt,function(t,e){t.body=t.body.transform(e)}),x(Wt,function(t,e){t.body=t.body.transform(e)}),x(Ut,function(t,e){t.properties=L(t.properties,e)}),x(Ht,function(t,e){t.all&&(t.all=t.all.transform(e)),t.default&&(t.default=t.default.transform(e)),t.properties&&(t.properties=L(t.properties,e))}),x(je,function(t,e){t.tag&&(t.tag=t.tag.transform(e)),t.expressions=L(t.expressions,e)}),W={parse:null,DEFNODE:t,AST_Token:O,AST_Node:u,AST_Statement:e,AST_Debugger:U,AST_Directive:a,AST_EmptyStatement:H,AST_SimpleStatement:J,AST_BlockScope:s,AST_Block:c,AST_BlockStatement:K,AST_StatementWithBody:f,AST_LabeledStatement:Q,AST_IterationStatement:h,AST_DWLoop:X,AST_Do:Z,AST_While:tt,AST_For:et,AST_ForEnumeration:nt,AST_ForIn:ot,AST_ForOf:it,AST_ForAwaitOf:at,AST_With:rt,AST_Scope:d,AST_Toplevel:st,AST_ClassInitBlock:lt,AST_Lambda:p,AST_Accessor:m,AST_LambdaExpression:_,AST_Arrow:ut,AST_AsyncArrow:ct,AST_AsyncFunction:ft,AST_Function:dt,AST_GeneratorFunction:pt,AST_AsyncGeneratorFunction:ht,AST_LambdaDefinition:b,AST_AsyncDefun:mt,AST_AsyncGeneratorDefun:_t,AST_Defun:St,AST_GeneratorDefun:bt,AST_Class:w,AST_DefClass:wt,AST_ClassExpression:vt,AST_ClassProperty:v,AST_ClassField:yt,AST_ClassGetter:At,AST_ClassSetter:Tt,AST_ClassMethod:Et,AST_ClassInit:gt,AST_Jump:kt,AST_Exit:xt,AST_Return:$t,AST_Throw:qt,AST_LoopControl:y,AST_Break:Dt,AST_Continue:Nt,AST_If:Ct,AST_Switch:Pt,AST_SwitchBranch:Bt,AST_Default:Lt,AST_Case:Ot,AST_Try:jt,AST_Catch:Ft,AST_Finally:It,AST_Definitions:A,AST_Const:Yt,AST_Let:Rt,AST_Var:Vt,AST_VarDef:T,AST_ExportDeclaration:Gt,AST_ExportDefault:Wt,AST_ExportForeign:zt,AST_ExportReferences:Ut,AST_Import:Ht,AST_DefaultValue:Mt,AST_Call:Kt,AST_New:Qt,AST_Sequence:Xt,AST_PropAccess:E,AST_Dot:Zt,AST_Sub:te,AST_Spread:ee,AST_Unary:ne,AST_UnaryPrefix:oe,AST_UnaryPostfix:ie,AST_Binary:ae,AST_Conditional:re,AST_Assign:se,AST_Await:le,AST_Yield:ue,AST_Array:ce,AST_Destructured:g,AST_DestructuredArray:fe,AST_DestructuredKeyVal:he,AST_DestructuredObject:de,AST_Object:pe,AST_ObjectProperty:$,AST_ObjectKeyVal:me,AST_ObjectMethod:_e,AST_ObjectSetter:Se,AST_ObjectGetter:be,AST_Symbol:q,AST_SymbolDeclaration:D,AST_SymbolConst:we,AST_SymbolImport:ve,AST_SymbolLet:ye,AST_SymbolVar:Ae,AST_SymbolFunarg:Te,AST_SymbolDefun:Ee,AST_SymbolLambda:ge,AST_SymbolDefClass:ke,AST_SymbolClass:xe,AST_SymbolCatch:$e,AST_Label:qe,AST_SymbolRef:De,AST_SymbolExport:Ne,AST_LabelRef:Ce,AST_ObjectIdentity:Pe,AST_Super:Be,AST_This:Le,AST_NewTarget:Oe,AST_Template:je,AST_Constant:N,AST_String:C,AST_Number:Fe,AST_BigInt:Ie,AST_RegExp:Ye,AST_Atom:P,AST_Null:Re,AST_NaN:Ve,AST_Undefined:Ge,AST_Hole:We,AST_Infinity:ze,AST_Boolean:Ue,AST_False:He,AST_True:Me,first_in_statement:function(t,e,n){for(var o,i=t.parent(-1),a=0;o=t.parent(a++);i=o){if(S(o))return e&&o.value===i;if(o instanceof ae){if(o.left===i)continue}else if("Call"==o.TYPE){if(o.expression===i)continue}else if(o instanceof re){if(o.condition===i)continue}else{if(o instanceof Wt)return n;if(o instanceof E){if(o.expression===i)continue}else if(o instanceof Xt){if(o.expressions[0]===i)continue}else{if(o instanceof J)return!0;if(o instanceof je){if(o.tag===i)continue}else if(o instanceof ie&&o.expression===i)continue}}return!1}},root_expr:function(t){for(;t instanceof E;)t=t.expression;return t},is_arrow:S,is_generator:function(t){return t instanceof _t||t instanceof ht||t instanceof bt||t instanceof pt},walk_lambda:function(t,e){S(t)&&t.value?t.value.walk(e):l(t,e)},walk_body:l,is_statement:r,is_async:function(t){return t instanceof ct||t instanceof mt||t instanceof ft||t instanceof _t||t instanceof ht},TreeWalker:B,TreeTransformer:Je}});
//# sourceMappingURL=sourcemaps/ast.js.map
