/**
 * skylark-uglifyjs - A version of uglifyjs that ported to running on skylarkjs.
 * @author Hudaokeji Co.,Ltd
 * @version v0.9.0
 * @link www.skylarkjs.org
 * @license MIT
 */
define(["./utils"],function(t){"use strict";const{HOP:e,List:n,MAP:o,noop:i,DEF_BITPROPS:a,return_true:r,return_this:s}=t;var l;function u(t,n,o,i){void 0===i&&(i=f);var a=n=n?n.split(/\s+/):[];i&&i.PROPS&&(n=n.concat(i.PROPS));var r=["return function AST_",t,"(props){","this._bits=0;","if(props){"];n.forEach(function(t){r.push("this.",t,"=props.",t,";")}),r.push("}");var s=Object.create(i&&i.prototype);(o.initialize||s.initialize)&&r.push("this.initialize();"),r.push("};");var l=new Function(r.join(""))();for(var u in l.prototype=s,l.prototype.CTOR=l,l.prototype.TYPE=l.TYPE=t,i&&(l.BASE=i,i.SUBCLASSES.push(l)),l.DEFMETHOD=function(t,e){this.prototype[t]=e},l.PROPS=n,l.SELF_PROPS=a,l.SUBCLASSES=[],o)e(o,u)&&(/^\$/.test(u)?l[u.substr(1)]=o[u]:l.DEFMETHOD(u,o[u]));return"undefined"!=typeof exports&&(exports["AST_"+t]=l),l}var c=u("Token","type value line col pos endline endcol endpos nlb comments_before comments_after file raw",{},null),f=u("Node","start end",{_clone:function(t){if(t){var e=this.clone();return e.transform(new He(function(t){if(t!==e)return t.clone(!0)}))}return new this.CTOR(this)},clone:function(t){return this._clone(t)},$documentation:"Base class of all AST nodes",$propdoc:{start:"[AST_Token] The first token of this node",end:"[AST_Token] The last token of this node"},equals:function(t){return this.TYPE==t.TYPE&&this._equals(t)},walk:function(t){t.visit(this)},_validate:function(){if("Node"==this.TYPE)throw new Error("should not instantiate AST_Node")},validate:function(){var t=this.CTOR;do{t.prototype._validate.call(this)}while(t=t.BASE)},validate_ast:function(){var t={};this.walk(new Me(function(e){if(e.validate_visited===t)throw new Error(string_template("cannot reuse AST_{TYPE} from [{start}]",e));e.validate_visited=t}))}},null);a(f,["_optimized","_squeezed","call_only","collapse_scanning","defined","evaluating","falsy","in_arg","in_bool","is_undefined","inlined","length_read","nested","new","optional","private","pure","redundant","single_use","static","terminal","truthy","uses_eval","uses_with"]),(f.log_function=function(t,e){if("function"==typeof t){var n=Object.create(null);f.info=e?function(t,e){o("INFO: "+string_template(t,e))}:i,f.warn=function(t,e){o("WARN: "+string_template(t,e))}}else f.info=f.warn=i;function o(e){n[e]||(n[e]=!0,t(e))}})();var h=[];function d(t,e){return t.length==e.length&&all(t,function(t,n){return t.equals(e[n])})}function p(t,e){return t===e||(null==t?null==e:t instanceof f&&e instanceof f&&t.equals(e))}f.enable_validation=function(){f.disable_validation(),function t(o){if(o.SUBCLASSES.forEach(t),e(o.prototype,"transform")){var i=o.prototype.transform;o.prototype.transform=function(t,e){var o=i.call(this,t,e);if(o instanceof f)o.validate();else if(!(null===o||e&&n.is_op(o)))throw new Error("invalid transformed value: "+o);return o},h.push(function(){o.prototype.transform=i})}}(this)},f.disable_validation=function(){for(var t;t=h.pop();)t()};var m=u("Statement",null,{$documentation:"Base class of all statements",_validate:function(){if("Statement"==this.TYPE)throw new Error("should not instantiate AST_Statement")}}),_=u("Debugger",null,{$documentation:"Represents a debugger statement",_equals:r},m),S=u("Directive","quote value",{$documentation:'Represents a directive, like "use strict";',$propdoc:{quote:"[string?] the original quote character",value:"[string] The value of this directive as a plain string (it's not an AST_String!)"},_equals:function(t){return this.value==t.value},_validate:function(){if(null!=this.quote){if("string"!=typeof this.quote)throw new Error("quote must be string");if(!/^["']$/.test(this.quote))throw new Error("invalid quote: "+this.quote)}if("string"!=typeof this.value)throw new Error("value must be string")}},m),b=u("EmptyStatement",null,{$documentation:"The empty statement (empty block or simply a semicolon)",_equals:r},m);function v(t){return t instanceof m&&!(t instanceof at)&&!(t instanceof W)}function w(t,e,n,o,i){if(n=n?"contain":"be",!(t instanceof f))throw new Error(e+" must "+n+" AST_Node");if(t instanceof jt)throw new Error(e+" cannot "+n+" AST_DefaultValue");if(t instanceof ee)throw new Error(e+" cannot "+n+" AST_Destructured");if(t instanceof Ve&&!i)throw new Error(e+" cannot "+n+" AST_Hole");if(t instanceof zt&&!o)throw new Error(e+" cannot "+n+" AST_Spread");if(v(t))throw new Error(e+" cannot "+n+" AST_Statement");if(t instanceof de)throw new Error(e+" cannot "+n+" AST_SymbolDeclaration")}function y(t,e){w(t[e],e)}var A=u("SimpleStatement","body",{$documentation:"A statement consisting of an expression, i.e. a = 1 + 2",$propdoc:{body:"[AST_Node] an expression node (should not be instanceof AST_Statement)"},_equals:function(t){return this.body.equals(t.body)},walk:function(t){var e=this;t.visit(e,function(){e.body.walk(t)})},_validate:function(){y(this,"body")}},m),T=u("BlockScope","_var_names enclosed functions make_def parent_scope variables",{$documentation:"Base class for all statements introducing a lexical scope",$propdoc:{enclosed:"[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any inner scopes",functions:"[Dictionary/S] like `variables`, but only lists function declarations",parent_scope:"[AST_Scope?/S] link to the parent scope",variables:"[Dictionary/S] a map of name ---\x3e SymbolDef for all variables/functions defined in this scope"},clone:function(t){var e=this._clone(t);return this.enclosed&&(e.enclosed=this.enclosed.slice()),this.functions&&(e.functions=this.functions.clone()),this.variables&&(e.variables=this.variables.clone()),e},pinned:function(){return this.resolve().pinned()},resolve:function(){return this.parent_scope.resolve()},_validate:function(){if("BlockScope"==this.TYPE)throw new Error("should not instantiate AST_BlockScope");if(null!=this.parent_scope){if(!(this.parent_scope instanceof T))throw new Error("parent_scope must be AST_BlockScope");if(!(this.resolve()instanceof I))throw new Error("must be contained within AST_Scope")}}},m);function E(t,e){t.body.forEach(function(t){t.walk(e)})}var g=u("Block","body",{$documentation:"A body of statements (usually braced)",$propdoc:{body:"[AST_Statement*] an array of statements"},_equals:function(t){return d(this.body,t.body)},walk:function(t){var e=this;t.visit(e,function(){E(e,t)})},_validate:function(){if("Block"==this.TYPE)throw new Error("should not instantiate AST_Block");this.body.forEach(function(t){if(!v(t))throw new Error("body must contain AST_Statement")})}},T),k=u("BlockStatement",null,{$documentation:"A block statement"},g),x=u("StatementWithBody","body",{$documentation:"Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",$propdoc:{body:"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"},_validate:function(){if("StatementWithBody"==this.TYPE)throw new Error("should not instantiate AST_StatementWithBody");if(!v(this.body))throw new Error("body must be AST_Statement")}},T),$=u("LabeledStatement","label",{$documentation:"Statement with a label",$propdoc:{label:"[AST_Label] a label definition"},_equals:function(t){return this.label.equals(t.label)&&this.body.equals(t.body)},walk:function(t){var e=this;t.visit(e,function(){e.label.walk(t),e.body.walk(t)})},clone:function(t){var e=this._clone(t);if(t){var n=e.label,o=this.label;e.walk(new Me(function(t){if(t instanceof _t){if(!t.label||t.label.thedef!==o)return;return t.label.thedef=n,n.references.push(t),!0}if(t instanceof I)return!0}))}return e},_validate:function(){if(!(this.label instanceof Ee))throw new Error("label must be AST_Label")}},x),q=u("IterationStatement",null,{$documentation:"Internal class.  All loops inherit from it.",_validate:function(){if("IterationStatement"==this.TYPE)throw new Error("should not instantiate AST_IterationStatement")}},x),D=u("DWLoop","condition",{$documentation:"Base class for do/while statements",$propdoc:{condition:"[AST_Node] the loop condition.  Should not be instanceof AST_Statement"},_equals:function(t){return this.body.equals(t.body)&&this.condition.equals(t.condition)},_validate:function(){if("DWLoop"==this.TYPE)throw new Error("should not instantiate AST_DWLoop");y(this,"condition")}},q),N=u("Do",null,{$documentation:"A `do` statement",walk:function(t){var e=this;t.visit(e,function(){e.body.walk(t),e.condition.walk(t)})}},D),C=u("While",null,{$documentation:"A `while` statement",walk:function(t){var e=this;t.visit(e,function(){e.condition.walk(t),e.body.walk(t)})}},D),P=u("For","init condition step",{$documentation:"A `for` statement",$propdoc:{init:"[AST_Node?] the `for` initialization code, or null if empty",condition:"[AST_Node?] the `for` termination clause, or null if empty",step:"[AST_Node?] the `for` update clause, or null if empty"},_equals:function(t){return p(this.init,t.init)&&p(this.condition,t.condition)&&p(this.step,t.step)&&this.body.equals(t.body)},walk:function(t){var e=this;t.visit(e,function(){e.init&&e.init.walk(t),e.condition&&e.condition.walk(t),e.step&&e.step.walk(t),e.body.walk(t)})},_validate:function(){if(null!=this.init){if(!(this.init instanceof f))throw new Error("init must be AST_Node");if(v(this.init)&&!(this.init instanceof xt))throw new Error("init cannot be AST_Statement")}null!=this.condition&&y(this,"condition"),null!=this.step&&y(this,"step")}},q),B=u("ForEnumeration","init object",{$documentation:"Base class for enumeration loops, i.e. `for ... in`, `for ... of` & `for await ... of`",$propdoc:{init:"[AST_Node] the assignment target during iteration",object:"[AST_Node] the object to iterate over"},_equals:function(t){return this.init.equals(t.init)&&this.object.equals(t.object)&&this.body.equals(t.body)},walk:function(t){var e=this;t.visit(e,function(){e.init.walk(t),e.object.walk(t),e.body.walk(t)})},_validate:function(){if("ForEnumeration"==this.TYPE)throw new Error("should not instantiate AST_ForEnumeration");if(this.init instanceof xt){if(1!=this.init.definitions.length)throw new Error("init must have single declaration")}else ne(this.init,function(t){if(!(t instanceof Vt||t instanceof ge))throw new Error("init must be assignable: "+t.TYPE)});y(this,"object")}},q),L=u("ForIn",null,{$documentation:"A `for ... in` statement"},B),O=u("ForOf",null,{$documentation:"A `for ... of` statement"},B),j=u("ForAwaitOf",null,{$documentation:"A `for await ... of` statement"},O),F=u("With","expression",{$documentation:"A `with` statement",$propdoc:{expression:"[AST_Node] the `with` expression"},_equals:function(t){return this.expression.equals(t.expression)&&this.body.equals(t.body)},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t),e.body.walk(t)})},_validate:function(){y(this,"expression")}},x),I=u("Scope","fn_defs may_call_this uses_eval uses_with",{$documentation:"Base class for all statements introducing a lambda scope",$propdoc:{uses_eval:"[boolean/S] tells whether this scope contains a direct call to the global `eval`",uses_with:"[boolean/S] tells whether this scope uses the `with` statement"},pinned:function(){return this.uses_eval||this.uses_with},resolve:s,_validate:function(){if("Scope"==this.TYPE)throw new Error("should not instantiate AST_Scope")}},g),Y=u("Toplevel","globals",{$documentation:"The toplevel scope",$propdoc:{globals:"[Dictionary/S] a map of name ---\x3e SymbolDef for all undeclared names"},wrap:function(t){var e=this.body;return l.parse(["(function(exports){'$ORIG';})(typeof ",t,"=='undefined'?(",t,"={}):",t,");"].join(""),{filename:"wrap="+JSON.stringify(t)}).transform(new He(function(t){if(t instanceof S&&"$ORIG"==t.value)return n.splice(e)}))},enclose:function(t){"string"!=typeof t&&(t="");var e=t.indexOf(":");e<0&&(e=t.length);var o=this.body;return l.parse(["(function(",t.slice(0,e),'){"$ORIG"})(',t.slice(e+1),")"].join(""),{filename:"enclose="+JSON.stringify(t)}).transform(new He(function(t){if(t instanceof S&&"$ORIG"==t.value)return n.splice(o)}))}},I),R=u("ClassInitBlock",null,{$documentation:"Value for `class` static initialization blocks"},I),V=u("Lambda","argnames length_read rest safe_ids uses_arguments",{$documentation:"Base class for functions",$propdoc:{argnames:"[(AST_DefaultValue|AST_Destructured|AST_SymbolFunarg)*] array of function arguments and/or destructured literals",length_read:"[boolean/S] whether length property of this function is accessed",rest:"[(AST_Destructured|AST_SymbolFunarg)?] rest parameter, or null if absent",uses_arguments:"[boolean|number/S] whether this function accesses the arguments array"},each_argname:function(t){var e=new Me(function(n){return n instanceof jt?(n.name.walk(e),!0):n instanceof ie?(n.value.walk(e),!0):void(n instanceof be&&t(n))});this.argnames.forEach(function(t){t.walk(e)}),this.rest&&this.rest.walk(e)},_equals:function(t){return p(this.rest,t.rest)&&p(this.name,t.name)&&p(this.value,t.value)&&d(this.argnames,t.argnames)&&d(this.body,t.body)},walk:function(t){var e=this;t.visit(e,function(){e.name&&e.name.walk(t),e.argnames.forEach(function(e){e.walk(t)}),e.rest&&e.rest.walk(t),E(e,t)})},_validate:function(){if("Lambda"==this.TYPE)throw new Error("should not instantiate AST_Lambda");this.argnames.forEach(function(t){ne(t,function(t){if(!(t instanceof be))throw new Error("argnames must be AST_SymbolFunarg[]")},!0)}),null!=this.rest&&ne(this.rest,function(t){if(!(t instanceof be))throw new Error("rest must be AST_SymbolFunarg")})}},I),G=u("Accessor",null,{$documentation:"A getter/setter function",_validate:function(){if(null!=this.name)throw new Error("name must be null")}},V),W=u("LambdaExpression","inlined",{$documentation:"Base class for function expressions",$propdoc:{inlined:"[boolean/S] whether this function has been inlined"},_validate:function(){if("LambdaExpression"==this.TYPE)throw new Error("should not instantiate AST_LambdaExpression")}},V);function z(t){return t instanceof U||t instanceof M}var U=u("Arrow","value",{$documentation:"An arrow function expression",$propdoc:{value:"[AST_Node?] simple return expression, or null if using function body."},walk:function(t){var e=this;t.visit(e,function(){e.argnames.forEach(function(e){e.walk(t)}),e.rest&&e.rest.walk(t),e.value?e.value.walk(t):E(e,t)})},_validate:function(){if(null!=this.name)throw new Error("name must be null");if(this.uses_arguments)throw new Error("uses_arguments must be false");if(null!=this.value&&(y(this,"value"),this.body.length))throw new Error("body must be empty if value exists")}},W),M=u("AsyncArrow","value",{$documentation:"An asynchronous arrow function expression",$propdoc:{value:"[AST_Node?] simple return expression, or null if using function body."},walk:function(t){var e=this;t.visit(e,function(){e.argnames.forEach(function(e){e.walk(t)}),e.rest&&e.rest.walk(t),e.value?e.value.walk(t):E(e,t)})},_validate:function(){if(null!=this.name)throw new Error("name must be null");if(this.uses_arguments)throw new Error("uses_arguments must be false");if(null!=this.value&&(y(this,"value"),this.body.length))throw new Error("body must be empty if value exists")}},W),H=u("AsyncFunction","name",{$documentation:"An asynchronous function expression",$propdoc:{name:"[AST_SymbolLambda?] the name of this function, or null if not specified"},_validate:function(){if(null!=this.name&&!(this.name instanceof we))throw new Error("name must be AST_SymbolLambda")}},W),J=u("AsyncGeneratorFunction","name",{$documentation:"An asynchronous generator function expression",$propdoc:{name:"[AST_SymbolLambda?] the name of this function, or null if not specified"},_validate:function(){if(null!=this.name&&!(this.name instanceof we))throw new Error("name must be AST_SymbolLambda")}},W),K=u("Function","name",{$documentation:"A function expression",$propdoc:{name:"[AST_SymbolLambda?] the name of this function, or null if not specified"},_validate:function(){if(null!=this.name&&!(this.name instanceof we))throw new Error("name must be AST_SymbolLambda")}},W),Q=u("GeneratorFunction","name",{$documentation:"A generator function expression",$propdoc:{name:"[AST_SymbolLambda?] the name of this function, or null if not specified"},_validate:function(){if(null!=this.name&&!(this.name instanceof we))throw new Error("name must be AST_SymbolLambda")}},W),X=u("LambdaDefinition","inlined name",{$documentation:"Base class for function definitions",$propdoc:{inlined:"[boolean/S] whether this function has been inlined",name:"[AST_SymbolDefun] the name of this function"},_validate:function(){if("LambdaDefinition"==this.TYPE)throw new Error("should not instantiate AST_LambdaDefinition");if(!(this.name instanceof ve))throw new Error("name must be AST_SymbolDefun")}},V),Z=u("AsyncDefun",null,{$documentation:"An asynchronous function definition"},X),tt=u("AsyncGeneratorDefun",null,{$documentation:"An asynchronous generator function definition"},X),et=u("Defun",null,{$documentation:"A function definition"},X),nt=u("GeneratorDefun",null,{$documentation:"A generator function definition"},X),ot=u("Class","extends name properties",{$documentation:"Base class for class literals",$propdoc:{extends:"[AST_Node?] the super class, or null if not specified",properties:"[AST_ClassProperty*] array of class properties"},_equals:function(t){return p(this.name,t.name)&&p(this.extends,t.extends)&&d(this.properties,t.properties)},resolve:function(t){return t?this:this.parent_scope.resolve()},walk:function(t){var e=this;t.visit(e,function(){e.name&&e.name.walk(t),e.extends&&e.extends.walk(t),e.properties.forEach(function(e){e.walk(t)})})},_validate:function(){if("Class"==this.TYPE)throw new Error("should not instantiate AST_Class");null!=this.extends&&y(this,"extends"),this.properties.forEach(function(t){if(!(t instanceof rt))throw new Error("properties must contain AST_ClassProperty")})}},T),it=u("DefClass",null,{$documentation:"A class definition",$propdoc:{name:"[AST_SymbolDefClass] the name of this class"},_validate:function(){if(!(this.name instanceof ye))throw new Error("name must be AST_SymbolDefClass")}},ot),at=u("ClassExpression",null,{$documentation:"A class expression",$propdoc:{name:"[AST_SymbolClass?] the name of this class, or null if not specified"},_validate:function(){if(null!=this.name&&!(this.name instanceof Ae))throw new Error("name must be AST_SymbolClass")}},ot),rt=u("ClassProperty","key private static value",{$documentation:"Base class for `class` properties",$propdoc:{key:"[string|AST_Node?] property name (AST_Node for computed property, null for initialization block)",private:"[boolean] whether this is a private property",static:"[boolean] whether this is a static property",value:"[AST_Node?] property value (AST_Accessor for getters/setters, AST_LambdaExpression for methods, null if not specified for fields)"},_equals:function(t){return!this.private==!t.private&&!this.static==!t.static&&p(this.key,t.key)&&p(this.value,t.value)},walk:function(t){var e=this;t.visit(e,function(){e.key instanceof f&&e.key.walk(t),e.value&&e.value.walk(t)})},_validate:function(){if("ClassProperty"==this.TYPE)throw new Error("should not instantiate AST_ClassProperty");if(this instanceof ft){if(null!=this.key)throw new Error("key must be null")}else if("string"!=typeof this.key){if(!(this.key instanceof f))throw new Error("key must be string or AST_Node");y(this,"key")}if(null!=this.value&&!(this.value instanceof f))throw new Error("value must be AST_Node")}}),st=u("ClassField",null,{$documentation:"A `class` field",_validate:function(){null!=this.value&&y(this,"value")}},rt),lt=u("ClassGetter",null,{$documentation:"A `class` getter",_validate:function(){if(!(this.value instanceof G))throw new Error("value must be AST_Accessor")}},rt),ut=u("ClassSetter",null,{$documentation:"A `class` setter",_validate:function(){if(!(this.value instanceof G))throw new Error("value must be AST_Accessor")}},rt),ct=u("ClassMethod",null,{$documentation:"A `class` method",_validate:function(){if(!(this.value instanceof W))throw new Error("value must be AST_LambdaExpression");if(z(this.value))throw new Error("value cannot be AST_Arrow or AST_AsyncArrow");if(null!=this.value.name)throw new Error("name of class method's lambda must be null")}},rt),ft=u("ClassInit",null,{$documentation:"A `class` static initialization block",_validate:function(){if(!this.static)throw new Error("static must be true");if(!(this.value instanceof R))throw new Error("value must be AST_ClassInitBlock")},initialize:function(){this.static=!0}},rt),ht=u("Jump",null,{$documentation:"Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)",_validate:function(){if("Jump"==this.TYPE)throw new Error("should not instantiate AST_Jump")}},m),dt=u("Exit","value",{$documentation:"Base class for “exits” (`return` and `throw`)",$propdoc:{value:"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"},_equals:function(t){return p(this.value,t.value)},walk:function(t){var e=this;t.visit(e,function(){e.value&&e.value.walk(t)})},_validate:function(){if("Exit"==this.TYPE)throw new Error("should not instantiate AST_Exit")}},ht),pt=u("Return",null,{$documentation:"A `return` statement",_validate:function(){null!=this.value&&y(this,"value")}},dt),mt=u("Throw",null,{$documentation:"A `throw` statement",_validate:function(){y(this,"value")}},dt),_t=u("LoopControl","label",{$documentation:"Base class for loop control statements (`break` and `continue`)",$propdoc:{label:"[AST_LabelRef?] the label, or null if none"},_equals:function(t){return p(this.label,t.label)},walk:function(t){var e=this;t.visit(e,function(){e.label&&e.label.walk(t)})},_validate:function(){if("LoopControl"==this.TYPE)throw new Error("should not instantiate AST_LoopControl");if(null!=this.label&&!(this.label instanceof xe))throw new Error("label must be AST_LabelRef")}},ht),St=u("Break",null,{$documentation:"A `break` statement"},_t),bt=u("Continue",null,{$documentation:"A `continue` statement"},_t),vt=u("If","condition alternative",{$documentation:"A `if` statement",$propdoc:{condition:"[AST_Node] the `if` condition",alternative:"[AST_Statement?] the `else` part, or null if not present"},_equals:function(t){return this.body.equals(t.body)&&this.condition.equals(t.condition)&&p(this.alternative,t.alternative)},walk:function(t){var e=this;t.visit(e,function(){e.condition.walk(t),e.body.walk(t),e.alternative&&e.alternative.walk(t)})},_validate:function(){if(y(this,"condition"),null!=this.alternative&&!v(this.alternative))throw new Error("alternative must be AST_Statement")}},x),wt=u("Switch","expression",{$documentation:"A `switch` statement",$propdoc:{expression:"[AST_Node] the `switch` “discriminant”"},_equals:function(t){return this.expression.equals(t.expression)&&d(this.body,t.body)},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t),E(e,t)})},_validate:function(){y(this,"expression"),this.body.forEach(function(t){if(!(t instanceof yt))throw new Error("body must be AST_SwitchBranch[]")})}},g),yt=u("SwitchBranch",null,{$documentation:"Base class for `switch` branches",_validate:function(){if("SwitchBranch"==this.TYPE)throw new Error("should not instantiate AST_SwitchBranch")}},g),At=u("Default",null,{$documentation:"A `default` switch branch"},yt),Tt=u("Case","expression",{$documentation:"A `case` switch branch",$propdoc:{expression:"[AST_Node] the `case` expression"},_equals:function(t){return this.expression.equals(t.expression)&&d(this.body,t.body)},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t),E(e,t)})},_validate:function(){y(this,"expression")}},yt),Et=u("Try","bcatch bfinally",{$documentation:"A `try` statement",$propdoc:{bcatch:"[AST_Catch?] the catch block, or null if not present",bfinally:"[AST_Finally?] the finally block, or null if not present"},_equals:function(t){return d(this.body,t.body)&&p(this.bcatch,t.bcatch)&&p(this.bfinally,t.bfinally)},walk:function(t){var e=this;t.visit(e,function(){E(e,t),e.bcatch&&e.bcatch.walk(t),e.bfinally&&e.bfinally.walk(t)})},_validate:function(){if(null!=this.bcatch&&!(this.bcatch instanceof gt))throw new Error("bcatch must be AST_Catch");if(null!=this.bfinally&&!(this.bfinally instanceof kt))throw new Error("bfinally must be AST_Finally")}},g),gt=u("Catch","argname",{$documentation:"A `catch` node; only makes sense as part of a `try` statement",$propdoc:{argname:"[(AST_Destructured|AST_SymbolCatch)?] symbol for the exception, or null if not present"},_equals:function(t){return p(this.argname,t.argname)&&d(this.body,t.body)},walk:function(t){var e=this;t.visit(e,function(){e.argname&&e.argname.walk(t),E(e,t)})},_validate:function(){null!=this.argname&&ne(this.argname,function(t){if(!(t instanceof Te))throw new Error("argname must be AST_SymbolCatch")})}},g),kt=u("Finally",null,{$documentation:"A `finally` node; only makes sense as part of a `try` statement"},g),xt=u("Definitions","definitions",{$documentation:"Base class for `var` nodes (variable declarations/initializations)",$propdoc:{definitions:"[AST_VarDef*] array of variable definitions"},_equals:function(t){return d(this.definitions,t.definitions)},walk:function(t){var e=this;t.visit(e,function(){e.definitions.forEach(function(e){e.walk(t)})})},_validate:function(){if("Definitions"==this.TYPE)throw new Error("should not instantiate AST_Definitions");if(this.definitions.length<1)throw new Error("must have at least one definition")}},m),$t=u("Const",null,{$documentation:"A `const` statement",_validate:function(){this.definitions.forEach(function(t){if(!(t instanceof Nt))throw new Error("definitions must be AST_VarDef[]");ne(t.name,function(t){if(!(t instanceof pe))throw new Error("name must be AST_SymbolConst")})})}},xt),qt=u("Let",null,{$documentation:"A `let` statement",_validate:function(){this.definitions.forEach(function(t){if(!(t instanceof Nt))throw new Error("definitions must be AST_VarDef[]");ne(t.name,function(t){if(!(t instanceof _e))throw new Error("name must be AST_SymbolLet")})})}},xt),Dt=u("Var",null,{$documentation:"A `var` statement",_validate:function(){this.definitions.forEach(function(t){if(!(t instanceof Nt))throw new Error("definitions must be AST_VarDef[]");ne(t.name,function(t){if(!(t instanceof Se))throw new Error("name must be AST_SymbolVar")})})}},xt),Nt=u("VarDef","name value",{$documentation:"A variable declaration; only appears in a AST_Definitions node",$propdoc:{name:"[AST_Destructured|AST_SymbolVar] name of the variable",value:"[AST_Node?] initializer, or null of there's no initializer"},_equals:function(t){return this.name.equals(t.name)&&p(this.value,t.value)},walk:function(t){var e=this;t.visit(e,function(){e.name.walk(t),e.value&&e.value.walk(t)})},_validate:function(){null!=this.value&&y(this,"value")}}),Ct=u("ExportDeclaration","body",{$documentation:"An `export` statement",$propdoc:{body:"[AST_DefClass|AST_Definitions|AST_LambdaDefinition] the statement to export"},_equals:function(t){return this.body.equals(t.body)},walk:function(t){var e=this;t.visit(e,function(){e.body.walk(t)})},_validate:function(){if(!(this.body instanceof it||this.body instanceof xt||this.body instanceof X))throw new Error("body must be AST_DefClass, AST_Definitions or AST_LambdaDefinition")}},m),Pt=u("ExportDefault","body",{$documentation:"An `export default` statement",$propdoc:{body:"[AST_Node] the default export"},_equals:function(t){return this.body.equals(t.body)},walk:function(t){var e=this;t.visit(e,function(){e.body.walk(t)})},_validate:function(){this.body instanceof it||this.body instanceof X||y(this,"body")}},m),Bt=u("ExportForeign","aliases keys path",{$documentation:"An `export ... from '...'` statement",$propdoc:{aliases:"[AST_String*] array of aliases to export",keys:"[AST_String*] array of keys to import",path:"[AST_String] the path to import module"},_equals:function(t){return this.path.equals(t.path)&&d(this.aliases,t.aliases)&&d(this.keys,t.keys)},_validate:function(){if(this.aliases.length!=this.keys.length)throw new Error("aliases:key length mismatch: "+this.aliases.length+" != "+this.keys.length);if(this.aliases.forEach(function(t){if(!(t instanceof Be))throw new Error("aliases must contain AST_String")}),this.keys.forEach(function(t){if(!(t instanceof Be))throw new Error("keys must contain AST_String")}),!(this.path instanceof Be))throw new Error("path must be AST_String")}},m),Lt=u("ExportReferences","properties",{$documentation:"An `export { ... }` statement",$propdoc:{properties:"[AST_SymbolExport*] array of aliases to export"},_equals:function(t){return d(this.properties,t.properties)},walk:function(t){var e=this;t.visit(e,function(){e.properties.forEach(function(e){e.walk(t)})})},_validate:function(){this.properties.forEach(function(t){if(!(t instanceof ke))throw new Error("properties must contain AST_SymbolExport")})}},m),Ot=u("Import","all default path properties",{$documentation:"An `import` statement",$propdoc:{all:"[AST_SymbolImport?] the imported namespace, or null if not specified",default:"[AST_SymbolImport?] the alias for default `export`, or null if not specified",path:"[AST_String] the path to import module",properties:"[(AST_SymbolImport*)?] array of aliases, or null if not specified"},_equals:function(t){return this.path.equals(t.path)&&p(this.all,t.all)&&p(this.default,t.default)&&!this.properties==!t.properties&&(!this.properties||d(this.properties,t.properties))},walk:function(t){var e=this;t.visit(e,function(){e.all&&e.all.walk(t),e.default&&e.default.walk(t),e.properties&&e.properties.forEach(function(e){e.walk(t)})})},_validate:function(){if(null!=this.all){if(!(this.all instanceof me))throw new Error("all must be AST_SymbolImport");if(null!=this.properties)throw new Error("cannot import both * and {} in the same statement")}if(null!=this.default){if(!(this.default instanceof me))throw new Error("default must be AST_SymbolImport");if(""!==this.default.key.value)throw new Error("invalid default key: "+this.default.key.value)}if(!(this.path instanceof Be))throw new Error("path must be AST_String");null!=this.properties&&this.properties.forEach(function(t){if(!(t instanceof me))throw new Error("properties must contain AST_SymbolImport")})}},m),jt=u("DefaultValue","name value",{$documentation:"A default value declaration",$propdoc:{name:"[AST_Destructured|AST_SymbolDeclaration] name of the variable",value:"[AST_Node] value to assign if variable is `undefined`"},_equals:function(t){return this.name.equals(t.name)&&this.value.equals(t.value)},walk:function(t){var e=this;t.visit(e,function(){e.name.walk(t),e.value.walk(t)})},_validate:function(){y(this,"value")}});function Ft(t,e,n,o){t[e].forEach(function(t){w(t,e,!0,n,o)})}var It=u("Call","args expression optional pure terminal",{$documentation:"A function call expression",$propdoc:{args:"[AST_Node*] array of arguments",expression:"[AST_Node] expression to invoke as function",optional:"[boolean] whether the expression is optional chaining",pure:"[boolean/S] marker for side-effect-free call expression",terminal:"[boolean] whether the chain has ended"},_equals:function(t){return!this.optional==!t.optional&&this.expression.equals(t.expression)&&d(this.args,t.args)},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t),e.args.forEach(function(e){e.walk(t)})})},_validate:function(){y(this,"expression"),Ft(this,"args",!0)}}),Yt=u("New",null,{$documentation:"An object instantiation.  Derives from a function call since it has exactly the same properties",_validate:function(){if(this.optional)throw new Error("optional must be false");if(this.terminal)throw new Error("terminal must be false")}},It),Rt=u("Sequence","expressions",{$documentation:"A sequence expression (comma-separated expressions)",$propdoc:{expressions:"[AST_Node*] array of expressions (at least two)"},_equals:function(t){return d(this.expressions,t.expressions)},walk:function(t){var e=this;t.visit(e,function(){e.expressions.forEach(function(e){e.walk(t)})})},_validate:function(){if(this.expressions.length<2)throw new Error("expressions must contain multiple elements");Ft(this,"expressions")}});var Vt=u("PropAccess","expression optional property terminal",{$documentation:'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`',$propdoc:{expression:"[AST_Node] the “container” expression",optional:"[boolean] whether the expression is optional chaining",property:"[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node",terminal:"[boolean] whether the chain has ended"},_equals:function(t){return!this.optional==!t.optional&&p(this.property,t.property)&&this.expression.equals(t.expression)},get_property:function(){var t=this.property;return t instanceof Pe?t.value:t instanceof Mt&&"void"==t.operator&&t.expression instanceof Pe?void 0:t},_validate:function(){if("PropAccess"==this.TYPE)throw new Error("should not instantiate AST_PropAccess");y(this,"expression")}}),Gt=u("Dot","quoted",{$documentation:"A dotted property access expression",$propdoc:{quoted:"[boolean] whether property is transformed from a quoted string"},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t)})},_validate:function(){if("string"!=typeof this.property)throw new Error("property must be string")}},Vt),Wt=u("Sub",null,{$documentation:'Index-style property access, i.e. `a["foo"]`',walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t),e.property.walk(t)})},_validate:function(){y(this,"property")}},Vt),zt=u("Spread","expression",{$documentation:"Spread expression in array/object literals or function calls",$propdoc:{expression:"[AST_Node] expression to be expanded"},_equals:function(t){return this.expression.equals(t.expression)},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t)})},_validate:function(){y(this,"expression")}}),Ut=u("Unary","operator expression",{$documentation:"Base class for unary expressions",$propdoc:{operator:"[string] the operator",expression:"[AST_Node] expression that this unary operator applies to"},_equals:function(t){return this.operator==t.operator&&this.expression.equals(t.expression)},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t)})},_validate:function(){if("Unary"==this.TYPE)throw new Error("should not instantiate AST_Unary");if("string"!=typeof this.operator)throw new Error("operator must be string");y(this,"expression")}}),Mt=u("UnaryPrefix",null,{$documentation:"Unary prefix expression, i.e. `typeof i` or `++i`"},Ut),Ht=u("UnaryPostfix",null,{$documentation:"Unary postfix expression, i.e. `i++`"},Ut),Jt=u("Binary","operator left right",{$documentation:"Binary expression, i.e. `a + b`",$propdoc:{left:"[AST_Node] left-hand side expression",operator:"[string] the operator",right:"[AST_Node] right-hand side expression"},_equals:function(t){return this.operator==t.operator&&this.left.equals(t.left)&&this.right.equals(t.right)},walk:function(t){var e=this;t.visit(e,function(){e.left.walk(t),e.right.walk(t)})},_validate:function(){if(this instanceof Qt||y(this,"left"),"string"!=typeof this.operator)throw new Error("operator must be string");y(this,"right")}}),Kt=u("Conditional","condition consequent alternative",{$documentation:"Conditional expression using the ternary operator, i.e. `a ? b : c`",$propdoc:{condition:"[AST_Node]",consequent:"[AST_Node]",alternative:"[AST_Node]"},_equals:function(t){return this.condition.equals(t.condition)&&this.consequent.equals(t.consequent)&&this.alternative.equals(t.alternative)},walk:function(t){var e=this;t.visit(e,function(){e.condition.walk(t),e.consequent.walk(t),e.alternative.walk(t)})},_validate:function(){y(this,"condition"),y(this,"consequent"),y(this,"alternative")}}),Qt=u("Assign",null,{$documentation:"An assignment expression — `a = b + 5`",_validate:function(){if(this.operator.indexOf("=")<0)throw new Error('operator must contain "="');if(this.left instanceof ee){if("="!=this.operator)throw new Error("invalid destructuring operator: "+this.operator);ne(this.left,function(t){if(!(t instanceof Vt||t instanceof ge))throw new Error("left must be assignable: "+t.TYPE)})}else if(!(this.left instanceof Ge||this.left instanceof Ye||this.left instanceof Vt&&!this.left.optional||this.left instanceof ge||this.left instanceof Re))throw new Error("left must be assignable")}},Jt),Xt=u("Await","expression",{$documentation:"An await expression",$propdoc:{expression:"[AST_Node] expression with Promise to resolve on"},_equals:function(t){return this.expression.equals(t.expression)},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t)})},_validate:function(){y(this,"expression")}}),Zt=u("Yield","expression nested",{$documentation:"A yield expression",$propdoc:{expression:"[AST_Node?] return value for iterator, or null if undefined",nested:"[boolean] whether to iterate over expression as generator"},_equals:function(t){return!this.nested==!t.nested&&p(this.expression,t.expression)},walk:function(t){var e=this;t.visit(e,function(){e.expression&&e.expression.walk(t)})},_validate:function(){if(null!=this.expression)y(this,"expression");else if(this.nested)throw new Error("yield* must contain expression")}}),te=u("Array","elements",{$documentation:"An array literal",$propdoc:{elements:"[AST_Node*] array of elements"},_equals:function(t){return d(this.elements,t.elements)},walk:function(t){var e=this;t.visit(e,function(){e.elements.forEach(function(e){e.walk(t)})})},_validate:function(){Ft(this,"elements",!0,!0)}}),ee=u("Destructured","rest",{$documentation:"Base class for destructured literal",$propdoc:{rest:"[(AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef)?] rest parameter, or null if absent"},_validate:function(){if("Destructured"==this.TYPE)throw new Error("should not instantiate AST_Destructured")}});function ne(t,e,n){if(t instanceof jt&&n)return ne(t.name,e);if(t instanceof ee){if(null!=t.rest&&ne(t.rest,e),t instanceof oe)return t.elements.forEach(function(t){t instanceof Ve||ne(t,e,!0)});if(t instanceof ae)return t.properties.forEach(function(t){ne(t.value,e,!0)})}e(t)}var oe=u("DestructuredArray","elements",{$documentation:"A destructured array literal",$propdoc:{elements:"[(AST_DefaultValue|AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef)*] array of elements"},_equals:function(t){return p(this.rest,t.rest)&&d(this.elements,t.elements)},walk:function(t){var e=this;t.visit(e,function(){e.elements.forEach(function(e){e.walk(t)}),e.rest&&e.rest.walk(t)})}},ee),ie=u("DestructuredKeyVal","key value",{$documentation:"A key: value destructured property",$propdoc:{key:"[string|AST_Node] property name.  For computed property this is an AST_Node.",value:"[AST_DefaultValue|AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef] property value"},_equals:function(t){return p(this.key,t.key)&&this.value.equals(t.value)},walk:function(t){var e=this;t.visit(e,function(){e.key instanceof f&&e.key.walk(t),e.value.walk(t)})},_validate:function(){if("string"!=typeof this.key){if(!(this.key instanceof f))throw new Error("key must be string or AST_Node");y(this,"key")}if(!(this.value instanceof f))throw new Error("value must be AST_Node")}}),ae=u("DestructuredObject","properties",{$documentation:"A destructured object literal",$propdoc:{properties:"[AST_DestructuredKeyVal*] array of properties"},_equals:function(t){return p(this.rest,t.rest)&&d(this.properties,t.properties)},walk:function(t){var e=this;t.visit(e,function(){e.properties.forEach(function(e){e.walk(t)}),e.rest&&e.rest.walk(t)})},_validate:function(){this.properties.forEach(function(t){if(!(t instanceof ie))throw new Error("properties must be AST_DestructuredKeyVal[]")})}},ee),re=u("Object","properties",{$documentation:"An object literal",$propdoc:{properties:"[(AST_ObjectProperty|AST_Spread)*] array of properties"},_equals:function(t){return d(this.properties,t.properties)},walk:function(t){var e=this;t.visit(e,function(){e.properties.forEach(function(e){e.walk(t)})})},_validate:function(){this.properties.forEach(function(t){if(!(t instanceof se||t instanceof zt))throw new Error("properties must contain AST_ObjectProperty and/or AST_Spread only")})}}),se=u("ObjectProperty","key value",{$documentation:"Base class for literal object properties",$propdoc:{key:"[string|AST_Node] property name.  For computed property this is an AST_Node.",value:"[AST_Node] property value.  For getters and setters this is an AST_Accessor."},_equals:function(t){return p(this.key,t.key)&&this.value.equals(t.value)},walk:function(t){var e=this;t.visit(e,function(){e.key instanceof f&&e.key.walk(t),e.value.walk(t)})},_validate:function(){if("ObjectProperty"==this.TYPE)throw new Error("should not instantiate AST_ObjectProperty");if("string"!=typeof this.key){if(!(this.key instanceof f))throw new Error("key must be string or AST_Node");y(this,"key")}if(!(this.value instanceof f))throw new Error("value must be AST_Node")}}),le=u("ObjectKeyVal",null,{$documentation:"A key: value object property",_validate:function(){y(this,"value")}},se),ue=u("ObjectMethod",null,{$documentation:"A key(){} object property",_validate:function(){if(!(this.value instanceof W))throw new Error("value must be AST_LambdaExpression");if(z(this.value))throw new Error("value cannot be AST_Arrow or AST_AsyncArrow");if(null!=this.value.name)throw new Error("name of object method's lambda must be null")}},le),ce=u("ObjectSetter",null,{$documentation:"An object setter property",_validate:function(){if(!(this.value instanceof G))throw new Error("value must be AST_Accessor")}},se),fe=u("ObjectGetter",null,{$documentation:"An object getter property",_validate:function(){if(!(this.value instanceof G))throw new Error("value must be AST_Accessor")}},se),he=u("Symbol","scope name thedef",{$documentation:"Base class for all symbols",$propdoc:{name:"[string] name of this symbol",scope:"[AST_Scope/S] the current scope (not necessarily the definition scope)",thedef:"[SymbolDef/S] the definition of this symbol"},_equals:function(t){return this.thedef?this.thedef===t.thedef:this.name==t.name},_validate:function(){if("Symbol"==this.TYPE)throw new Error("should not instantiate AST_Symbol");if("string"!=typeof this.name)throw new Error("name must be string")}}),de=u("SymbolDeclaration","init",{$documentation:"A declaration symbol (symbol in var, function name or argument, symbol in catch)"},he),pe=u("SymbolConst",null,{$documentation:"Symbol defining a constant"},de),me=u("SymbolImport","key",{$documentation:"Symbol defined by an `import` statement",$propdoc:{key:"[AST_String] the original `export` name"},_equals:function(t){return this.name==t.name&&this.key.equals(t.key)},_validate:function(){if(!(this.key instanceof Be))throw new Error("key must be AST_String")}},pe),_e=u("SymbolLet",null,{$documentation:"Symbol defining a lexical-scoped variable"},de),Se=u("SymbolVar",null,{$documentation:"Symbol defining a variable"},de),be=u("SymbolFunarg","unused",{$documentation:"Symbol naming a function argument"},Se),ve=u("SymbolDefun",null,{$documentation:"Symbol defining a function"},de),we=u("SymbolLambda",null,{$documentation:"Symbol naming a function expression"},de),ye=u("SymbolDefClass",null,{$documentation:"Symbol defining a class"},pe),Ae=u("SymbolClass",null,{$documentation:"Symbol naming a class expression"},pe),Te=u("SymbolCatch",null,{$documentation:"Symbol naming the exception in catch"},de),Ee=u("Label","references",{$documentation:"Symbol naming a label (declaration)",$propdoc:{references:"[AST_LoopControl*] a list of nodes referring to this label"},initialize:function(){this.references=[],this.thedef=this}},he),ge=u("SymbolRef","fixed in_arg redef",{$documentation:"Reference to some symbol (not definition/declaration)"},he),ke=u("SymbolExport","alias",{$documentation:"Reference in an `export` statement",$propdoc:{alias:"[AST_String] the `export` alias"},_equals:function(t){return this.name==t.name&&this.alias.equals(t.alias)},_validate:function(){if(!(this.alias instanceof Be))throw new Error("alias must be AST_String")}},ge),xe=u("LabelRef",null,{$documentation:"Reference to a label symbol"},he),$e=u("ObjectIdentity",null,{$documentation:"Base class for `super` & `this`",_equals:r,_validate:function(){if("ObjectIdentity"==this.TYPE)throw new Error("should not instantiate AST_ObjectIdentity")}},he),qe=u("Super",null,{$documentation:"The `super` symbol",_validate:function(){if("super"!==this.name)throw new Error('name must be "super"')}},$e),De=u("This",null,{$documentation:"The `this` symbol",_validate:function(){if("This"==this.TYPE&&"this"!==this.name)throw new Error('name must be "this"')}},$e),Ne=u("NewTarget",null,{$documentation:"The `new.target` symbol",initialize:function(){this.name="new.target"},_validate:function(){if("new.target"!==this.name)throw new Error('name must be "new.target": '+this.name)}},De),Ce=u("Template","expressions strings tag",{$documentation:"A template literal, i.e. tag`str1${expr1}...strN${exprN}strN+1`",$propdoc:{expressions:"[AST_Node*] the placeholder expressions",strings:"[string*] the raw text segments",tag:"[AST_Node?] tag function, or null if absent"},_equals:function(t){return p(this.tag,t.tag)&&(e=this.strings,n=t.strings,e.length==n.length&&all(e,function(t,e){return t==n[e]}))&&d(this.expressions,t.expressions);var e,n},walk:function(t){var e=this;t.visit(e,function(){e.tag&&e.tag.walk(t),e.expressions.forEach(function(e){e.walk(t)})})},_validate:function(){if(this.expressions.length+1!=this.strings.length)throw new Error("malformed template with "+this.expressions.length+" placeholder(s) but "+this.strings.length+" text segment(s)");Ft(this,"expressions"),this.strings.forEach(function(t){if("string"!=typeof t)throw new Error("strings must contain string")}),null!=this.tag&&y(this,"tag")}}),Pe=u("Constant",null,{$documentation:"Base class for all constants",_equals:function(t){return this.value===t.value},_validate:function(){if("Constant"==this.TYPE)throw new Error("should not instantiate AST_Constant")}}),Be=u("String","quote value",{$documentation:"A string literal",$propdoc:{quote:"[string?] the original quote character",value:"[string] the contents of this string"},_validate:function(){if(null!=this.quote){if("string"!=typeof this.quote)throw new Error("quote must be string");if(!/^["']$/.test(this.quote))throw new Error("invalid quote: "+this.quote)}if("string"!=typeof this.value)throw new Error("value must be string")}},Pe),Le=u("Number","value",{$documentation:"A number literal",$propdoc:{value:"[number] the numeric value"},_validate:function(){if("number"!=typeof this.value)throw new Error("value must be number");if(!isFinite(this.value))throw new Error("value must be finite");if(this.value<0)throw new Error("value cannot be negative")}},Pe),Oe=u("BigInt","value",{$documentation:"A BigInt literal",$propdoc:{value:"[string] the numeric representation"},_validate:function(){if("string"!=typeof this.value)throw new Error("value must be string");if("-"==this.value[0])throw new Error("value cannot be negative")}},Pe),je=u("RegExp","value",{$documentation:"A regexp literal",$propdoc:{value:"[RegExp] the actual regexp"},_equals:function(t){return""+this.value==""+t.value},_validate:function(){if(!(this.value instanceof RegExp))throw new Error("value must be RegExp")}},Pe),Fe=u("Atom",null,{$documentation:"Base class for atoms",_equals:r,_validate:function(){if("Atom"==this.TYPE)throw new Error("should not instantiate AST_Atom")}},Pe),Ie=u("Null",null,{$documentation:"The `null` atom",value:null},Fe),Ye=u("NaN",null,{$documentation:"The impossible value",value:NaN},Fe),Re=u("Undefined",null,{$documentation:"The `undefined` value",value:void 0},Fe),Ve=u("Hole",null,{$documentation:"A hole in an array",value:void 0},Fe),Ge=u("Infinity",null,{$documentation:"The `Infinity` value",value:1/0},Fe),We=u("Boolean",null,{$documentation:"Base class for booleans",_validate:function(){if("Boolean"==this.TYPE)throw new Error("should not instantiate AST_Boolean")}},Fe),ze=u("False",null,{$documentation:"The `false` atom",value:!1},We),Ue=u("True",null,{$documentation:"The `true` atom",value:!0},We);function Me(t){this.callback=t,this.directives=Object.create(null),this.stack=[]}function He(t,e){Me.call(this),this.before=t,this.after=e}return Me.prototype={visit:function(t,e){this.push(t),!this.callback(t,e||i)&&e&&e(),this.pop()},parent:function(t){return this.stack[this.stack.length-2-(t||0)]},push:function(t){var e;t instanceof ot?(this.directives=Object.create(this.directives),e="use strict"):t instanceof S?e=t.value:t instanceof V&&(this.directives=Object.create(this.directives)),e&&!this.directives[e]&&(this.directives[e]=t),this.stack.push(t)},pop:function(){var t=this.stack.pop();(t instanceof ot||t instanceof V)&&(this.directives=Object.getPrototypeOf(this.directives))},self:function(){return this.stack[this.stack.length-1]},find_parent:function(t){for(var e=this.stack,n=e.length-1;--n>=0;){var o=e[n];if(o instanceof t)return o}},has_directive:function(t){var e=this.directives[t];if(e)return e;var n=this.stack[this.stack.length-1];if(n instanceof I)for(var o=0;o<n.body.length;++o){var i=n.body[o];if(!(i instanceof S))break;if(i.value==t)return i}},loopcontrol_target:function(t){var e=this.stack;if(t.label)for(var n=e.length;--n>=0;){if((o=e[n])instanceof $&&o.label.name==t.label.name)return o.body}else for(n=e.length;--n>=0;){var o;if((o=e[n])instanceof q||t instanceof St&&o instanceof wt)return o}},in_boolean_context:function(){for(var t,e=!0,n=0,o=this.self();t=this.parent(n++);o=t){if(t instanceof Jt)switch(t.operator){case"&&":case"||":t.left===o&&(e=!1);continue;default:return!1}if(!(t instanceof Kt)){if(t instanceof D)return t.condition===o;if(t instanceof P)return t.condition===o;if(t instanceof vt)return t.condition===o;if(t instanceof pt){if(t.in_bool)return!0;for(;t=this.parent(n++);)if(t instanceof V){if(t.name)return!1;if("Call"!=(t=this.parent(n++)).TYPE)return!1;break}}if(t instanceof Rt){if(t.tail_node()===o)continue;return!e||"d"}return t instanceof A?!e||"d":t instanceof Mt&&"!"==t.operator}if(t.condition===o)return!0}}},He.prototype=new Me,function(t){function e(t,e){return n(t,function(t){return t.transform(e,!0)})}function o(t,n){t.argnames=e(t.argnames,n),t.rest&&(t.rest=t.rest.transform(n)),t.value?t.value=t.value.transform(n):t.body=e(t.body,n)}t(f,i),t($,function(t,e){t.label=t.label.transform(e),t.body=t.body.transform(e)}),t(A,function(t,e){t.body=t.body.transform(e)}),t(g,function(t,n){t.body=e(t.body,n)}),t(N,function(t,e){t.body=t.body.transform(e),t.condition=t.condition.transform(e)}),t(C,function(t,e){t.condition=t.condition.transform(e),t.body=t.body.transform(e)}),t(P,function(t,e){t.init&&(t.init=t.init.transform(e)),t.condition&&(t.condition=t.condition.transform(e)),t.step&&(t.step=t.step.transform(e)),t.body=t.body.transform(e)}),t(B,function(t,e){t.init=t.init.transform(e),t.object=t.object.transform(e),t.body=t.body.transform(e)}),t(F,function(t,e){t.expression=t.expression.transform(e),t.body=t.body.transform(e)}),t(dt,function(t,e){t.value&&(t.value=t.value.transform(e))}),t(_t,function(t,e){t.label&&(t.label=t.label.transform(e))}),t(vt,function(t,e){t.condition=t.condition.transform(e),t.body=t.body.transform(e),t.alternative&&(t.alternative=t.alternative.transform(e))}),t(wt,function(t,n){t.expression=t.expression.transform(n),t.body=e(t.body,n)}),t(Tt,function(t,n){t.expression=t.expression.transform(n),t.body=e(t.body,n)}),t(Et,function(t,n){t.body=e(t.body,n),t.bcatch&&(t.bcatch=t.bcatch.transform(n)),t.bfinally&&(t.bfinally=t.bfinally.transform(n))}),t(gt,function(t,n){t.argname&&(t.argname=t.argname.transform(n)),t.body=e(t.body,n)}),t(xt,function(t,n){t.definitions=e(t.definitions,n)}),t(Nt,function(t,e){t.name=t.name.transform(e),t.value&&(t.value=t.value.transform(e))}),t(jt,function(t,e){t.name=t.name.transform(e),t.value=t.value.transform(e)}),t(V,function(t,n){t.name&&(t.name=t.name.transform(n)),t.argnames=e(t.argnames,n),t.rest&&(t.rest=t.rest.transform(n)),t.body=e(t.body,n)}),t(U,o),t(M,o),t(ot,function(t,n){t.name&&(t.name=t.name.transform(n)),t.extends&&(t.extends=t.extends.transform(n)),t.properties=e(t.properties,n)}),t(rt,function(t,e){t.key instanceof f&&(t.key=t.key.transform(e)),t.value&&(t.value=t.value.transform(e))}),t(It,function(t,n){t.expression=t.expression.transform(n),t.args=e(t.args,n)}),t(Rt,function(t,n){t.expressions=e(t.expressions,n)}),t(Xt,function(t,e){t.expression=t.expression.transform(e)}),t(Zt,function(t,e){t.expression&&(t.expression=t.expression.transform(e))}),t(Gt,function(t,e){t.expression=t.expression.transform(e)}),t(Wt,function(t,e){t.expression=t.expression.transform(e),t.property=t.property.transform(e)}),t(zt,function(t,e){t.expression=t.expression.transform(e)}),t(Ut,function(t,e){t.expression=t.expression.transform(e)}),t(Jt,function(t,e){t.left=t.left.transform(e),t.right=t.right.transform(e)}),t(Kt,function(t,e){t.condition=t.condition.transform(e),t.consequent=t.consequent.transform(e),t.alternative=t.alternative.transform(e)}),t(te,function(t,n){t.elements=e(t.elements,n)}),t(oe,function(t,n){t.elements=e(t.elements,n),t.rest&&(t.rest=t.rest.transform(n))}),t(ie,function(t,e){t.key instanceof f&&(t.key=t.key.transform(e)),t.value=t.value.transform(e)}),t(ae,function(t,n){t.properties=e(t.properties,n),t.rest&&(t.rest=t.rest.transform(n))}),t(re,function(t,n){t.properties=e(t.properties,n)}),t(se,function(t,e){t.key instanceof f&&(t.key=t.key.transform(e)),t.value=t.value.transform(e)}),t(Ct,function(t,e){t.body=t.body.transform(e)}),t(Pt,function(t,e){t.body=t.body.transform(e)}),t(Lt,function(t,n){t.properties=e(t.properties,n)}),t(Ot,function(t,n){t.all&&(t.all=t.all.transform(n)),t.default&&(t.default=t.default.transform(n)),t.properties&&(t.properties=e(t.properties,n))}),t(Ce,function(t,n){t.tag&&(t.tag=t.tag.transform(n)),t.expressions=e(t.expressions,n)})}(function(t,e){t.DEFMETHOD("transform",function(t,n){var o,i;return t.push(this),t.before&&(o=t.before(this,e,n)),void 0===o&&(e(o=this,t),t.after&&void 0!==(i=t.after(o,n))&&(o=i)),t.pop(),o})}),l={parse:null,DEFNODE:u,AST_Token:c,AST_Node:f,AST_Statement:m,AST_Debugger:_,AST_Directive:S,AST_EmptyStatement:b,AST_SimpleStatement:A,AST_BlockScope:T,AST_Block:g,AST_BlockStatement:k,AST_StatementWithBody:x,AST_LabeledStatement:$,AST_IterationStatement:q,AST_DWLoop:D,AST_Do:N,AST_While:C,AST_For:P,AST_ForEnumeration:B,AST_ForIn:L,AST_ForOf:O,AST_ForAwaitOf:j,AST_With:F,AST_Scope:I,AST_Toplevel:Y,AST_ClassInitBlock:R,AST_Lambda:V,AST_Accessor:G,AST_LambdaExpression:W,AST_Arrow:U,AST_AsyncArrow:M,AST_AsyncFunction:H,AST_Function:K,AST_GeneratorFunction:Q,AST_AsyncGeneratorFunction:J,AST_LambdaDefinition:X,AST_AsyncDefun:Z,AST_AsyncGeneratorDefun:tt,AST_Defun:et,AST_GeneratorDefun:nt,AST_Class:ot,AST_DefClass:it,AST_ClassExpression:at,AST_ClassProperty:rt,AST_ClassField:st,AST_ClassGetter:lt,AST_ClassSetter:ut,AST_ClassMethod:ct,AST_ClassInit:ft,AST_Jump:ht,AST_Exit:dt,AST_Return:pt,AST_Throw:mt,AST_LoopControl:_t,AST_Break:St,AST_Continue:bt,AST_If:vt,AST_Switch:wt,AST_SwitchBranch:yt,AST_Default:At,AST_Case:Tt,AST_Try:Et,AST_Catch:gt,AST_Finally:kt,AST_Definitions:xt,AST_Const:$t,AST_Let:qt,AST_Var:Dt,AST_VarDef:Nt,AST_ExportDeclaration:Ct,AST_ExportDefault:Pt,AST_ExportForeign:Bt,AST_ExportReferences:Lt,AST_Import:Ot,AST_DefaultValue:jt,AST_Call:It,AST_New:Yt,AST_Sequence:Rt,AST_PropAccess:Vt,AST_Dot:Gt,AST_Sub:Wt,AST_Spread:zt,AST_Unary:Ut,AST_UnaryPrefix:Mt,AST_UnaryPostfix:Ht,AST_Binary:Jt,AST_Conditional:Kt,AST_Assign:Qt,AST_Await:Xt,AST_Yield:Zt,AST_Array:te,AST_Destructured:ee,AST_DestructuredArray:oe,AST_DestructuredKeyVal:ie,AST_DestructuredObject:ae,AST_Object:re,AST_ObjectProperty:se,AST_ObjectKeyVal:le,AST_ObjectMethod:ue,AST_ObjectSetter:ce,AST_ObjectGetter:fe,AST_Symbol:he,AST_SymbolDeclaration:de,AST_SymbolConst:pe,AST_SymbolImport:me,AST_SymbolLet:_e,AST_SymbolVar:Se,AST_SymbolFunarg:be,AST_SymbolDefun:ve,AST_SymbolLambda:we,AST_SymbolDefClass:ye,AST_SymbolClass:Ae,AST_SymbolCatch:Te,AST_Label:Ee,AST_SymbolRef:ge,AST_SymbolExport:ke,AST_LabelRef:xe,AST_ObjectIdentity:$e,AST_Super:qe,AST_This:De,AST_NewTarget:Ne,AST_Template:Ce,AST_Constant:Pe,AST_String:Be,AST_Number:Le,AST_BigInt:Oe,AST_RegExp:je,AST_Atom:Fe,AST_Null:Ie,AST_NaN:Ye,AST_Undefined:Re,AST_Hole:Ve,AST_Infinity:Ge,AST_Boolean:We,AST_False:ze,AST_True:Ue,first_in_statement:function(t,e,n){for(var o,i=t.parent(-1),a=0;o=t.parent(a++);i=o){if(z(o))return e&&o.value===i;if(o instanceof Jt){if(o.left===i)continue}else if("Call"==o.TYPE){if(o.expression===i)continue}else if(o instanceof Kt){if(o.condition===i)continue}else{if(o instanceof Pt)return n;if(o instanceof Vt){if(o.expression===i)continue}else if(o instanceof Rt){if(o.expressions[0]===i)continue}else{if(o instanceof A)return!0;if(o instanceof Ce){if(o.tag===i)continue}else if(o instanceof Ht&&o.expression===i)continue}}return!1}},is_arrow:z,is_generator:function(t){return t instanceof tt||t instanceof J||t instanceof nt||t instanceof Q},walk_lambda:function(t,e){z(t)&&t.value?t.value.walk(e):E(t,e)},walk_body:E,TreeWalker:Me,TreeTransformer:He}});
//# sourceMappingURL=sourcemaps/ast.js.map
