{"version":3,"sources":["mozilla-ast.js"],"names":["define","m_ast","AST_Accessor","AST_Array","AST_Arrow","AST_Assign","AST_AsyncFunction","AST_AsyncDefun","AST_AsyncArrow","AST_AsyncGeneratorFunction","AST_AsyncGeneratorDefun","AST_Atom","AST_Await","AST_BigInt","AST_Binary","AST_Block","AST_BlockStatement","AST_Boolean","AST_Break","AST_Call","AST_Case","AST_Catch","AST_ClassExpression","AST_ClassGetter","AST_ClassInit","AST_ClassSetter","AST_Conditional","AST_Const","AST_Constant","AST_Continue","AST_Debugger","AST_Default","AST_DefClass","AST_Definitions","AST_Defun","AST_Directive","AST_Do","AST_Dot","AST_EmptyStatement","AST_ExportDeclaration","AST_False","AST_Finally","AST_For","AST_ForIn","AST_ForOf","AST_Function","AST_Hole","AST_If","AST_Import","AST_Infinity","AST_Label","AST_LabeledStatement","AST_LabelRef","AST_Lambda","AST_Let","AST_New","AST_NewTarget","AST_Node","AST_Null","AST_Number","AST_Object","AST_ObjectGetter","AST_ObjectKeyVal","AST_ObjectProperty","AST_ObjectSetter","AST_PropAccess","AST_RegExp","AST_Return","AST_Sequence","AST_SimpleStatement","AST_String","AST_Sub","AST_Super","AST_Switch","AST_SwitchBranch","AST_Symbol","AST_SymbolCatch","AST_SymbolClass","AST_SymbolConst","AST_SymbolDefClass","AST_SymbolDefun","AST_SymbolExport","AST_SymbolFunarg","AST_SymbolImport","AST_SymbolLambda","AST_SymbolLet","AST_SymbolRef","AST_SymbolVar","AST_This","AST_Throw","AST_Token","AST_Toplevel","AST_True","AST_Try","AST_Unary","AST_UnaryPostfix","AST_UnaryPrefix","AST_Var","AST_VarDef","AST_While","AST_With","AST_Yield","is_generator","is_arrow","is_async","To_Moz_MethodDefinition","kind","M","computed","key","to_moz","private","type","name","slice","value","static","To_Moz_ForOfStatement","is_await","await","left","init","right","object","body","To_Moz_Literal","operator","prefix","argument","raw","start","normalize_directives","i","length","stat","node","pos","raw_token","moznode","my_start_token","loc","range","file","source","line","col","column","endline","endcol","endpos","my_end_token","end","read_name","map","moztype","mytype","propmap","moz_to_me","me_to_moz","JSON","stringify","split","forEach","prop","m","exec","Error","moz","how","my","push","MOZ_TO_ME","Function","TYPE","join","exports","from_moz","def_to_moz","to_moz_block","to_moz_scope","FROM_MOZ_STACK","HOP","pop","from_moz_alias","set_moz_loc","mynode","handler","DEFMETHOD","this","to_mozilla_ast","to_moz_alias","alias","is_identifier_string","unshift","Program","ArrowFunctionExpression","argnames","rest","fn","params","param","async","FunctionDeclaration","ctor","generator","AST_GeneratorDefun","id","FunctionExpression","AST_GeneratorFunction","ClassDeclaration","extends","superClass","properties","ClassExpression","MethodDefinition","internal","AST_ClassMethod","PropertyDefinition","AST_ClassField","StaticBlock","AST_ClassInitBlock","ForOfStatement","AST_ForAwaitOf","TryStatement","handlers","guardedHandlers","block","bcatch","bfinally","finalizer","Property","args","method","AST_ObjectMethod","ArrayExpression","elements","elem","ArrayPattern","el","AST_DestructuredArray","ObjectPattern","props","AST_DestructuredKeyVal","AST_DestructuredObject","MemberExpression","optional","expression","property","MetaProperty","expr","meta","SwitchCase","test","consequent","ExportAllDeclaration","AST_ExportForeign","aliases","exported","keys","path","ExportDefaultDeclaration","decl","declaration","CTOR","AST_ExportDefault","ExportNamedDeclaration","specifiers","local","AST_ExportReferences","sym","ImportDeclaration","all","def","imported","default","ImportExpression","arg","VariableDeclaration","const","let","definitions","declarations","Literal","bigint","toLowerCase","val","negate","rx","regex","pattern","RegExp","flags","raw_source","isNaN","AST_NaN","isFinite","TemplateLiteral","AST_Template","expressions","strings","quasis","TaggedTemplateExpression","tmpl","quasi","tag","Identifier","p","level","Super","ThisExpression","ParenthesizedExpression","parens","ChainExpression","terminal","UpdateExpression","UnaryExpression","AST_DefaultValue","AST_Spread","AST_LambdaDefinition","argname","guard","definition","mangled_name","toString","match","String","last","str","index","tail","prototype","return_null","from_mozilla_ast","save_stack","ast","walk","TreeWalker","parent","s","AST_Scope","label","thedef","js_error"],"mappings":"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","file":"../mozilla-ast.js","sourcesContent":["define([\n    \"./ast\"\n],function(m_ast){\n    /***********************************************************************\n\n      A JavaScript tokenizer / parser / beautifier / compressor.\n      https://github.com/mishoo/UglifyJS\n\n      -------------------------------- (C) ---------------------------------\n\n                               Author: Mihai Bazon\n                             <mihai.bazon@gmail.com>\n                           http://mihai.bazon.net/blog\n\n      Distributed under the BSD license:\n\n        Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n        Redistribution and use in source and binary forms, with or without\n        modification, are permitted provided that the following conditions\n        are met:\n\n            * Redistributions of source code must retain the above\n              copyright notice, this list of conditions and the following\n              disclaimer.\n\n            * Redistributions in binary form must reproduce the above\n              copyright notice, this list of conditions and the following\n              disclaimer in the documentation and/or other materials\n              provided with the distribution.\n\n        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n        EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n        IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n        PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n        LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n        OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n        PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n        PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n        THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n        TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n        THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n        SUCH DAMAGE.\n\n     ***********************************************************************/\n\n    \"use strict\";\n\n    const {\n        AST_Accessor,\n        AST_Array,\n        AST_Arrow,\n        AST_Assign,\n        AST_AsyncFunction,\n        AST_AsyncDefun,\n        AST_AsyncArrow,\n        AST_AsyncGeneratorFunction,\n        AST_AsyncGeneratorDefun,\n        AST_Atom,\n        AST_Await,\n        AST_BigInt,\n        AST_Binary,\n        AST_Block,\n        AST_BlockStatement,\n        AST_Boolean,\n        AST_Break,\n        AST_Call,\n        AST_Case,\n        AST_Catch,\n        AST_Chain,\n        AST_Class,\n        AST_ClassStaticBlock,\n        AST_ClassExpression,\n        AST_ClassGetter,\n        AST_ClassInit,\n        AST_ClassProperty,\n        AST_ClassPrivateProperty,\n        AST_ClassSetter,\n        AST_ConciseMethod,\n        AST_Conditional,\n        AST_Const,\n        AST_Constant,\n        AST_Continue,\n        AST_Debugger,\n        AST_Default,\n        AST_DefaultAssign,\n        AST_DefClass,\n        AST_Definitions,\n        AST_Defun,\n        AST_Destructuring,\n        AST_Directive,\n        AST_Do,\n        AST_Dot,\n        AST_DotHash,\n        AST_EmptyStatement,\n        AST_Expansion,\n        AST_Export,\n        AST_ExportDeclaration,\n        AST_False,\n        AST_Finally,\n        AST_For,\n        AST_ForIn,\n        AST_ForOf,\n        AST_Function,\n        AST_Hole,\n        AST_If,\n        AST_Import,\n        AST_ImportMeta,\n        AST_Infinity,\n        AST_Label,\n        AST_LabeledStatement,\n        AST_LabelRef,\n        AST_Lambda,\n        AST_Let,\n        AST_NameMapping,\n        AST_New,\n        AST_NewTarget,\n        AST_Node,\n        AST_Null,\n        AST_Number,\n        AST_Object,\n        AST_ObjectGetter,\n        AST_ObjectKeyVal,\n        AST_ObjectProperty,\n        AST_ObjectSetter,\n        AST_PrefixedTemplateString,\n        AST_PrivateGetter,\n        AST_PrivateMethod,\n        AST_PrivateSetter,\n        AST_PrivateIn,\n        AST_PropAccess,\n        AST_RegExp,\n        AST_Return,\n        AST_Sequence,\n        AST_SimpleStatement,\n        AST_Statement,\n        AST_String,\n        AST_Sub,\n        AST_Super,\n        AST_Switch,\n        AST_SwitchBranch,\n        AST_Symbol,\n        AST_SymbolCatch,\n        AST_SymbolClass,\n        AST_SymbolClassProperty,\n        AST_SymbolPrivateProperty,\n        AST_SymbolConst,\n        AST_SymbolDefClass,\n        AST_SymbolDefun,\n        AST_SymbolExport,\n        AST_SymbolExportForeign,\n        AST_SymbolFunarg,\n        AST_SymbolImport,\n        AST_SymbolImportForeign,\n        AST_SymbolLambda,\n        AST_SymbolLet,\n        AST_SymbolMethod,\n        AST_SymbolRef,\n        AST_SymbolVar,\n        AST_TemplateSegment,\n        AST_TemplateString,\n        AST_This,\n        AST_Throw,\n        AST_Token,\n        AST_Toplevel,\n        AST_True,\n        AST_Try,\n        AST_TryBlock,\n        AST_Unary,\n        AST_UnaryPostfix,\n        AST_UnaryPrefix,\n        AST_Var,\n        AST_VarDef,\n        AST_While,\n        AST_With,\n        AST_Yield,\n\n        is_generator,\n        is_arrow,\n        is_async\n    } = m_ast;\n\n    (function() {\n        var MOZ_TO_ME = {\n            Program: function(M) {\n                return new AST_Toplevel({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    body: normalize_directives(M.body.map(from_moz)),\n                });\n            },\n            ArrowFunctionExpression: function(M) {\n                var argnames = [], rest = null;\n                M.params.forEach(function(param) {\n                    if (param.type == \"RestElement\") {\n                        rest = from_moz(param.argument);\n                    } else {\n                        argnames.push(from_moz(param));\n                    }\n                });\n                var fn = new (M.async ? AST_AsyncArrow : AST_Arrow)({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    argnames: argnames,\n                    rest: rest,\n                });\n                var node = from_moz(M.body);\n                if (node instanceof AST_BlockStatement) {\n                    fn.body = normalize_directives(node.body);\n                    fn.value = null;\n                } else {\n                    fn.body = [];\n                    fn.value = node;\n                }\n                return fn;\n            },\n            FunctionDeclaration: function(M) {\n                var ctor;\n                if (M.async) {\n                    ctor = M.generator ? AST_AsyncGeneratorDefun : AST_AsyncDefun;\n                } else {\n                    ctor = M.generator ? AST_GeneratorDefun : AST_Defun;\n                }\n                var argnames = [], rest = null;\n                M.params.forEach(function(param) {\n                    if (param.type == \"RestElement\") {\n                        rest = from_moz(param.argument);\n                    } else {\n                        argnames.push(from_moz(param));\n                    }\n                });\n                return new ctor({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: from_moz(M.id),\n                    argnames: argnames,\n                    rest: rest,\n                    body: normalize_directives(from_moz(M.body).body),\n                });\n            },\n            FunctionExpression: function(M) {\n                var ctor;\n                if (M.async) {\n                    ctor = M.generator ? AST_AsyncGeneratorFunction : AST_AsyncFunction;\n                } else {\n                    ctor = M.generator ? AST_GeneratorFunction : AST_Function;\n                }\n                var argnames = [], rest = null;\n                M.params.forEach(function(param) {\n                    if (param.type == \"RestElement\") {\n                        rest = from_moz(param.argument);\n                    } else {\n                        argnames.push(from_moz(param));\n                    }\n                });\n                return new ctor({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: from_moz(M.id),\n                    argnames: argnames,\n                    rest: rest,\n                    body: normalize_directives(from_moz(M.body).body),\n                });\n            },\n            ClassDeclaration: function(M) {\n                return new AST_DefClass({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: from_moz(M.id),\n                    extends: from_moz(M.superClass),\n                    properties: M.body.body.map(from_moz),\n                });\n            },\n            ClassExpression: function(M) {\n                return new AST_ClassExpression({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: from_moz(M.id),\n                    extends: from_moz(M.superClass),\n                    properties: M.body.body.map(from_moz),\n                });\n            },\n            MethodDefinition: function(M) {\n                var key = M.key, internal = false;\n                if (M.computed) {\n                    key = from_moz(key);\n                } else if (key.type == \"PrivateIdentifier\") {\n                    internal = true;\n                    key = \"#\" + key.name;\n                } else {\n                    key = read_name(key);\n                }\n                var ctor = AST_ClassMethod, value = from_moz(M.value);\n                switch (M.kind) {\n                  case \"get\":\n                    ctor = AST_ClassGetter;\n                    value = new AST_Accessor(value);\n                    break;\n                  case \"set\":\n                    ctor = AST_ClassSetter;\n                    value = new AST_Accessor(value);\n                    break;\n                }\n                return new ctor({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    key: key,\n                    private: internal,\n                    static: M.static,\n                    value: value,\n                });\n            },\n            PropertyDefinition: function(M) {\n                var key = M.key, internal = false;\n                if (M.computed) {\n                    key = from_moz(key);\n                } else if (key.type == \"PrivateIdentifier\") {\n                    internal = true;\n                    key = \"#\" + key.name;\n                } else {\n                    key = read_name(key);\n                }\n                return new AST_ClassField({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    key: key,\n                    private: internal,\n                    static: M.static,\n                    value: from_moz(M.value),\n                });\n            },\n            StaticBlock: function(M) {\n                var start = my_start_token(M);\n                var end = my_end_token(M);\n                return new AST_ClassInit({\n                    start: start,\n                    end: end,\n                    value: new AST_ClassInitBlock({\n                        start: start,\n                        end: end,\n                        body: normalize_directives(M.body.map(from_moz)),\n                    }),\n                });\n            },\n            ForOfStatement: function(M) {\n                return new (M.await ? AST_ForAwaitOf : AST_ForOf)({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    init: from_moz(M.left),\n                    object: from_moz(M.right),\n                    body: from_moz(M.body),\n                });\n            },\n            TryStatement: function(M) {\n                var handlers = M.handlers || [M.handler];\n                if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n                    throw new Error(\"Multiple catch clauses are not supported.\");\n                }\n                return new AST_Try({\n                    start    : my_start_token(M),\n                    end      : my_end_token(M),\n                    body     : from_moz(M.block).body,\n                    bcatch   : from_moz(handlers[0]),\n                    bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null,\n                });\n            },\n            Property: function(M) {\n                var key = M.computed ? from_moz(M.key) : read_name(M.key);\n                var args = {\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    key: key,\n                    value: from_moz(M.value),\n                };\n                if (M.kind == \"init\") return new (M.method ? AST_ObjectMethod : AST_ObjectKeyVal)(args);\n                args.value = new AST_Accessor(args.value);\n                if (M.kind == \"get\") return new AST_ObjectGetter(args);\n                if (M.kind == \"set\") return new AST_ObjectSetter(args);\n            },\n            ArrayExpression: function(M) {\n                return new AST_Array({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    elements: M.elements.map(function(elem) {\n                        return elem === null ? new AST_Hole() : from_moz(elem);\n                    }),\n                });\n            },\n            ArrayPattern: function(M) {\n                var elements = [], rest = null;\n                M.elements.forEach(function(el) {\n                    if (el === null) {\n                        elements.push(new AST_Hole());\n                    } else if (el.type == \"RestElement\") {\n                        rest = from_moz(el.argument);\n                    } else {\n                        elements.push(from_moz(el));\n                    }\n                });\n                return new AST_DestructuredArray({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    elements: elements,\n                    rest: rest,\n                });\n            },\n            ObjectPattern: function(M) {\n                var props = [], rest = null;\n                M.properties.forEach(function(prop) {\n                    if (prop.type == \"RestElement\") {\n                        rest = from_moz(prop.argument);\n                    } else {\n                        props.push(new AST_DestructuredKeyVal(from_moz(prop)));\n                    }\n                });\n                return new AST_DestructuredObject({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    properties: props,\n                    rest: rest,\n                });\n            },\n            MemberExpression: function(M) {\n                return new (M.computed ? AST_Sub : AST_Dot)({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    optional: M.optional,\n                    expression: from_moz(M.object),\n                    property: M.computed ? from_moz(M.property) : M.property.name,\n                });\n            },\n            MetaProperty: function(M) {\n                var expr = from_moz(M.meta);\n                var prop = read_name(M.property);\n                if (expr.name == \"new\" && prop == \"target\") return new AST_NewTarget({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: \"new.target\",\n                });\n                return new AST_Dot({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    expression: expr,\n                    property: prop,\n                });\n            },\n            SwitchCase: function(M) {\n                return new (M.test ? AST_Case : AST_Default)({\n                    start      : my_start_token(M),\n                    end        : my_end_token(M),\n                    expression : from_moz(M.test),\n                    body       : M.consequent.map(from_moz),\n                });\n            },\n            ExportAllDeclaration: function(M) {\n                var start = my_start_token(M);\n                var end = my_end_token(M);\n                return new AST_ExportForeign({\n                    start: start,\n                    end: end,\n                    aliases: [ M.exported ? from_moz_alias(M.exported) : new AST_String({\n                        start: start,\n                        value: \"*\",\n                        end: end,\n                    }) ],\n                    keys: [ new AST_String({\n                        start: start,\n                        value: \"*\",\n                        end: end,\n                    }) ],\n                    path: from_moz(M.source),\n                });\n            },\n            ExportDefaultDeclaration: function(M) {\n                var decl = from_moz(M.declaration);\n                if (!decl.name) switch (decl.CTOR) {\n                  case AST_AsyncDefun:\n                    decl = new AST_AsyncFunction(decl);\n                    break;\n                  case AST_AsyncGeneratorDefun:\n                    decl = new AST_AsyncGeneratorFunction(decl);\n                    break;\n                  case AST_DefClass:\n                    decl = new AST_ClassExpression(decl);\n                    break;\n                  case AST_Defun:\n                    decl = new AST_Function(decl);\n                    break;\n                  case AST_GeneratorDefun:\n                    decl = new AST_GeneratorFunction(decl);\n                    break;\n                }\n                return new AST_ExportDefault({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    body: decl,\n                });\n            },\n            ExportNamedDeclaration: function(M) {\n                if (M.declaration) return new AST_ExportDeclaration({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    body: from_moz(M.declaration),\n                });\n                if (M.source) {\n                    var aliases = [], keys = [];\n                    M.specifiers.forEach(function(prop) {\n                        aliases.push(from_moz_alias(prop.exported));\n                        keys.push(from_moz_alias(prop.local));\n                    });\n                    return new AST_ExportForeign({\n                        start: my_start_token(M),\n                        end: my_end_token(M),\n                        aliases: aliases,\n                        keys: keys,\n                        path: from_moz(M.source),\n                    });\n                }\n                return new AST_ExportReferences({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    properties: M.specifiers.map(function(prop) {\n                        var sym = new AST_SymbolExport(from_moz(prop.local));\n                        sym.alias = from_moz_alias(prop.exported);\n                        return sym;\n                    }),\n                });\n            },\n            ImportDeclaration: function(M) {\n                var start = my_start_token(M);\n                var end = my_end_token(M);\n                var all = null, def = null, props = null;\n                M.specifiers.forEach(function(prop) {\n                    var sym = new AST_SymbolImport(from_moz(prop.local));\n                    switch (prop.type) {\n                      case \"ImportDefaultSpecifier\":\n                        def = sym;\n                        def.key = new AST_String({\n                            start: start,\n                            value: \"\",\n                            end: end,\n                        });\n                        break;\n                      case \"ImportNamespaceSpecifier\":\n                        all = sym;\n                        all.key = new AST_String({\n                            start: start,\n                            value: \"*\",\n                            end: end,\n                        });\n                        break;\n                      default:\n                        sym.key = from_moz_alias(prop.imported);\n                        if (!props) props = [];\n                        props.push(sym);\n                        break;\n                    }\n                });\n                return new AST_Import({\n                    start: start,\n                    end: end,\n                    all: all,\n                    default: def,\n                    properties: props,\n                    path: from_moz(M.source),\n                });\n            },\n            ImportExpression: function(M) {\n                var start = my_start_token(M);\n                var arg = from_moz(M.source);\n                return new AST_Call({\n                    start: start,\n                    end: my_end_token(M),\n                    expression: new AST_SymbolRef({\n                        start: start,\n                        end: arg.start,\n                        name: \"import\",\n                    }),\n                    args: [ arg ],\n                });\n            },\n            VariableDeclaration: function(M) {\n                return new ({\n                    const: AST_Const,\n                    let: AST_Let,\n                }[M.kind] || AST_Var)({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    definitions: M.declarations.map(from_moz),\n                });\n            },\n            Literal: function(M) {\n                var args = {\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                };\n                if (M.bigint) {\n                    args.value = M.bigint.toLowerCase() + \"n\";\n                    return new AST_BigInt(args);\n                }\n                var val = M.value;\n                if (val === null) return new AST_Null(args);\n                var rx = M.regex;\n                if (rx && rx.pattern) {\n                    // RegExpLiteral as per ESTree AST spec\n                    args.value = new RegExp(rx.pattern, rx.flags);\n                    args.value.raw_source = rx.pattern;\n                    return new AST_RegExp(args);\n                } else if (rx) {\n                    // support legacy RegExp\n                    args.value = M.regex && M.raw ? M.raw : val;\n                    return new AST_RegExp(args);\n                }\n                switch (typeof val) {\n                  case \"string\":\n                    args.value = val;\n                    return new AST_String(args);\n                  case \"number\":\n                    if (isNaN(val)) return new AST_NaN(args);\n                    var negate, node;\n                    if (isFinite(val)) {\n                        negate = 1 / val < 0;\n                        args.value = negate ? -val : val;\n                        node = new AST_Number(args);\n                    } else {\n                        negate = val < 0;\n                        node = new AST_Infinity(args);\n                    }\n                    return negate ? new AST_UnaryPrefix({\n                        start: args.start,\n                        end: args.end,\n                        operator: \"-\",\n                        expression: node,\n                    }) : node;\n                  case \"boolean\":\n                    return new (val ? AST_True : AST_False)(args);\n                }\n            },\n            TemplateLiteral: function(M) {\n                return new AST_Template({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    expressions: M.expressions.map(from_moz),\n                    strings: M.quasis.map(function(el) {\n                        return el.value.raw;\n                    }),\n                });\n            },\n            TaggedTemplateExpression: function(M) {\n                var tmpl = from_moz(M.quasi);\n                tmpl.start = my_start_token(M);\n                tmpl.end = my_end_token(M);\n                tmpl.tag = from_moz(M.tag);\n                return tmpl;\n            },\n            Identifier: function(M) {\n                var p, level = FROM_MOZ_STACK.length - 1;\n                do {\n                    p = FROM_MOZ_STACK[--level];\n                } while (p.type == \"ArrayPattern\"\n                    || p.type == \"AssignmentPattern\" && p.left === FROM_MOZ_STACK[level + 1]\n                    || p.type == \"ObjectPattern\"\n                    || p.type == \"Property\" && p.value === FROM_MOZ_STACK[level + 1]\n                    || p.type == \"VariableDeclarator\" && p.id === FROM_MOZ_STACK[level + 1]);\n                var ctor = AST_SymbolRef;\n                switch (p.type) {\n                  case \"ArrowFunctionExpression\":\n                    if (p.body !== FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolFunarg;\n                    break;\n                  case \"BreakStatement\":\n                  case \"ContinueStatement\":\n                    ctor = AST_LabelRef;\n                    break;\n                  case \"CatchClause\":\n                    ctor = AST_SymbolCatch;\n                    break;\n                  case \"ClassDeclaration\":\n                    if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolDefClass;\n                    break;\n                  case \"ClassExpression\":\n                    if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolClass;\n                    break;\n                  case \"FunctionDeclaration\":\n                    ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolDefun : AST_SymbolFunarg;\n                    break;\n                  case \"FunctionExpression\":\n                    ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolLambda : AST_SymbolFunarg;\n                    break;\n                  case \"LabeledStatement\":\n                    ctor = AST_Label;\n                    break;\n                  case \"VariableDeclaration\":\n                    ctor = {\n                        const: AST_SymbolConst,\n                        let: AST_SymbolLet,\n                    }[p.kind] || AST_SymbolVar;\n                    break;\n                }\n                return new ctor({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: M.name,\n                });\n            },\n            Super: function(M) {\n                return new AST_Super({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: \"super\",\n                });\n            },\n            ThisExpression: function(M) {\n                return new AST_This({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: \"this\",\n                });\n            },\n            ParenthesizedExpression: function(M) {\n                var node = from_moz(M.expression);\n                if (!node.start.parens) node.start.parens = [];\n                node.start.parens.push(my_start_token(M));\n                if (!node.end.parens) node.end.parens = [];\n                node.end.parens.push(my_end_token(M));\n                return node;\n            },\n            ChainExpression: function(M) {\n                var node = from_moz(M.expression);\n                node.terminal = true;\n                return node;\n            },\n        };\n\n        MOZ_TO_ME.UpdateExpression =\n        MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n            var prefix = \"prefix\" in M ? M.prefix\n                : M.type == \"UnaryExpression\" ? true : false;\n            return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                operator   : M.operator,\n                expression : from_moz(M.argument)\n            });\n        };\n\n        map(\"EmptyStatement\", AST_EmptyStatement);\n        map(\"ExpressionStatement\", AST_SimpleStatement, \"expression>body\");\n        map(\"BlockStatement\", AST_BlockStatement, \"body@body\");\n        map(\"IfStatement\", AST_If, \"test>condition, consequent>body, alternate>alternative\");\n        map(\"LabeledStatement\", AST_LabeledStatement, \"label>label, body>body\");\n        map(\"BreakStatement\", AST_Break, \"label>label\");\n        map(\"ContinueStatement\", AST_Continue, \"label>label\");\n        map(\"WithStatement\", AST_With, \"object>expression, body>body\");\n        map(\"SwitchStatement\", AST_Switch, \"discriminant>expression, cases@body\");\n        map(\"ReturnStatement\", AST_Return, \"argument>value\");\n        map(\"ThrowStatement\", AST_Throw, \"argument>value\");\n        map(\"WhileStatement\", AST_While, \"test>condition, body>body\");\n        map(\"DoWhileStatement\", AST_Do, \"test>condition, body>body\");\n        map(\"ForStatement\", AST_For, \"init>init, test>condition, update>step, body>body\");\n        map(\"ForInStatement\", AST_ForIn, \"left>init, right>object, body>body\");\n        map(\"DebuggerStatement\", AST_Debugger);\n        map(\"VariableDeclarator\", AST_VarDef, \"id>name, init>value\");\n        map(\"CatchClause\", AST_Catch, \"param>argname, body%body\");\n\n        map(\"BinaryExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n        map(\"LogicalExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n        map(\"AssignmentExpression\", AST_Assign, \"operator=operator, left>left, right>right\");\n        map(\"AssignmentPattern\", AST_DefaultValue, \"left>name, right>value\");\n        map(\"ConditionalExpression\", AST_Conditional, \"test>condition, consequent>consequent, alternate>alternative\");\n        map(\"NewExpression\", AST_New, \"callee>expression, arguments@args, pure=pure\");\n        map(\"CallExpression\", AST_Call, \"callee>expression, arguments@args, optional=optional, pure=pure\");\n        map(\"SequenceExpression\", AST_Sequence, \"expressions@expressions\");\n        map(\"SpreadElement\", AST_Spread, \"argument>expression\");\n        map(\"ObjectExpression\", AST_Object, \"properties@properties\");\n        map(\"AwaitExpression\", AST_Await, \"argument>expression\");\n        map(\"YieldExpression\", AST_Yield, \"argument>expression, delegate=nested\");\n\n        def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n            return to_moz_scope(\"Program\", M);\n        });\n\n        def_to_moz(AST_LambdaDefinition, function To_Moz_FunctionDeclaration(M) {\n            var params = M.argnames.map(to_moz);\n            if (M.rest) params.push({\n                type: \"RestElement\",\n                argument: to_moz(M.rest),\n            });\n            return {\n                type: \"FunctionDeclaration\",\n                id: to_moz(M.name),\n                async: is_async(M),\n                generator: is_generator(M),\n                params: params,\n                body: to_moz_scope(\"BlockStatement\", M),\n            };\n        });\n\n        def_to_moz(AST_Lambda, function To_Moz_FunctionExpression(M) {\n            var params = M.argnames.map(to_moz);\n            if (M.rest) params.push({\n                type: \"RestElement\",\n                argument: to_moz(M.rest),\n            });\n            if (is_arrow(M)) return {\n                type: \"ArrowFunctionExpression\",\n                async: is_async(M),\n                params: params,\n                body: M.value ? to_moz(M.value) : to_moz_scope(\"BlockStatement\", M),\n            };\n            return {\n                type: \"FunctionExpression\",\n                id: to_moz(M.name),\n                async: is_async(M),\n                generator: is_generator(M),\n                params: params,\n                body: to_moz_scope(\"BlockStatement\", M),\n            };\n        });\n\n        def_to_moz(AST_DefClass, function To_Moz_ClassDeclaration(M) {\n            return {\n                type: \"ClassDeclaration\",\n                id: to_moz(M.name),\n                superClass: to_moz(M.extends),\n                body: {\n                    type: \"ClassBody\",\n                    body: M.properties.map(to_moz),\n                },\n            };\n        });\n\n        def_to_moz(AST_ClassExpression, function To_Moz_ClassExpression(M) {\n            return {\n                type: \"ClassExpression\",\n                id: to_moz(M.name),\n                superClass: to_moz(M.extends),\n                body: {\n                    type: \"ClassBody\",\n                    body: M.properties.map(to_moz),\n                },\n            };\n        });\n\n        function To_Moz_MethodDefinition(kind) {\n            return function(M) {\n                var computed = M.key instanceof AST_Node;\n                var key = computed ? to_moz(M.key) : M.private ? {\n                    type: \"PrivateIdentifier\",\n                    name: M.key.slice(1),\n                } : {\n                    type: \"Literal\",\n                    value: M.key,\n                };\n                return {\n                    type: \"MethodDefinition\",\n                    kind: kind,\n                    computed: computed,\n                    key: key,\n                    static: M.static,\n                    value: to_moz(M.value),\n                };\n            };\n        }\n        def_to_moz(AST_ClassGetter, To_Moz_MethodDefinition(\"get\"));\n        def_to_moz(AST_ClassSetter, To_Moz_MethodDefinition(\"set\"));\n        def_to_moz(AST_ClassMethod, To_Moz_MethodDefinition(\"method\"));\n\n        def_to_moz(AST_ClassField, function To_Moz_PropertyDefinition(M) {\n            var computed = M.key instanceof AST_Node;\n            var key = computed ? to_moz(M.key) : M.private ? {\n                type: \"PrivateIdentifier\",\n                name: M.key.slice(1),\n            } : {\n                type: \"Literal\",\n                value: M.key,\n            };\n            return {\n                type: \"PropertyDefinition\",\n                computed: computed,\n                key: key,\n                static: M.static,\n                value: to_moz(M.value),\n            };\n        });\n\n        def_to_moz(AST_ClassInit, function To_Moz_StaticBlock(M) {\n            return to_moz_scope(\"StaticBlock\", M.value);\n        });\n\n        function To_Moz_ForOfStatement(is_await) {\n            return function(M) {\n                return {\n                    type: \"ForOfStatement\",\n                    await: is_await,\n                    left: to_moz(M.init),\n                    right: to_moz(M.object),\n                    body: to_moz(M.body),\n                };\n            };\n        }\n        def_to_moz(AST_ForAwaitOf, To_Moz_ForOfStatement(true));\n        def_to_moz(AST_ForOf, To_Moz_ForOfStatement(false));\n\n        def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n            return {\n                type: \"ExpressionStatement\",\n                expression: set_moz_loc(M, {\n                    type: \"Literal\",\n                    value: M.value,\n                }),\n            };\n        });\n\n        def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n            return {\n                type: \"SwitchCase\",\n                test: to_moz(M.expression),\n                consequent: M.body.map(to_moz),\n            };\n        });\n\n        def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n            return {\n                type: \"TryStatement\",\n                block: to_moz_block(M),\n                handler: to_moz(M.bcatch),\n                guardedHandlers: [],\n                finalizer: to_moz(M.bfinally),\n            };\n        });\n\n        def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n            return {\n                type: \"CatchClause\",\n                param: to_moz(M.argname),\n                guard: null,\n                body: to_moz_block(M),\n            };\n        });\n\n        def_to_moz(AST_ExportDeclaration, function To_Moz_ExportNamedDeclaration_declaration(M) {\n            return {\n                type: \"ExportNamedDeclaration\",\n                declaration: to_moz(M.body),\n            };\n        });\n\n        def_to_moz(AST_ExportDefault, function To_Moz_ExportDefaultDeclaration(M) {\n            return {\n                type: \"ExportDefaultDeclaration\",\n                declaration: to_moz(M.body),\n            };\n        });\n\n        def_to_moz(AST_ExportForeign, function To_Moz_ExportAllDeclaration_ExportNamedDeclaration(M) {\n            if (M.keys[0].value == \"*\") return {\n                type: \"ExportAllDeclaration\",\n                exported: M.aliases[0].value == \"*\" ? null : to_moz_alias(M.aliases[0]),\n                source: to_moz(M.path),\n            };\n            var specifiers = [];\n            for (var i = 0; i < M.aliases.length; i++) {\n                specifiers.push(set_moz_loc({\n                    start: M.keys[i].start,\n                    end: M.aliases[i].end,\n                }, {\n                    type: \"ExportSpecifier\",\n                    local: to_moz_alias(M.keys[i]),\n                    exported: to_moz_alias(M.aliases[i]),\n                }));\n            }\n            return {\n                type: \"ExportNamedDeclaration\",\n                specifiers: specifiers,\n                source: to_moz(M.path),\n            };\n        });\n\n        def_to_moz(AST_ExportReferences, function To_Moz_ExportNamedDeclaration_specifiers(M) {\n            return {\n                type: \"ExportNamedDeclaration\",\n                specifiers: M.properties.map(function(prop) {\n                    return set_moz_loc({\n                        start: prop.start,\n                        end: prop.alias.end,\n                    }, {\n                        type: \"ExportSpecifier\",\n                        local: to_moz(prop),\n                        exported: to_moz_alias(prop.alias),\n                    });\n                }),\n            };\n        });\n\n        def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n            var specifiers = M.properties ? M.properties.map(function(prop) {\n                return set_moz_loc({\n                    start: prop.key.start,\n                    end: prop.end,\n                }, {\n                    type: \"ImportSpecifier\",\n                    local: to_moz(prop),\n                    imported: to_moz_alias(prop.key),\n                });\n            }) : [];\n            if (M.all) specifiers.unshift(set_moz_loc(M.all, {\n                type: \"ImportNamespaceSpecifier\",\n                local: to_moz(M.all),\n            }));\n            if (M.default) specifiers.unshift(set_moz_loc(M.default, {\n                type: \"ImportDefaultSpecifier\",\n                local: to_moz(M.default),\n            }));\n            return {\n                type: \"ImportDeclaration\",\n                specifiers: specifiers,\n                source: to_moz(M.path),\n            };\n        });\n\n        def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {\n            return {\n                type: \"VariableDeclaration\",\n                kind: M.TYPE.toLowerCase(),\n                declarations: M.definitions.map(to_moz),\n            };\n        });\n\n        def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n            var computed = M instanceof AST_Sub;\n            var expr = {\n                type: \"MemberExpression\",\n                object: to_moz(M.expression),\n                computed: computed,\n                optional: M.optional,\n                property: computed ? to_moz(M.property) : {\n                    type: \"Identifier\",\n                    name: M.property,\n                },\n            };\n            return M.terminal ? {\n                type: \"ChainExpression\",\n                expression: expr,\n            } : expr;\n        });\n\n        def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n            return {\n                type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n                operator: M.operator,\n                prefix: M instanceof AST_UnaryPrefix,\n                argument: to_moz(M.expression)\n            };\n        });\n\n        def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n            return {\n                type: M.operator == \"&&\" || M.operator == \"||\" ? \"LogicalExpression\" : \"BinaryExpression\",\n                left: to_moz(M.left),\n                operator: M.operator,\n                right: to_moz(M.right)\n            };\n        });\n\n        def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n            return {\n                type: \"ArrayExpression\",\n                elements: M.elements.map(to_moz),\n            };\n        });\n\n        def_to_moz(AST_DestructuredArray, function To_Moz_ArrayPattern(M) {\n            var elements = M.elements.map(to_moz);\n            if (M.rest) elements.push({\n                type: \"RestElement\",\n                argument: to_moz(M.rest),\n            });\n            return {\n                type: \"ArrayPattern\",\n                elements: elements,\n            };\n        });\n\n        def_to_moz(AST_DestructuredKeyVal, function To_Moz_Property(M) {\n            var computed = M.key instanceof AST_Node;\n            var key = computed ? to_moz(M.key) : {\n                type: \"Literal\",\n                value: M.key,\n            };\n            return {\n                type: \"Property\",\n                kind: \"init\",\n                computed: computed,\n                key: key,\n                value: to_moz(M.value),\n            };\n        });\n\n        def_to_moz(AST_DestructuredObject, function To_Moz_ObjectPattern(M) {\n            var props = M.properties.map(to_moz);\n            if (M.rest) props.push({\n                type: \"RestElement\",\n                argument: to_moz(M.rest),\n            });\n            return {\n                type: \"ObjectPattern\",\n                properties: props,\n            };\n        });\n\n        def_to_moz(AST_ObjectProperty, function To_Moz_Property(M) {\n            var computed = M.key instanceof AST_Node;\n            var key = computed ? to_moz(M.key) : {\n                type: \"Literal\",\n                value: M.key,\n            };\n            var kind;\n            if (M instanceof AST_ObjectKeyVal) {\n                kind = \"init\";\n            } else if (M instanceof AST_ObjectGetter) {\n                kind = \"get\";\n            } else if (M instanceof AST_ObjectSetter) {\n                kind = \"set\";\n            }\n            return {\n                type: \"Property\",\n                kind: kind,\n                computed: computed,\n                method: M instanceof AST_ObjectMethod,\n                key: key,\n                value: to_moz(M.value),\n            };\n        });\n\n        def_to_moz(AST_Symbol, function To_Moz_Identifier(M) {\n            var def = M.definition();\n            return {\n                type: \"Identifier\",\n                name: def && def.mangled_name || M.name,\n            };\n        });\n\n        def_to_moz(AST_Super, function To_Moz_Super() {\n            return { type: \"Super\" };\n        });\n\n        def_to_moz(AST_This, function To_Moz_ThisExpression() {\n            return { type: \"ThisExpression\" };\n        });\n\n        def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n            return {\n                type: \"MetaProperty\",\n                meta: {\n                    type: \"Identifier\",\n                    name: \"new\",\n                },\n                property: {\n                    type: \"Identifier\",\n                    name: \"target\",\n                },\n            };\n        });\n\n        def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n            var flags = M.value.toString().match(/\\/([gimuy]*)$/)[1];\n            var value = \"/\" + M.value.raw_source + \"/\" + flags;\n            return {\n                type: \"Literal\",\n                value: value,\n                raw: value,\n                regex: {\n                    pattern: M.value.raw_source,\n                    flags: flags,\n                },\n            };\n        });\n\n        def_to_moz(AST_BigInt, function To_Moz_BigInt(M) {\n            var value = M.value;\n            return {\n                type: \"Literal\",\n                bigint: value.slice(0, -1),\n                raw: value,\n            };\n        });\n\n        function To_Moz_Literal(M) {\n            var value = M.value;\n            if (typeof value === \"number\" && (value < 0 || (value === 0 && 1 / value < 0))) {\n                return {\n                    type: \"UnaryExpression\",\n                    operator: \"-\",\n                    prefix: true,\n                    argument: {\n                        type: \"Literal\",\n                        value: -value,\n                        raw: M.start.raw,\n                    },\n                };\n            }\n            return {\n                type: \"Literal\",\n                value: value,\n                raw: M.start.raw,\n            };\n        }\n        def_to_moz(AST_Boolean, To_Moz_Literal);\n        def_to_moz(AST_Constant, To_Moz_Literal);\n        def_to_moz(AST_Null, To_Moz_Literal);\n\n        def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n            return {\n                type: \"Identifier\",\n                name: String(M.value),\n            };\n        });\n\n        def_to_moz(AST_Template, function To_Moz_TemplateLiteral_TaggedTemplateExpression(M) {\n            var last = M.strings.length - 1;\n            var tmpl = {\n                type: \"TemplateLiteral\",\n                expressions: M.expressions.map(to_moz),\n                quasis: M.strings.map(function(str, index) {\n                    return {\n                        type: \"TemplateElement\",\n                        tail: index == last,\n                        value: { raw: str },\n                    };\n                }),\n            };\n            if (!M.tag) return tmpl;\n            return {\n                type: \"TaggedTemplateExpression\",\n                tag: to_moz(M.tag),\n                quasi: tmpl,\n            };\n        });\n\n        AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n        AST_Hole.DEFMETHOD(\"to_mozilla_ast\", return_null);\n        AST_Node.DEFMETHOD(\"to_mozilla_ast\", function() {\n            throw new Error(\"Cannot convert AST_\" + this.TYPE);\n        });\n\n        /* -----[ tools ]----- */\n\n        function normalize_directives(body) {\n            for (var i = 0; i < body.length; i++) {\n                var stat = body[i];\n                if (!(stat instanceof AST_SimpleStatement)) break;\n                var node = stat.body;\n                if (!(node instanceof AST_String)) break;\n                if (stat.start.pos !== node.start.pos) break;\n                body[i] = new AST_Directive(node);\n            }\n            return body;\n        }\n\n        function raw_token(moznode) {\n            if (moznode.type == \"Literal\") {\n                return moznode.raw != null ? moznode.raw : moznode.value + \"\";\n            }\n        }\n\n        function my_start_token(moznode) {\n            var loc = moznode.loc, start = loc && loc.start;\n            var range = moznode.range;\n            return new AST_Token({\n                file    : loc && loc.source,\n                line    : start && start.line,\n                col     : start && start.column,\n                pos     : range ? range[0] : moznode.start,\n                endline : start && start.line,\n                endcol  : start && start.column,\n                endpos  : range ? range[0] : moznode.start,\n                raw     : raw_token(moznode),\n            });\n        }\n\n        function my_end_token(moznode) {\n            var loc = moznode.loc, end = loc && loc.end;\n            var range = moznode.range;\n            return new AST_Token({\n                file    : loc && loc.source,\n                line    : end && end.line,\n                col     : end && end.column,\n                pos     : range ? range[1] : moznode.end,\n                endline : end && end.line,\n                endcol  : end && end.column,\n                endpos  : range ? range[1] : moznode.end,\n                raw     : raw_token(moznode),\n            });\n        }\n\n        function read_name(M) {\n            return \"\" + M[M.type == \"Identifier\" ? \"name\" : \"value\"];\n        }\n\n        function map(moztype, mytype, propmap) {\n            var moz_to_me = [\n                \"start: my_start_token(M)\",\n                \"end: my_end_token(M)\",\n            ];\n            var me_to_moz = [\n                \"type: \" + JSON.stringify(moztype),\n            ];\n\n            if (propmap) propmap.split(/\\s*,\\s*/).forEach(function(prop) {\n                var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);\n                if (!m) throw new Error(\"Can't understand property map: \" + prop);\n                var moz = m[1], how = m[2], my = m[3];\n                switch (how) {\n                  case \"@\":\n                    moz_to_me.push(my + \": M.\" + moz + \".map(from_moz)\");\n                    me_to_moz.push(moz + \": M.\" +  my + \".map(to_moz)\");\n                    break;\n                  case \">\":\n                    moz_to_me.push(my + \": from_moz(M.\" + moz + \")\");\n                    me_to_moz.push(moz + \": to_moz(M.\" + my + \")\");\n                    break;\n                  case \"=\":\n                    moz_to_me.push(my + \": M.\" + moz);\n                    me_to_moz.push(moz + \": M.\" + my);\n                    break;\n                  case \"%\":\n                    moz_to_me.push(my + \": from_moz(M.\" + moz + \").body\");\n                    me_to_moz.push(moz + \": to_moz_block(M)\");\n                    break;\n                  default:\n                    throw new Error(\"Can't understand operator in propmap: \" + prop);\n                }\n            });\n\n            MOZ_TO_ME[moztype] = new Function(\"U2\", \"my_start_token\", \"my_end_token\", \"from_moz\", [\n                \"return function From_Moz_\" + moztype + \"(M) {\",\n                \"    return new U2.AST_\" + mytype.TYPE + \"({\",\n                moz_to_me.join(\",\\n\"),\n                \"    });\",\n                \"};\",\n            ].join(\"\\n\"))(exports, my_start_token, my_end_token, from_moz);\n            def_to_moz(mytype, new Function(\"to_moz\", \"to_moz_block\", \"to_moz_scope\", [\n                \"return function To_Moz_\" + moztype + \"(M) {\",\n                \"    return {\",\n                me_to_moz.join(\",\\n\"),\n                \"    };\",\n                \"};\",\n            ].join(\"\\n\"))(to_moz, to_moz_block, to_moz_scope));\n        }\n\n        var FROM_MOZ_STACK = null;\n\n        function from_moz(moz) {\n            FROM_MOZ_STACK.push(moz);\n            var node = null;\n            if (moz) {\n                if (!HOP(MOZ_TO_ME, moz.type)) throw new Error(\"Unsupported type: \" + moz.type);\n                node = MOZ_TO_ME[moz.type](moz);\n            }\n            FROM_MOZ_STACK.pop();\n            return node;\n        }\n\n        function from_moz_alias(moz) {\n            return new AST_String({\n                start: my_start_token(moz),\n                value: read_name(moz),\n                end: my_end_token(moz),\n            });\n        }\n\n        AST_Node.from_mozilla_ast = function(node) {\n            var save_stack = FROM_MOZ_STACK;\n            FROM_MOZ_STACK = [];\n            var ast = from_moz(node);\n            FROM_MOZ_STACK = save_stack;\n            ast.walk(new TreeWalker(function(node) {\n                if (node instanceof AST_LabelRef) {\n                    for (var level = 0, parent; parent = this.parent(level); level++) {\n                        if (parent instanceof AST_Scope) break;\n                        if (parent instanceof AST_LabeledStatement && parent.label.name == node.name) {\n                            node.thedef = parent.label;\n                            break;\n                        }\n                    }\n                    if (!node.thedef) {\n                        var s = node.start;\n                        js_error(\"Undefined label \" + node.name, s.file, s.line, s.col, s.pos);\n                    }\n                }\n            }));\n            return ast;\n        };\n\n        function set_moz_loc(mynode, moznode) {\n            var start = mynode.start;\n            var end = mynode.end;\n            if (start.pos != null && end.endpos != null) {\n                moznode.range = [start.pos, end.endpos];\n            }\n            if (start.line) {\n                moznode.loc = {\n                    start: {line: start.line, column: start.col},\n                    end: end.endline ? {line: end.endline, column: end.endcol} : null,\n                };\n                if (start.file) {\n                    moznode.loc.source = start.file;\n                }\n            }\n            return moznode;\n        }\n\n        function def_to_moz(mytype, handler) {\n            mytype.DEFMETHOD(\"to_mozilla_ast\", function() {\n                return set_moz_loc(this, handler(this));\n            });\n        }\n\n        function to_moz(node) {\n            return node != null ? node.to_mozilla_ast() : null;\n        }\n\n        function to_moz_alias(alias) {\n            return is_identifier_string(alias.value) ? set_moz_loc(alias, {\n                type: \"Identifier\",\n                name: alias.value,\n            }) : to_moz(alias);\n        }\n\n        function to_moz_block(node) {\n            return {\n                type: \"BlockStatement\",\n                body: node.body.map(to_moz),\n            };\n        }\n\n        function to_moz_scope(type, node) {\n            var body = node.body.map(to_moz);\n            if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n                body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n            }\n            return {\n                type: type,\n                body: body,\n            };\n        }\n    })();\n});"]}