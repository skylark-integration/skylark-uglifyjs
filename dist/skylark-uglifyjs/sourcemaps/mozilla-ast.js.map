{"version":3,"sources":["mozilla-ast.js"],"names":["define","m_ast","AST_Accessor","AST_Array","AST_Arrow","AST_Assign","AST_Atom","AST_Await","AST_BigInt","AST_Binary","AST_Block","AST_BlockStatement","AST_Boolean","AST_Break","AST_Call","AST_Case","AST_Catch","AST_Chain","AST_Class","AST_ClassStaticBlock","AST_ClassExpression","AST_ClassProperty","AST_ClassPrivateProperty","AST_ConciseMethod","AST_Conditional","AST_Const","AST_Constant","AST_Continue","AST_Debugger","AST_Default","AST_DefaultAssign","AST_DefClass","AST_Definitions","AST_Defun","AST_Destructuring","AST_Directive","AST_Do","AST_Dot","AST_DotHash","AST_EmptyStatement","AST_Expansion","AST_Export","AST_False","AST_Finally","AST_For","AST_ForIn","AST_ForOf","AST_Function","AST_Hole","AST_If","AST_Import","AST_ImportMeta","AST_Label","AST_LabeledStatement","AST_LabelRef","AST_Lambda","AST_Let","AST_NameMapping","AST_New","AST_NewTarget","AST_Node","AST_Null","AST_Number","AST_Object","AST_ObjectGetter","AST_ObjectKeyVal","AST_ObjectProperty","AST_ObjectSetter","AST_PrefixedTemplateString","AST_PrivateGetter","AST_PrivateMethod","AST_PrivateSetter","AST_PrivateIn","AST_PropAccess","AST_RegExp","AST_Return","AST_Sequence","AST_SimpleStatement","AST_Statement","AST_String","AST_Sub","AST_Super","AST_Switch","AST_SwitchBranch","AST_Symbol","AST_SymbolCatch","AST_SymbolClass","AST_SymbolClassProperty","AST_SymbolPrivateProperty","AST_SymbolConst","AST_SymbolDefClass","AST_SymbolDefun","AST_SymbolExport","AST_SymbolExportForeign","AST_SymbolFunarg","AST_SymbolImport","AST_SymbolImportForeign","AST_SymbolLambda","AST_SymbolLet","AST_SymbolMethod","AST_SymbolRef","AST_SymbolVar","AST_TemplateSegment","AST_TemplateString","AST_This","AST_Throw","AST_Token","AST_Toplevel","AST_True","AST_Try","AST_TryBlock","AST_Unary","AST_UnaryPostfix","AST_UnaryPrefix","AST_Var","AST_VarDef","AST_While","AST_With","AST_Yield","is_generator","MOZ_TO_ME","Program","M","start","my_start_token","end","my_end_token","body","normalize_directives","map","from_moz","ArrowFunctionExpression","argnames","rest","params","forEach","param","type","argument","push","fn","async","AST_AsyncArrow","node","value","FunctionDeclaration","ctor","generator","AST_AsyncGeneratorDefun","AST_AsyncDefun","AST_GeneratorDefun","name","id","FunctionExpression","AST_AsyncGeneratorFunction","AST_AsyncFunction","AST_GeneratorFunction","ClassDeclaration","extends","superClass","properties","ClassExpression","MethodDefinition","key","internal","computed","read_name","AST_ClassMethod","kind","AST_ClassGetter","AST_ClassSetter","private","static","PropertyDefinition","AST_ClassField","StaticBlock","AST_ClassInit","AST_ClassInitBlock","ForOfStatement","await","AST_ForAwaitOf","init","left","object","right","TryStatement","handlers","handler","length","guardedHandlers","Error","block","bcatch","bfinally","finalizer","Property","args","method","AST_ObjectMethod","ArrayExpression","elements","elem","ArrayPattern","el","AST_DestructuredArray","ObjectPattern","props","prop","AST_DestructuredKeyVal","AST_DestructuredObject","MemberExpression","optional","expression","property","MetaProperty","expr","meta","SwitchCase","test","consequent","ExportAllDeclaration","AST_ExportForeign","aliases","exported","from_moz_alias","keys","path","source","ExportDefaultDeclaration","decl","declaration","CTOR","AST_ExportDefault","ExportNamedDeclaration","AST_ExportDeclaration","specifiers","local","AST_ExportReferences","sym","alias","ImportDeclaration","all","def","imported","default","ImportExpression","arg","VariableDeclaration","const","let","definitions","declarations","Literal","bigint","toLowerCase","val","rx","regex","pattern","RegExp","flags","raw_source","raw","isNaN","AST_NaN","isFinite","negate","AST_Infinity","operator","TemplateLiteral","AST_Template","expressions","strings","quasis","TaggedTemplateExpression","tmpl","quasi","tag","Identifier","p","level","FROM_MOZ_STACK","Super","ThisExpression","ParenthesizedExpression","parens","ChainExpression","terminal","To_Moz_MethodDefinition","to_moz","slice","To_Moz_ForOfStatement","is_await","To_Moz_Literal","prefix","i","stat","pos","raw_token","moznode","loc","range","file","line","col","column","endline","endcol","endpos","moztype","mytype","propmap","moz_to_me","me_to_moz","JSON","stringify","split","m","exec","moz","how","my","Function","TYPE","join","exports","def_to_moz","to_moz_block","to_moz_scope","UpdateExpression","UnaryExpression","AST_DefaultValue","AST_Spread","AST_LambdaDefinition","is_async","is_arrow","set_moz_loc","argname","guard","to_moz_alias","unshift","definition","mangled_name","toString","match","String","last","str","index","tail","DEFMETHOD","prototype","to_mozilla_ast","return_null","this","HOP","pop","mynode","is_identifier_string","from_mozilla_ast","save_stack","ast","walk","TreeWalker","parent","AST_Scope","label","thedef","s","js_error"],"mappings":"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","file":"../mozilla-ast.js","sourcesContent":["define([\n    \"./ast\"\n],function(m_ast){\n    /***********************************************************************\n\n      A JavaScript tokenizer / parser / beautifier / compressor.\n      https://github.com/mishoo/UglifyJS\n\n      -------------------------------- (C) ---------------------------------\n\n                               Author: Mihai Bazon\n                             <mihai.bazon@gmail.com>\n                           http://mihai.bazon.net/blog\n\n      Distributed under the BSD license:\n\n        Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n        Redistribution and use in source and binary forms, with or without\n        modification, are permitted provided that the following conditions\n        are met:\n\n            * Redistributions of source code must retain the above\n              copyright notice, this list of conditions and the following\n              disclaimer.\n\n            * Redistributions in binary form must reproduce the above\n              copyright notice, this list of conditions and the following\n              disclaimer in the documentation and/or other materials\n              provided with the distribution.\n\n        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n        EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n        IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n        PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n        LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n        OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n        PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n        PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n        THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n        TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n        THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n        SUCH DAMAGE.\n\n     ***********************************************************************/\n\n    \"use strict\";\n\n    const {\n        AST_Accessor,\n        AST_Array,\n        AST_Arrow,\n        AST_Assign,\n        AST_Atom,\n        AST_Await,\n        AST_BigInt,\n        AST_Binary,\n        AST_Block,\n        AST_BlockStatement,\n        AST_Boolean,\n        AST_Break,\n        AST_Call,\n        AST_Case,\n        AST_Catch,\n        AST_Chain,\n        AST_Class,\n        AST_ClassStaticBlock,\n        AST_ClassExpression,\n        AST_ClassProperty,\n        AST_ClassPrivateProperty,\n        AST_ConciseMethod,\n        AST_Conditional,\n        AST_Const,\n        AST_Constant,\n        AST_Continue,\n        AST_Debugger,\n        AST_Default,\n        AST_DefaultAssign,\n        AST_DefClass,\n        AST_Definitions,\n        AST_Defun,\n        AST_Destructuring,\n        AST_Directive,\n        AST_Do,\n        AST_Dot,\n        AST_DotHash,\n        AST_EmptyStatement,\n        AST_Expansion,\n        AST_Export,\n        AST_False,\n        AST_Finally,\n        AST_For,\n        AST_ForIn,\n        AST_ForOf,\n        AST_Function,\n        AST_Hole,\n        AST_If,\n        AST_Import,\n        AST_ImportMeta,\n        AST_Label,\n        AST_LabeledStatement,\n        AST_LabelRef,\n        AST_Lambda,\n        AST_Let,\n        AST_NameMapping,\n        AST_New,\n        AST_NewTarget,\n        AST_Node,\n        AST_Null,\n        AST_Number,\n        AST_Object,\n        AST_ObjectGetter,\n        AST_ObjectKeyVal,\n        AST_ObjectProperty,\n        AST_ObjectSetter,\n        AST_PrefixedTemplateString,\n        AST_PrivateGetter,\n        AST_PrivateMethod,\n        AST_PrivateSetter,\n        AST_PrivateIn,\n        AST_PropAccess,\n        AST_RegExp,\n        AST_Return,\n        AST_Sequence,\n        AST_SimpleStatement,\n        AST_Statement,\n        AST_String,\n        AST_Sub,\n        AST_Super,\n        AST_Switch,\n        AST_SwitchBranch,\n        AST_Symbol,\n        AST_SymbolCatch,\n        AST_SymbolClass,\n        AST_SymbolClassProperty,\n        AST_SymbolPrivateProperty,\n        AST_SymbolConst,\n        AST_SymbolDefClass,\n        AST_SymbolDefun,\n        AST_SymbolExport,\n        AST_SymbolExportForeign,\n        AST_SymbolFunarg,\n        AST_SymbolImport,\n        AST_SymbolImportForeign,\n        AST_SymbolLambda,\n        AST_SymbolLet,\n        AST_SymbolMethod,\n        AST_SymbolRef,\n        AST_SymbolVar,\n        AST_TemplateSegment,\n        AST_TemplateString,\n        AST_This,\n        AST_Throw,\n        AST_Token,\n        AST_Toplevel,\n        AST_True,\n        AST_Try,\n        AST_TryBlock,\n        AST_Unary,\n        AST_UnaryPostfix,\n        AST_UnaryPrefix,\n        AST_Var,\n        AST_VarDef,\n        AST_While,\n        AST_With,\n        AST_Yield,\n\n        is_generator\n    } = m_ast;\n\n    (function() {\n        var MOZ_TO_ME = {\n            Program: function(M) {\n                return new AST_Toplevel({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    body: normalize_directives(M.body.map(from_moz)),\n                });\n            },\n            ArrowFunctionExpression: function(M) {\n                var argnames = [], rest = null;\n                M.params.forEach(function(param) {\n                    if (param.type == \"RestElement\") {\n                        rest = from_moz(param.argument);\n                    } else {\n                        argnames.push(from_moz(param));\n                    }\n                });\n                var fn = new (M.async ? AST_AsyncArrow : AST_Arrow)({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    argnames: argnames,\n                    rest: rest,\n                });\n                var node = from_moz(M.body);\n                if (node instanceof AST_BlockStatement) {\n                    fn.body = normalize_directives(node.body);\n                    fn.value = null;\n                } else {\n                    fn.body = [];\n                    fn.value = node;\n                }\n                return fn;\n            },\n            FunctionDeclaration: function(M) {\n                var ctor;\n                if (M.async) {\n                    ctor = M.generator ? AST_AsyncGeneratorDefun : AST_AsyncDefun;\n                } else {\n                    ctor = M.generator ? AST_GeneratorDefun : AST_Defun;\n                }\n                var argnames = [], rest = null;\n                M.params.forEach(function(param) {\n                    if (param.type == \"RestElement\") {\n                        rest = from_moz(param.argument);\n                    } else {\n                        argnames.push(from_moz(param));\n                    }\n                });\n                return new ctor({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: from_moz(M.id),\n                    argnames: argnames,\n                    rest: rest,\n                    body: normalize_directives(from_moz(M.body).body),\n                });\n            },\n            FunctionExpression: function(M) {\n                var ctor;\n                if (M.async) {\n                    ctor = M.generator ? AST_AsyncGeneratorFunction : AST_AsyncFunction;\n                } else {\n                    ctor = M.generator ? AST_GeneratorFunction : AST_Function;\n                }\n                var argnames = [], rest = null;\n                M.params.forEach(function(param) {\n                    if (param.type == \"RestElement\") {\n                        rest = from_moz(param.argument);\n                    } else {\n                        argnames.push(from_moz(param));\n                    }\n                });\n                return new ctor({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: from_moz(M.id),\n                    argnames: argnames,\n                    rest: rest,\n                    body: normalize_directives(from_moz(M.body).body),\n                });\n            },\n            ClassDeclaration: function(M) {\n                return new AST_DefClass({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: from_moz(M.id),\n                    extends: from_moz(M.superClass),\n                    properties: M.body.body.map(from_moz),\n                });\n            },\n            ClassExpression: function(M) {\n                return new AST_ClassExpression({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: from_moz(M.id),\n                    extends: from_moz(M.superClass),\n                    properties: M.body.body.map(from_moz),\n                });\n            },\n            MethodDefinition: function(M) {\n                var key = M.key, internal = false;\n                if (M.computed) {\n                    key = from_moz(key);\n                } else if (key.type == \"PrivateIdentifier\") {\n                    internal = true;\n                    key = \"#\" + key.name;\n                } else {\n                    key = read_name(key);\n                }\n                var ctor = AST_ClassMethod, value = from_moz(M.value);\n                switch (M.kind) {\n                  case \"get\":\n                    ctor = AST_ClassGetter;\n                    value = new AST_Accessor(value);\n                    break;\n                  case \"set\":\n                    ctor = AST_ClassSetter;\n                    value = new AST_Accessor(value);\n                    break;\n                }\n                return new ctor({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    key: key,\n                    private: internal,\n                    static: M.static,\n                    value: value,\n                });\n            },\n            PropertyDefinition: function(M) {\n                var key = M.key, internal = false;\n                if (M.computed) {\n                    key = from_moz(key);\n                } else if (key.type == \"PrivateIdentifier\") {\n                    internal = true;\n                    key = \"#\" + key.name;\n                } else {\n                    key = read_name(key);\n                }\n                return new AST_ClassField({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    key: key,\n                    private: internal,\n                    static: M.static,\n                    value: from_moz(M.value),\n                });\n            },\n            StaticBlock: function(M) {\n                var start = my_start_token(M);\n                var end = my_end_token(M);\n                return new AST_ClassInit({\n                    start: start,\n                    end: end,\n                    value: new AST_ClassInitBlock({\n                        start: start,\n                        end: end,\n                        body: normalize_directives(M.body.map(from_moz)),\n                    }),\n                });\n            },\n            ForOfStatement: function(M) {\n                return new (M.await ? AST_ForAwaitOf : AST_ForOf)({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    init: from_moz(M.left),\n                    object: from_moz(M.right),\n                    body: from_moz(M.body),\n                });\n            },\n            TryStatement: function(M) {\n                var handlers = M.handlers || [M.handler];\n                if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n                    throw new Error(\"Multiple catch clauses are not supported.\");\n                }\n                return new AST_Try({\n                    start    : my_start_token(M),\n                    end      : my_end_token(M),\n                    body     : from_moz(M.block).body,\n                    bcatch   : from_moz(handlers[0]),\n                    bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null,\n                });\n            },\n            Property: function(M) {\n                var key = M.computed ? from_moz(M.key) : read_name(M.key);\n                var args = {\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    key: key,\n                    value: from_moz(M.value),\n                };\n                if (M.kind == \"init\") return new (M.method ? AST_ObjectMethod : AST_ObjectKeyVal)(args);\n                args.value = new AST_Accessor(args.value);\n                if (M.kind == \"get\") return new AST_ObjectGetter(args);\n                if (M.kind == \"set\") return new AST_ObjectSetter(args);\n            },\n            ArrayExpression: function(M) {\n                return new AST_Array({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    elements: M.elements.map(function(elem) {\n                        return elem === null ? new AST_Hole() : from_moz(elem);\n                    }),\n                });\n            },\n            ArrayPattern: function(M) {\n                var elements = [], rest = null;\n                M.elements.forEach(function(el) {\n                    if (el === null) {\n                        elements.push(new AST_Hole());\n                    } else if (el.type == \"RestElement\") {\n                        rest = from_moz(el.argument);\n                    } else {\n                        elements.push(from_moz(el));\n                    }\n                });\n                return new AST_DestructuredArray({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    elements: elements,\n                    rest: rest,\n                });\n            },\n            ObjectPattern: function(M) {\n                var props = [], rest = null;\n                M.properties.forEach(function(prop) {\n                    if (prop.type == \"RestElement\") {\n                        rest = from_moz(prop.argument);\n                    } else {\n                        props.push(new AST_DestructuredKeyVal(from_moz(prop)));\n                    }\n                });\n                return new AST_DestructuredObject({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    properties: props,\n                    rest: rest,\n                });\n            },\n            MemberExpression: function(M) {\n                return new (M.computed ? AST_Sub : AST_Dot)({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    optional: M.optional,\n                    expression: from_moz(M.object),\n                    property: M.computed ? from_moz(M.property) : M.property.name,\n                });\n            },\n            MetaProperty: function(M) {\n                var expr = from_moz(M.meta);\n                var prop = read_name(M.property);\n                if (expr.name == \"new\" && prop == \"target\") return new AST_NewTarget({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: \"new.target\",\n                });\n                return new AST_Dot({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    expression: expr,\n                    property: prop,\n                });\n            },\n            SwitchCase: function(M) {\n                return new (M.test ? AST_Case : AST_Default)({\n                    start      : my_start_token(M),\n                    end        : my_end_token(M),\n                    expression : from_moz(M.test),\n                    body       : M.consequent.map(from_moz),\n                });\n            },\n            ExportAllDeclaration: function(M) {\n                var start = my_start_token(M);\n                var end = my_end_token(M);\n                return new AST_ExportForeign({\n                    start: start,\n                    end: end,\n                    aliases: [ M.exported ? from_moz_alias(M.exported) : new AST_String({\n                        start: start,\n                        value: \"*\",\n                        end: end,\n                    }) ],\n                    keys: [ new AST_String({\n                        start: start,\n                        value: \"*\",\n                        end: end,\n                    }) ],\n                    path: from_moz(M.source),\n                });\n            },\n            ExportDefaultDeclaration: function(M) {\n                var decl = from_moz(M.declaration);\n                if (!decl.name) switch (decl.CTOR) {\n                  case AST_AsyncDefun:\n                    decl = new AST_AsyncFunction(decl);\n                    break;\n                  case AST_AsyncGeneratorDefun:\n                    decl = new AST_AsyncGeneratorFunction(decl);\n                    break;\n                  case AST_DefClass:\n                    decl = new AST_ClassExpression(decl);\n                    break;\n                  case AST_Defun:\n                    decl = new AST_Function(decl);\n                    break;\n                  case AST_GeneratorDefun:\n                    decl = new AST_GeneratorFunction(decl);\n                    break;\n                }\n                return new AST_ExportDefault({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    body: decl,\n                });\n            },\n            ExportNamedDeclaration: function(M) {\n                if (M.declaration) return new AST_ExportDeclaration({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    body: from_moz(M.declaration),\n                });\n                if (M.source) {\n                    var aliases = [], keys = [];\n                    M.specifiers.forEach(function(prop) {\n                        aliases.push(from_moz_alias(prop.exported));\n                        keys.push(from_moz_alias(prop.local));\n                    });\n                    return new AST_ExportForeign({\n                        start: my_start_token(M),\n                        end: my_end_token(M),\n                        aliases: aliases,\n                        keys: keys,\n                        path: from_moz(M.source),\n                    });\n                }\n                return new AST_ExportReferences({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    properties: M.specifiers.map(function(prop) {\n                        var sym = new AST_SymbolExport(from_moz(prop.local));\n                        sym.alias = from_moz_alias(prop.exported);\n                        return sym;\n                    }),\n                });\n            },\n            ImportDeclaration: function(M) {\n                var start = my_start_token(M);\n                var end = my_end_token(M);\n                var all = null, def = null, props = null;\n                M.specifiers.forEach(function(prop) {\n                    var sym = new AST_SymbolImport(from_moz(prop.local));\n                    switch (prop.type) {\n                      case \"ImportDefaultSpecifier\":\n                        def = sym;\n                        def.key = new AST_String({\n                            start: start,\n                            value: \"\",\n                            end: end,\n                        });\n                        break;\n                      case \"ImportNamespaceSpecifier\":\n                        all = sym;\n                        all.key = new AST_String({\n                            start: start,\n                            value: \"*\",\n                            end: end,\n                        });\n                        break;\n                      default:\n                        sym.key = from_moz_alias(prop.imported);\n                        if (!props) props = [];\n                        props.push(sym);\n                        break;\n                    }\n                });\n                return new AST_Import({\n                    start: start,\n                    end: end,\n                    all: all,\n                    default: def,\n                    properties: props,\n                    path: from_moz(M.source),\n                });\n            },\n            ImportExpression: function(M) {\n                var start = my_start_token(M);\n                var arg = from_moz(M.source);\n                return new AST_Call({\n                    start: start,\n                    end: my_end_token(M),\n                    expression: new AST_SymbolRef({\n                        start: start,\n                        end: arg.start,\n                        name: \"import\",\n                    }),\n                    args: [ arg ],\n                });\n            },\n            VariableDeclaration: function(M) {\n                return new ({\n                    const: AST_Const,\n                    let: AST_Let,\n                }[M.kind] || AST_Var)({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    definitions: M.declarations.map(from_moz),\n                });\n            },\n            Literal: function(M) {\n                var args = {\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                };\n                if (M.bigint) {\n                    args.value = M.bigint.toLowerCase() + \"n\";\n                    return new AST_BigInt(args);\n                }\n                var val = M.value;\n                if (val === null) return new AST_Null(args);\n                var rx = M.regex;\n                if (rx && rx.pattern) {\n                    // RegExpLiteral as per ESTree AST spec\n                    args.value = new RegExp(rx.pattern, rx.flags);\n                    args.value.raw_source = rx.pattern;\n                    return new AST_RegExp(args);\n                } else if (rx) {\n                    // support legacy RegExp\n                    args.value = M.regex && M.raw ? M.raw : val;\n                    return new AST_RegExp(args);\n                }\n                switch (typeof val) {\n                  case \"string\":\n                    args.value = val;\n                    return new AST_String(args);\n                  case \"number\":\n                    if (isNaN(val)) return new AST_NaN(args);\n                    var negate, node;\n                    if (isFinite(val)) {\n                        negate = 1 / val < 0;\n                        args.value = negate ? -val : val;\n                        node = new AST_Number(args);\n                    } else {\n                        negate = val < 0;\n                        node = new AST_Infinity(args);\n                    }\n                    return negate ? new AST_UnaryPrefix({\n                        start: args.start,\n                        end: args.end,\n                        operator: \"-\",\n                        expression: node,\n                    }) : node;\n                  case \"boolean\":\n                    return new (val ? AST_True : AST_False)(args);\n                }\n            },\n            TemplateLiteral: function(M) {\n                return new AST_Template({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    expressions: M.expressions.map(from_moz),\n                    strings: M.quasis.map(function(el) {\n                        return el.value.raw;\n                    }),\n                });\n            },\n            TaggedTemplateExpression: function(M) {\n                var tmpl = from_moz(M.quasi);\n                tmpl.start = my_start_token(M);\n                tmpl.end = my_end_token(M);\n                tmpl.tag = from_moz(M.tag);\n                return tmpl;\n            },\n            Identifier: function(M) {\n                var p, level = FROM_MOZ_STACK.length - 1;\n                do {\n                    p = FROM_MOZ_STACK[--level];\n                } while (p.type == \"ArrayPattern\"\n                    || p.type == \"AssignmentPattern\" && p.left === FROM_MOZ_STACK[level + 1]\n                    || p.type == \"ObjectPattern\"\n                    || p.type == \"Property\" && p.value === FROM_MOZ_STACK[level + 1]\n                    || p.type == \"VariableDeclarator\" && p.id === FROM_MOZ_STACK[level + 1]);\n                var ctor = AST_SymbolRef;\n                switch (p.type) {\n                  case \"ArrowFunctionExpression\":\n                    if (p.body !== FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolFunarg;\n                    break;\n                  case \"BreakStatement\":\n                  case \"ContinueStatement\":\n                    ctor = AST_LabelRef;\n                    break;\n                  case \"CatchClause\":\n                    ctor = AST_SymbolCatch;\n                    break;\n                  case \"ClassDeclaration\":\n                    if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolDefClass;\n                    break;\n                  case \"ClassExpression\":\n                    if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolClass;\n                    break;\n                  case \"FunctionDeclaration\":\n                    ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolDefun : AST_SymbolFunarg;\n                    break;\n                  case \"FunctionExpression\":\n                    ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolLambda : AST_SymbolFunarg;\n                    break;\n                  case \"LabeledStatement\":\n                    ctor = AST_Label;\n                    break;\n                  case \"VariableDeclaration\":\n                    ctor = {\n                        const: AST_SymbolConst,\n                        let: AST_SymbolLet,\n                    }[p.kind] || AST_SymbolVar;\n                    break;\n                }\n                return new ctor({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: M.name,\n                });\n            },\n            Super: function(M) {\n                return new AST_Super({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: \"super\",\n                });\n            },\n            ThisExpression: function(M) {\n                return new AST_This({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: \"this\",\n                });\n            },\n            ParenthesizedExpression: function(M) {\n                var node = from_moz(M.expression);\n                if (!node.start.parens) node.start.parens = [];\n                node.start.parens.push(my_start_token(M));\n                if (!node.end.parens) node.end.parens = [];\n                node.end.parens.push(my_end_token(M));\n                return node;\n            },\n            ChainExpression: function(M) {\n                var node = from_moz(M.expression);\n                node.terminal = true;\n                return node;\n            },\n        };\n\n        MOZ_TO_ME.UpdateExpression =\n        MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n            var prefix = \"prefix\" in M ? M.prefix\n                : M.type == \"UnaryExpression\" ? true : false;\n            return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                operator   : M.operator,\n                expression : from_moz(M.argument)\n            });\n        };\n\n        map(\"EmptyStatement\", AST_EmptyStatement);\n        map(\"ExpressionStatement\", AST_SimpleStatement, \"expression>body\");\n        map(\"BlockStatement\", AST_BlockStatement, \"body@body\");\n        map(\"IfStatement\", AST_If, \"test>condition, consequent>body, alternate>alternative\");\n        map(\"LabeledStatement\", AST_LabeledStatement, \"label>label, body>body\");\n        map(\"BreakStatement\", AST_Break, \"label>label\");\n        map(\"ContinueStatement\", AST_Continue, \"label>label\");\n        map(\"WithStatement\", AST_With, \"object>expression, body>body\");\n        map(\"SwitchStatement\", AST_Switch, \"discriminant>expression, cases@body\");\n        map(\"ReturnStatement\", AST_Return, \"argument>value\");\n        map(\"ThrowStatement\", AST_Throw, \"argument>value\");\n        map(\"WhileStatement\", AST_While, \"test>condition, body>body\");\n        map(\"DoWhileStatement\", AST_Do, \"test>condition, body>body\");\n        map(\"ForStatement\", AST_For, \"init>init, test>condition, update>step, body>body\");\n        map(\"ForInStatement\", AST_ForIn, \"left>init, right>object, body>body\");\n        map(\"DebuggerStatement\", AST_Debugger);\n        map(\"VariableDeclarator\", AST_VarDef, \"id>name, init>value\");\n        map(\"CatchClause\", AST_Catch, \"param>argname, body%body\");\n\n        map(\"BinaryExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n        map(\"LogicalExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n        map(\"AssignmentExpression\", AST_Assign, \"operator=operator, left>left, right>right\");\n        map(\"AssignmentPattern\", AST_DefaultValue, \"left>name, right>value\");\n        map(\"ConditionalExpression\", AST_Conditional, \"test>condition, consequent>consequent, alternate>alternative\");\n        map(\"NewExpression\", AST_New, \"callee>expression, arguments@args, pure=pure\");\n        map(\"CallExpression\", AST_Call, \"callee>expression, arguments@args, optional=optional, pure=pure\");\n        map(\"SequenceExpression\", AST_Sequence, \"expressions@expressions\");\n        map(\"SpreadElement\", AST_Spread, \"argument>expression\");\n        map(\"ObjectExpression\", AST_Object, \"properties@properties\");\n        map(\"AwaitExpression\", AST_Await, \"argument>expression\");\n        map(\"YieldExpression\", AST_Yield, \"argument>expression, delegate=nested\");\n\n        def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n            return to_moz_scope(\"Program\", M);\n        });\n\n        def_to_moz(AST_LambdaDefinition, function To_Moz_FunctionDeclaration(M) {\n            var params = M.argnames.map(to_moz);\n            if (M.rest) params.push({\n                type: \"RestElement\",\n                argument: to_moz(M.rest),\n            });\n            return {\n                type: \"FunctionDeclaration\",\n                id: to_moz(M.name),\n                async: is_async(M),\n                generator: is_generator(M),\n                params: params,\n                body: to_moz_scope(\"BlockStatement\", M),\n            };\n        });\n\n        def_to_moz(AST_Lambda, function To_Moz_FunctionExpression(M) {\n            var params = M.argnames.map(to_moz);\n            if (M.rest) params.push({\n                type: \"RestElement\",\n                argument: to_moz(M.rest),\n            });\n            if (is_arrow(M)) return {\n                type: \"ArrowFunctionExpression\",\n                async: is_async(M),\n                params: params,\n                body: M.value ? to_moz(M.value) : to_moz_scope(\"BlockStatement\", M),\n            };\n            return {\n                type: \"FunctionExpression\",\n                id: to_moz(M.name),\n                async: is_async(M),\n                generator: is_generator(M),\n                params: params,\n                body: to_moz_scope(\"BlockStatement\", M),\n            };\n        });\n\n        def_to_moz(AST_DefClass, function To_Moz_ClassDeclaration(M) {\n            return {\n                type: \"ClassDeclaration\",\n                id: to_moz(M.name),\n                superClass: to_moz(M.extends),\n                body: {\n                    type: \"ClassBody\",\n                    body: M.properties.map(to_moz),\n                },\n            };\n        });\n\n        def_to_moz(AST_ClassExpression, function To_Moz_ClassExpression(M) {\n            return {\n                type: \"ClassExpression\",\n                id: to_moz(M.name),\n                superClass: to_moz(M.extends),\n                body: {\n                    type: \"ClassBody\",\n                    body: M.properties.map(to_moz),\n                },\n            };\n        });\n\n        function To_Moz_MethodDefinition(kind) {\n            return function(M) {\n                var computed = M.key instanceof AST_Node;\n                var key = computed ? to_moz(M.key) : M.private ? {\n                    type: \"PrivateIdentifier\",\n                    name: M.key.slice(1),\n                } : {\n                    type: \"Literal\",\n                    value: M.key,\n                };\n                return {\n                    type: \"MethodDefinition\",\n                    kind: kind,\n                    computed: computed,\n                    key: key,\n                    static: M.static,\n                    value: to_moz(M.value),\n                };\n            };\n        }\n        def_to_moz(AST_ClassGetter, To_Moz_MethodDefinition(\"get\"));\n        def_to_moz(AST_ClassSetter, To_Moz_MethodDefinition(\"set\"));\n        def_to_moz(AST_ClassMethod, To_Moz_MethodDefinition(\"method\"));\n\n        def_to_moz(AST_ClassField, function To_Moz_PropertyDefinition(M) {\n            var computed = M.key instanceof AST_Node;\n            var key = computed ? to_moz(M.key) : M.private ? {\n                type: \"PrivateIdentifier\",\n                name: M.key.slice(1),\n            } : {\n                type: \"Literal\",\n                value: M.key,\n            };\n            return {\n                type: \"PropertyDefinition\",\n                computed: computed,\n                key: key,\n                static: M.static,\n                value: to_moz(M.value),\n            };\n        });\n\n        def_to_moz(AST_ClassInit, function To_Moz_StaticBlock(M) {\n            return to_moz_scope(\"StaticBlock\", M.value);\n        });\n\n        function To_Moz_ForOfStatement(is_await) {\n            return function(M) {\n                return {\n                    type: \"ForOfStatement\",\n                    await: is_await,\n                    left: to_moz(M.init),\n                    right: to_moz(M.object),\n                    body: to_moz(M.body),\n                };\n            };\n        }\n        def_to_moz(AST_ForAwaitOf, To_Moz_ForOfStatement(true));\n        def_to_moz(AST_ForOf, To_Moz_ForOfStatement(false));\n\n        def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n            return {\n                type: \"ExpressionStatement\",\n                expression: set_moz_loc(M, {\n                    type: \"Literal\",\n                    value: M.value,\n                }),\n            };\n        });\n\n        def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n            return {\n                type: \"SwitchCase\",\n                test: to_moz(M.expression),\n                consequent: M.body.map(to_moz),\n            };\n        });\n\n        def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n            return {\n                type: \"TryStatement\",\n                block: to_moz_block(M),\n                handler: to_moz(M.bcatch),\n                guardedHandlers: [],\n                finalizer: to_moz(M.bfinally),\n            };\n        });\n\n        def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n            return {\n                type: \"CatchClause\",\n                param: to_moz(M.argname),\n                guard: null,\n                body: to_moz_block(M),\n            };\n        });\n\n        def_to_moz(AST_ExportDeclaration, function To_Moz_ExportNamedDeclaration_declaration(M) {\n            return {\n                type: \"ExportNamedDeclaration\",\n                declaration: to_moz(M.body),\n            };\n        });\n\n        def_to_moz(AST_ExportDefault, function To_Moz_ExportDefaultDeclaration(M) {\n            return {\n                type: \"ExportDefaultDeclaration\",\n                declaration: to_moz(M.body),\n            };\n        });\n\n        def_to_moz(AST_ExportForeign, function To_Moz_ExportAllDeclaration_ExportNamedDeclaration(M) {\n            if (M.keys[0].value == \"*\") return {\n                type: \"ExportAllDeclaration\",\n                exported: M.aliases[0].value == \"*\" ? null : to_moz_alias(M.aliases[0]),\n                source: to_moz(M.path),\n            };\n            var specifiers = [];\n            for (var i = 0; i < M.aliases.length; i++) {\n                specifiers.push(set_moz_loc({\n                    start: M.keys[i].start,\n                    end: M.aliases[i].end,\n                }, {\n                    type: \"ExportSpecifier\",\n                    local: to_moz_alias(M.keys[i]),\n                    exported: to_moz_alias(M.aliases[i]),\n                }));\n            }\n            return {\n                type: \"ExportNamedDeclaration\",\n                specifiers: specifiers,\n                source: to_moz(M.path),\n            };\n        });\n\n        def_to_moz(AST_ExportReferences, function To_Moz_ExportNamedDeclaration_specifiers(M) {\n            return {\n                type: \"ExportNamedDeclaration\",\n                specifiers: M.properties.map(function(prop) {\n                    return set_moz_loc({\n                        start: prop.start,\n                        end: prop.alias.end,\n                    }, {\n                        type: \"ExportSpecifier\",\n                        local: to_moz(prop),\n                        exported: to_moz_alias(prop.alias),\n                    });\n                }),\n            };\n        });\n\n        def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n            var specifiers = M.properties ? M.properties.map(function(prop) {\n                return set_moz_loc({\n                    start: prop.key.start,\n                    end: prop.end,\n                }, {\n                    type: \"ImportSpecifier\",\n                    local: to_moz(prop),\n                    imported: to_moz_alias(prop.key),\n                });\n            }) : [];\n            if (M.all) specifiers.unshift(set_moz_loc(M.all, {\n                type: \"ImportNamespaceSpecifier\",\n                local: to_moz(M.all),\n            }));\n            if (M.default) specifiers.unshift(set_moz_loc(M.default, {\n                type: \"ImportDefaultSpecifier\",\n                local: to_moz(M.default),\n            }));\n            return {\n                type: \"ImportDeclaration\",\n                specifiers: specifiers,\n                source: to_moz(M.path),\n            };\n        });\n\n        def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {\n            return {\n                type: \"VariableDeclaration\",\n                kind: M.TYPE.toLowerCase(),\n                declarations: M.definitions.map(to_moz),\n            };\n        });\n\n        def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n            var computed = M instanceof AST_Sub;\n            var expr = {\n                type: \"MemberExpression\",\n                object: to_moz(M.expression),\n                computed: computed,\n                optional: M.optional,\n                property: computed ? to_moz(M.property) : {\n                    type: \"Identifier\",\n                    name: M.property,\n                },\n            };\n            return M.terminal ? {\n                type: \"ChainExpression\",\n                expression: expr,\n            } : expr;\n        });\n\n        def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n            return {\n                type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n                operator: M.operator,\n                prefix: M instanceof AST_UnaryPrefix,\n                argument: to_moz(M.expression)\n            };\n        });\n\n        def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n            return {\n                type: M.operator == \"&&\" || M.operator == \"||\" ? \"LogicalExpression\" : \"BinaryExpression\",\n                left: to_moz(M.left),\n                operator: M.operator,\n                right: to_moz(M.right)\n            };\n        });\n\n        def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n            return {\n                type: \"ArrayExpression\",\n                elements: M.elements.map(to_moz),\n            };\n        });\n\n        def_to_moz(AST_DestructuredArray, function To_Moz_ArrayPattern(M) {\n            var elements = M.elements.map(to_moz);\n            if (M.rest) elements.push({\n                type: \"RestElement\",\n                argument: to_moz(M.rest),\n            });\n            return {\n                type: \"ArrayPattern\",\n                elements: elements,\n            };\n        });\n\n        def_to_moz(AST_DestructuredKeyVal, function To_Moz_Property(M) {\n            var computed = M.key instanceof AST_Node;\n            var key = computed ? to_moz(M.key) : {\n                type: \"Literal\",\n                value: M.key,\n            };\n            return {\n                type: \"Property\",\n                kind: \"init\",\n                computed: computed,\n                key: key,\n                value: to_moz(M.value),\n            };\n        });\n\n        def_to_moz(AST_DestructuredObject, function To_Moz_ObjectPattern(M) {\n            var props = M.properties.map(to_moz);\n            if (M.rest) props.push({\n                type: \"RestElement\",\n                argument: to_moz(M.rest),\n            });\n            return {\n                type: \"ObjectPattern\",\n                properties: props,\n            };\n        });\n\n        def_to_moz(AST_ObjectProperty, function To_Moz_Property(M) {\n            var computed = M.key instanceof AST_Node;\n            var key = computed ? to_moz(M.key) : {\n                type: \"Literal\",\n                value: M.key,\n            };\n            var kind;\n            if (M instanceof AST_ObjectKeyVal) {\n                kind = \"init\";\n            } else if (M instanceof AST_ObjectGetter) {\n                kind = \"get\";\n            } else if (M instanceof AST_ObjectSetter) {\n                kind = \"set\";\n            }\n            return {\n                type: \"Property\",\n                kind: kind,\n                computed: computed,\n                method: M instanceof AST_ObjectMethod,\n                key: key,\n                value: to_moz(M.value),\n            };\n        });\n\n        def_to_moz(AST_Symbol, function To_Moz_Identifier(M) {\n            var def = M.definition();\n            return {\n                type: \"Identifier\",\n                name: def && def.mangled_name || M.name,\n            };\n        });\n\n        def_to_moz(AST_Super, function To_Moz_Super() {\n            return { type: \"Super\" };\n        });\n\n        def_to_moz(AST_This, function To_Moz_ThisExpression() {\n            return { type: \"ThisExpression\" };\n        });\n\n        def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n            return {\n                type: \"MetaProperty\",\n                meta: {\n                    type: \"Identifier\",\n                    name: \"new\",\n                },\n                property: {\n                    type: \"Identifier\",\n                    name: \"target\",\n                },\n            };\n        });\n\n        def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n            var flags = M.value.toString().match(/\\/([gimuy]*)$/)[1];\n            var value = \"/\" + M.value.raw_source + \"/\" + flags;\n            return {\n                type: \"Literal\",\n                value: value,\n                raw: value,\n                regex: {\n                    pattern: M.value.raw_source,\n                    flags: flags,\n                },\n            };\n        });\n\n        def_to_moz(AST_BigInt, function To_Moz_BigInt(M) {\n            var value = M.value;\n            return {\n                type: \"Literal\",\n                bigint: value.slice(0, -1),\n                raw: value,\n            };\n        });\n\n        function To_Moz_Literal(M) {\n            var value = M.value;\n            if (typeof value === \"number\" && (value < 0 || (value === 0 && 1 / value < 0))) {\n                return {\n                    type: \"UnaryExpression\",\n                    operator: \"-\",\n                    prefix: true,\n                    argument: {\n                        type: \"Literal\",\n                        value: -value,\n                        raw: M.start.raw,\n                    },\n                };\n            }\n            return {\n                type: \"Literal\",\n                value: value,\n                raw: M.start.raw,\n            };\n        }\n        def_to_moz(AST_Boolean, To_Moz_Literal);\n        def_to_moz(AST_Constant, To_Moz_Literal);\n        def_to_moz(AST_Null, To_Moz_Literal);\n\n        def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n            return {\n                type: \"Identifier\",\n                name: String(M.value),\n            };\n        });\n\n        def_to_moz(AST_Template, function To_Moz_TemplateLiteral_TaggedTemplateExpression(M) {\n            var last = M.strings.length - 1;\n            var tmpl = {\n                type: \"TemplateLiteral\",\n                expressions: M.expressions.map(to_moz),\n                quasis: M.strings.map(function(str, index) {\n                    return {\n                        type: \"TemplateElement\",\n                        tail: index == last,\n                        value: { raw: str },\n                    };\n                }),\n            };\n            if (!M.tag) return tmpl;\n            return {\n                type: \"TaggedTemplateExpression\",\n                tag: to_moz(M.tag),\n                quasi: tmpl,\n            };\n        });\n\n        AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n        AST_Hole.DEFMETHOD(\"to_mozilla_ast\", return_null);\n        AST_Node.DEFMETHOD(\"to_mozilla_ast\", function() {\n            throw new Error(\"Cannot convert AST_\" + this.TYPE);\n        });\n\n        /* -----[ tools ]----- */\n\n        function normalize_directives(body) {\n            for (var i = 0; i < body.length; i++) {\n                var stat = body[i];\n                if (!(stat instanceof AST_SimpleStatement)) break;\n                var node = stat.body;\n                if (!(node instanceof AST_String)) break;\n                if (stat.start.pos !== node.start.pos) break;\n                body[i] = new AST_Directive(node);\n            }\n            return body;\n        }\n\n        function raw_token(moznode) {\n            if (moznode.type == \"Literal\") {\n                return moznode.raw != null ? moznode.raw : moznode.value + \"\";\n            }\n        }\n\n        function my_start_token(moznode) {\n            var loc = moznode.loc, start = loc && loc.start;\n            var range = moznode.range;\n            return new AST_Token({\n                file    : loc && loc.source,\n                line    : start && start.line,\n                col     : start && start.column,\n                pos     : range ? range[0] : moznode.start,\n                endline : start && start.line,\n                endcol  : start && start.column,\n                endpos  : range ? range[0] : moznode.start,\n                raw     : raw_token(moznode),\n            });\n        }\n\n        function my_end_token(moznode) {\n            var loc = moznode.loc, end = loc && loc.end;\n            var range = moznode.range;\n            return new AST_Token({\n                file    : loc && loc.source,\n                line    : end && end.line,\n                col     : end && end.column,\n                pos     : range ? range[1] : moznode.end,\n                endline : end && end.line,\n                endcol  : end && end.column,\n                endpos  : range ? range[1] : moznode.end,\n                raw     : raw_token(moznode),\n            });\n        }\n\n        function read_name(M) {\n            return \"\" + M[M.type == \"Identifier\" ? \"name\" : \"value\"];\n        }\n\n        function map(moztype, mytype, propmap) {\n            var moz_to_me = [\n                \"start: my_start_token(M)\",\n                \"end: my_end_token(M)\",\n            ];\n            var me_to_moz = [\n                \"type: \" + JSON.stringify(moztype),\n            ];\n\n            if (propmap) propmap.split(/\\s*,\\s*/).forEach(function(prop) {\n                var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);\n                if (!m) throw new Error(\"Can't understand property map: \" + prop);\n                var moz = m[1], how = m[2], my = m[3];\n                switch (how) {\n                  case \"@\":\n                    moz_to_me.push(my + \": M.\" + moz + \".map(from_moz)\");\n                    me_to_moz.push(moz + \": M.\" +  my + \".map(to_moz)\");\n                    break;\n                  case \">\":\n                    moz_to_me.push(my + \": from_moz(M.\" + moz + \")\");\n                    me_to_moz.push(moz + \": to_moz(M.\" + my + \")\");\n                    break;\n                  case \"=\":\n                    moz_to_me.push(my + \": M.\" + moz);\n                    me_to_moz.push(moz + \": M.\" + my);\n                    break;\n                  case \"%\":\n                    moz_to_me.push(my + \": from_moz(M.\" + moz + \").body\");\n                    me_to_moz.push(moz + \": to_moz_block(M)\");\n                    break;\n                  default:\n                    throw new Error(\"Can't understand operator in propmap: \" + prop);\n                }\n            });\n\n            MOZ_TO_ME[moztype] = new Function(\"U2\", \"my_start_token\", \"my_end_token\", \"from_moz\", [\n                \"return function From_Moz_\" + moztype + \"(M) {\",\n                \"    return new U2.AST_\" + mytype.TYPE + \"({\",\n                moz_to_me.join(\",\\n\"),\n                \"    });\",\n                \"};\",\n            ].join(\"\\n\"))(exports, my_start_token, my_end_token, from_moz);\n            def_to_moz(mytype, new Function(\"to_moz\", \"to_moz_block\", \"to_moz_scope\", [\n                \"return function To_Moz_\" + moztype + \"(M) {\",\n                \"    return {\",\n                me_to_moz.join(\",\\n\"),\n                \"    };\",\n                \"};\",\n            ].join(\"\\n\"))(to_moz, to_moz_block, to_moz_scope));\n        }\n\n        var FROM_MOZ_STACK = null;\n\n        function from_moz(moz) {\n            FROM_MOZ_STACK.push(moz);\n            var node = null;\n            if (moz) {\n                if (!HOP(MOZ_TO_ME, moz.type)) throw new Error(\"Unsupported type: \" + moz.type);\n                node = MOZ_TO_ME[moz.type](moz);\n            }\n            FROM_MOZ_STACK.pop();\n            return node;\n        }\n\n        function from_moz_alias(moz) {\n            return new AST_String({\n                start: my_start_token(moz),\n                value: read_name(moz),\n                end: my_end_token(moz),\n            });\n        }\n\n        AST_Node.from_mozilla_ast = function(node) {\n            var save_stack = FROM_MOZ_STACK;\n            FROM_MOZ_STACK = [];\n            var ast = from_moz(node);\n            FROM_MOZ_STACK = save_stack;\n            ast.walk(new TreeWalker(function(node) {\n                if (node instanceof AST_LabelRef) {\n                    for (var level = 0, parent; parent = this.parent(level); level++) {\n                        if (parent instanceof AST_Scope) break;\n                        if (parent instanceof AST_LabeledStatement && parent.label.name == node.name) {\n                            node.thedef = parent.label;\n                            break;\n                        }\n                    }\n                    if (!node.thedef) {\n                        var s = node.start;\n                        js_error(\"Undefined label \" + node.name, s.file, s.line, s.col, s.pos);\n                    }\n                }\n            }));\n            return ast;\n        };\n\n        function set_moz_loc(mynode, moznode) {\n            var start = mynode.start;\n            var end = mynode.end;\n            if (start.pos != null && end.endpos != null) {\n                moznode.range = [start.pos, end.endpos];\n            }\n            if (start.line) {\n                moznode.loc = {\n                    start: {line: start.line, column: start.col},\n                    end: end.endline ? {line: end.endline, column: end.endcol} : null,\n                };\n                if (start.file) {\n                    moznode.loc.source = start.file;\n                }\n            }\n            return moznode;\n        }\n\n        function def_to_moz(mytype, handler) {\n            mytype.DEFMETHOD(\"to_mozilla_ast\", function() {\n                return set_moz_loc(this, handler(this));\n            });\n        }\n\n        function to_moz(node) {\n            return node != null ? node.to_mozilla_ast() : null;\n        }\n\n        function to_moz_alias(alias) {\n            return is_identifier_string(alias.value) ? set_moz_loc(alias, {\n                type: \"Identifier\",\n                name: alias.value,\n            }) : to_moz(alias);\n        }\n\n        function to_moz_block(node) {\n            return {\n                type: \"BlockStatement\",\n                body: node.body.map(to_moz),\n            };\n        }\n\n        function to_moz_scope(type, node) {\n            var body = node.body.map(to_moz);\n            if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n                body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n            }\n            return {\n                type: type,\n                body: body,\n            };\n        }\n    })();\n});"]}