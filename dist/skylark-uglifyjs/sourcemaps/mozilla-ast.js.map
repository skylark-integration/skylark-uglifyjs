{"version":3,"sources":["mozilla-ast.js"],"names":["define","m_ast","AST_Accessor","AST_Array","AST_Arrow","AST_Assign","AST_AsyncFunction","AST_AsyncDefun","AST_AsyncArrow","AST_AsyncGeneratorFunction","AST_AsyncGeneratorDefun","AST_Atom","AST_Await","AST_BigInt","AST_Binary","AST_Block","AST_BlockStatement","AST_Boolean","AST_Break","AST_Call","AST_Case","AST_Catch","AST_Chain","AST_Class","AST_ClassStaticBlock","AST_ClassExpression","AST_ClassGetter","AST_ClassInit","AST_ClassProperty","AST_ClassPrivateProperty","AST_ClassSetter","AST_ConciseMethod","AST_Conditional","AST_Const","AST_Constant","AST_Continue","AST_Debugger","AST_Default","AST_DefaultAssign","AST_DefClass","AST_Definitions","AST_Defun","AST_Destructuring","AST_Directive","AST_Do","AST_Dot","AST_DotHash","AST_EmptyStatement","AST_Expansion","AST_Export","AST_ExportDeclaration","AST_False","AST_Finally","AST_For","AST_ForIn","AST_ForOf","AST_Function","AST_Hole","AST_If","AST_Import","AST_ImportMeta","AST_Label","AST_LabeledStatement","AST_LabelRef","AST_Lambda","AST_Let","AST_NameMapping","AST_New","AST_NewTarget","AST_Node","AST_Null","AST_Number","AST_Object","AST_ObjectGetter","AST_ObjectKeyVal","AST_ObjectProperty","AST_ObjectSetter","AST_PrefixedTemplateString","AST_PrivateGetter","AST_PrivateMethod","AST_PrivateSetter","AST_PrivateIn","AST_PropAccess","AST_RegExp","AST_Return","AST_Sequence","AST_SimpleStatement","AST_Statement","AST_String","AST_Sub","AST_Super","AST_Switch","AST_SwitchBranch","AST_Symbol","AST_SymbolCatch","AST_SymbolClass","AST_SymbolClassProperty","AST_SymbolPrivateProperty","AST_SymbolConst","AST_SymbolDefClass","AST_SymbolDefun","AST_SymbolExport","AST_SymbolExportForeign","AST_SymbolFunarg","AST_SymbolImport","AST_SymbolImportForeign","AST_SymbolLambda","AST_SymbolLet","AST_SymbolMethod","AST_SymbolRef","AST_SymbolVar","AST_TemplateSegment","AST_TemplateString","AST_This","AST_Throw","AST_Token","AST_Toplevel","AST_True","AST_Try","AST_TryBlock","AST_Unary","AST_UnaryPostfix","AST_UnaryPrefix","AST_Var","AST_VarDef","AST_While","AST_With","AST_Yield","is_generator","is_arrow","is_async","MOZ_TO_ME","Program","M","start","my_start_token","end","my_end_token","body","normalize_directives","map","from_moz","ArrowFunctionExpression","argnames","rest","params","forEach","param","type","argument","push","fn","async","node","value","FunctionDeclaration","ctor","generator","AST_GeneratorDefun","name","id","FunctionExpression","AST_GeneratorFunction","ClassDeclaration","extends","superClass","properties","ClassExpression","MethodDefinition","key","internal","computed","read_name","AST_ClassMethod","kind","private","static","PropertyDefinition","AST_ClassField","StaticBlock","AST_ClassInitBlock","ForOfStatement","await","AST_ForAwaitOf","init","left","object","right","TryStatement","handlers","handler","length","guardedHandlers","Error","block","bcatch","bfinally","finalizer","Property","args","method","AST_ObjectMethod","ArrayExpression","elements","elem","ArrayPattern","el","AST_DestructuredArray","ObjectPattern","props","prop","AST_DestructuredKeyVal","AST_DestructuredObject","MemberExpression","optional","expression","property","MetaProperty","expr","meta","SwitchCase","test","consequent","ExportAllDeclaration","AST_ExportForeign","aliases","exported","from_moz_alias","keys","path","source","ExportDefaultDeclaration","decl","declaration","CTOR","AST_ExportDefault","ExportNamedDeclaration","specifiers","local","AST_ExportReferences","sym","alias","ImportDeclaration","all","def","imported","default","ImportExpression","arg","VariableDeclaration","const","let","definitions","declarations","Literal","bigint","toLowerCase","val","rx","regex","pattern","RegExp","flags","raw_source","raw","isNaN","AST_NaN","isFinite","negate","AST_Infinity","operator","TemplateLiteral","AST_Template","expressions","strings","quasis","TaggedTemplateExpression","tmpl","quasi","tag","Identifier","p","level","FROM_MOZ_STACK","Super","ThisExpression","ParenthesizedExpression","parens","ChainExpression","terminal","To_Moz_MethodDefinition","to_moz","slice","To_Moz_ForOfStatement","is_await","To_Moz_Literal","prefix","i","stat","pos","raw_token","moznode","loc","range","file","line","col","column","endline","endcol","endpos","moztype","mytype","propmap","moz_to_me","me_to_moz","JSON","stringify","split","m","exec","moz","how","my","Function","TYPE","join","exports","def_to_moz","to_moz_block","to_moz_scope","UpdateExpression","UnaryExpression","AST_DefaultValue","AST_Spread","AST_LambdaDefinition","set_moz_loc","argname","guard","to_moz_alias","unshift","definition","mangled_name","toString","match","String","last","str","index","tail","DEFMETHOD","prototype","to_mozilla_ast","return_null","this","HOP","pop","mynode","is_identifier_string","from_mozilla_ast","save_stack","ast","walk","TreeWalker","parent","AST_Scope","label","thedef","s","js_error"],"mappings":"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","file":"../mozilla-ast.js","sourcesContent":["define([\n    \"./ast\"\n],function(m_ast){\n    /***********************************************************************\n\n      A JavaScript tokenizer / parser / beautifier / compressor.\n      https://github.com/mishoo/UglifyJS\n\n      -------------------------------- (C) ---------------------------------\n\n                               Author: Mihai Bazon\n                             <mihai.bazon@gmail.com>\n                           http://mihai.bazon.net/blog\n\n      Distributed under the BSD license:\n\n        Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n        Redistribution and use in source and binary forms, with or without\n        modification, are permitted provided that the following conditions\n        are met:\n\n            * Redistributions of source code must retain the above\n              copyright notice, this list of conditions and the following\n              disclaimer.\n\n            * Redistributions in binary form must reproduce the above\n              copyright notice, this list of conditions and the following\n              disclaimer in the documentation and/or other materials\n              provided with the distribution.\n\n        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n        EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n        IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n        PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n        LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n        OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n        PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n        PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n        THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n        TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n        THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n        SUCH DAMAGE.\n\n     ***********************************************************************/\n\n    \"use strict\";\n\n    const {\n        AST_Accessor,\n        AST_Array,\n        AST_Arrow,\n        AST_Assign,\n        AST_AsyncFunction,\n        AST_AsyncDefun,\n        AST_AsyncArrow,\n        AST_AsyncGeneratorFunction,\n        AST_AsyncGeneratorDefun,\n        AST_Atom,\n        AST_Await,\n        AST_BigInt,\n        AST_Binary,\n        AST_Block,\n        AST_BlockStatement,\n        AST_Boolean,\n        AST_Break,\n        AST_Call,\n        AST_Case,\n        AST_Catch,\n        AST_Chain,\n        AST_Class,\n        AST_ClassStaticBlock,\n        AST_ClassExpression,\n        AST_ClassGetter,\n        AST_ClassInit,\n        AST_ClassProperty,\n        AST_ClassPrivateProperty,\n        AST_ClassSetter,\n        AST_ConciseMethod,\n        AST_Conditional,\n        AST_Const,\n        AST_Constant,\n        AST_Continue,\n        AST_Debugger,\n        AST_Default,\n        AST_DefaultAssign,\n        AST_DefClass,\n        AST_Definitions,\n        AST_Defun,\n        AST_Destructuring,\n        AST_Directive,\n        AST_Do,\n        AST_Dot,\n        AST_DotHash,\n        AST_EmptyStatement,\n        AST_Expansion,\n        AST_Export,\n        AST_ExportDeclaration,\n        AST_False,\n        AST_Finally,\n        AST_For,\n        AST_ForIn,\n        AST_ForOf,\n        AST_Function,\n        AST_Hole,\n        AST_If,\n        AST_Import,\n        AST_ImportMeta,\n        AST_Label,\n        AST_LabeledStatement,\n        AST_LabelRef,\n        AST_Lambda,\n        AST_Let,\n        AST_NameMapping,\n        AST_New,\n        AST_NewTarget,\n        AST_Node,\n        AST_Null,\n        AST_Number,\n        AST_Object,\n        AST_ObjectGetter,\n        AST_ObjectKeyVal,\n        AST_ObjectProperty,\n        AST_ObjectSetter,\n        AST_PrefixedTemplateString,\n        AST_PrivateGetter,\n        AST_PrivateMethod,\n        AST_PrivateSetter,\n        AST_PrivateIn,\n        AST_PropAccess,\n        AST_RegExp,\n        AST_Return,\n        AST_Sequence,\n        AST_SimpleStatement,\n        AST_Statement,\n        AST_String,\n        AST_Sub,\n        AST_Super,\n        AST_Switch,\n        AST_SwitchBranch,\n        AST_Symbol,\n        AST_SymbolCatch,\n        AST_SymbolClass,\n        AST_SymbolClassProperty,\n        AST_SymbolPrivateProperty,\n        AST_SymbolConst,\n        AST_SymbolDefClass,\n        AST_SymbolDefun,\n        AST_SymbolExport,\n        AST_SymbolExportForeign,\n        AST_SymbolFunarg,\n        AST_SymbolImport,\n        AST_SymbolImportForeign,\n        AST_SymbolLambda,\n        AST_SymbolLet,\n        AST_SymbolMethod,\n        AST_SymbolRef,\n        AST_SymbolVar,\n        AST_TemplateSegment,\n        AST_TemplateString,\n        AST_This,\n        AST_Throw,\n        AST_Token,\n        AST_Toplevel,\n        AST_True,\n        AST_Try,\n        AST_TryBlock,\n        AST_Unary,\n        AST_UnaryPostfix,\n        AST_UnaryPrefix,\n        AST_Var,\n        AST_VarDef,\n        AST_While,\n        AST_With,\n        AST_Yield,\n\n        is_generator,\n        is_arrow,\n        is_async\n    } = m_ast;\n\n    (function() {\n        var MOZ_TO_ME = {\n            Program: function(M) {\n                return new AST_Toplevel({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    body: normalize_directives(M.body.map(from_moz)),\n                });\n            },\n            ArrowFunctionExpression: function(M) {\n                var argnames = [], rest = null;\n                M.params.forEach(function(param) {\n                    if (param.type == \"RestElement\") {\n                        rest = from_moz(param.argument);\n                    } else {\n                        argnames.push(from_moz(param));\n                    }\n                });\n                var fn = new (M.async ? AST_AsyncArrow : AST_Arrow)({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    argnames: argnames,\n                    rest: rest,\n                });\n                var node = from_moz(M.body);\n                if (node instanceof AST_BlockStatement) {\n                    fn.body = normalize_directives(node.body);\n                    fn.value = null;\n                } else {\n                    fn.body = [];\n                    fn.value = node;\n                }\n                return fn;\n            },\n            FunctionDeclaration: function(M) {\n                var ctor;\n                if (M.async) {\n                    ctor = M.generator ? AST_AsyncGeneratorDefun : AST_AsyncDefun;\n                } else {\n                    ctor = M.generator ? AST_GeneratorDefun : AST_Defun;\n                }\n                var argnames = [], rest = null;\n                M.params.forEach(function(param) {\n                    if (param.type == \"RestElement\") {\n                        rest = from_moz(param.argument);\n                    } else {\n                        argnames.push(from_moz(param));\n                    }\n                });\n                return new ctor({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: from_moz(M.id),\n                    argnames: argnames,\n                    rest: rest,\n                    body: normalize_directives(from_moz(M.body).body),\n                });\n            },\n            FunctionExpression: function(M) {\n                var ctor;\n                if (M.async) {\n                    ctor = M.generator ? AST_AsyncGeneratorFunction : AST_AsyncFunction;\n                } else {\n                    ctor = M.generator ? AST_GeneratorFunction : AST_Function;\n                }\n                var argnames = [], rest = null;\n                M.params.forEach(function(param) {\n                    if (param.type == \"RestElement\") {\n                        rest = from_moz(param.argument);\n                    } else {\n                        argnames.push(from_moz(param));\n                    }\n                });\n                return new ctor({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: from_moz(M.id),\n                    argnames: argnames,\n                    rest: rest,\n                    body: normalize_directives(from_moz(M.body).body),\n                });\n            },\n            ClassDeclaration: function(M) {\n                return new AST_DefClass({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: from_moz(M.id),\n                    extends: from_moz(M.superClass),\n                    properties: M.body.body.map(from_moz),\n                });\n            },\n            ClassExpression: function(M) {\n                return new AST_ClassExpression({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: from_moz(M.id),\n                    extends: from_moz(M.superClass),\n                    properties: M.body.body.map(from_moz),\n                });\n            },\n            MethodDefinition: function(M) {\n                var key = M.key, internal = false;\n                if (M.computed) {\n                    key = from_moz(key);\n                } else if (key.type == \"PrivateIdentifier\") {\n                    internal = true;\n                    key = \"#\" + key.name;\n                } else {\n                    key = read_name(key);\n                }\n                var ctor = AST_ClassMethod, value = from_moz(M.value);\n                switch (M.kind) {\n                  case \"get\":\n                    ctor = AST_ClassGetter;\n                    value = new AST_Accessor(value);\n                    break;\n                  case \"set\":\n                    ctor = AST_ClassSetter;\n                    value = new AST_Accessor(value);\n                    break;\n                }\n                return new ctor({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    key: key,\n                    private: internal,\n                    static: M.static,\n                    value: value,\n                });\n            },\n            PropertyDefinition: function(M) {\n                var key = M.key, internal = false;\n                if (M.computed) {\n                    key = from_moz(key);\n                } else if (key.type == \"PrivateIdentifier\") {\n                    internal = true;\n                    key = \"#\" + key.name;\n                } else {\n                    key = read_name(key);\n                }\n                return new AST_ClassField({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    key: key,\n                    private: internal,\n                    static: M.static,\n                    value: from_moz(M.value),\n                });\n            },\n            StaticBlock: function(M) {\n                var start = my_start_token(M);\n                var end = my_end_token(M);\n                return new AST_ClassInit({\n                    start: start,\n                    end: end,\n                    value: new AST_ClassInitBlock({\n                        start: start,\n                        end: end,\n                        body: normalize_directives(M.body.map(from_moz)),\n                    }),\n                });\n            },\n            ForOfStatement: function(M) {\n                return new (M.await ? AST_ForAwaitOf : AST_ForOf)({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    init: from_moz(M.left),\n                    object: from_moz(M.right),\n                    body: from_moz(M.body),\n                });\n            },\n            TryStatement: function(M) {\n                var handlers = M.handlers || [M.handler];\n                if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n                    throw new Error(\"Multiple catch clauses are not supported.\");\n                }\n                return new AST_Try({\n                    start    : my_start_token(M),\n                    end      : my_end_token(M),\n                    body     : from_moz(M.block).body,\n                    bcatch   : from_moz(handlers[0]),\n                    bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null,\n                });\n            },\n            Property: function(M) {\n                var key = M.computed ? from_moz(M.key) : read_name(M.key);\n                var args = {\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    key: key,\n                    value: from_moz(M.value),\n                };\n                if (M.kind == \"init\") return new (M.method ? AST_ObjectMethod : AST_ObjectKeyVal)(args);\n                args.value = new AST_Accessor(args.value);\n                if (M.kind == \"get\") return new AST_ObjectGetter(args);\n                if (M.kind == \"set\") return new AST_ObjectSetter(args);\n            },\n            ArrayExpression: function(M) {\n                return new AST_Array({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    elements: M.elements.map(function(elem) {\n                        return elem === null ? new AST_Hole() : from_moz(elem);\n                    }),\n                });\n            },\n            ArrayPattern: function(M) {\n                var elements = [], rest = null;\n                M.elements.forEach(function(el) {\n                    if (el === null) {\n                        elements.push(new AST_Hole());\n                    } else if (el.type == \"RestElement\") {\n                        rest = from_moz(el.argument);\n                    } else {\n                        elements.push(from_moz(el));\n                    }\n                });\n                return new AST_DestructuredArray({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    elements: elements,\n                    rest: rest,\n                });\n            },\n            ObjectPattern: function(M) {\n                var props = [], rest = null;\n                M.properties.forEach(function(prop) {\n                    if (prop.type == \"RestElement\") {\n                        rest = from_moz(prop.argument);\n                    } else {\n                        props.push(new AST_DestructuredKeyVal(from_moz(prop)));\n                    }\n                });\n                return new AST_DestructuredObject({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    properties: props,\n                    rest: rest,\n                });\n            },\n            MemberExpression: function(M) {\n                return new (M.computed ? AST_Sub : AST_Dot)({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    optional: M.optional,\n                    expression: from_moz(M.object),\n                    property: M.computed ? from_moz(M.property) : M.property.name,\n                });\n            },\n            MetaProperty: function(M) {\n                var expr = from_moz(M.meta);\n                var prop = read_name(M.property);\n                if (expr.name == \"new\" && prop == \"target\") return new AST_NewTarget({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: \"new.target\",\n                });\n                return new AST_Dot({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    expression: expr,\n                    property: prop,\n                });\n            },\n            SwitchCase: function(M) {\n                return new (M.test ? AST_Case : AST_Default)({\n                    start      : my_start_token(M),\n                    end        : my_end_token(M),\n                    expression : from_moz(M.test),\n                    body       : M.consequent.map(from_moz),\n                });\n            },\n            ExportAllDeclaration: function(M) {\n                var start = my_start_token(M);\n                var end = my_end_token(M);\n                return new AST_ExportForeign({\n                    start: start,\n                    end: end,\n                    aliases: [ M.exported ? from_moz_alias(M.exported) : new AST_String({\n                        start: start,\n                        value: \"*\",\n                        end: end,\n                    }) ],\n                    keys: [ new AST_String({\n                        start: start,\n                        value: \"*\",\n                        end: end,\n                    }) ],\n                    path: from_moz(M.source),\n                });\n            },\n            ExportDefaultDeclaration: function(M) {\n                var decl = from_moz(M.declaration);\n                if (!decl.name) switch (decl.CTOR) {\n                  case AST_AsyncDefun:\n                    decl = new AST_AsyncFunction(decl);\n                    break;\n                  case AST_AsyncGeneratorDefun:\n                    decl = new AST_AsyncGeneratorFunction(decl);\n                    break;\n                  case AST_DefClass:\n                    decl = new AST_ClassExpression(decl);\n                    break;\n                  case AST_Defun:\n                    decl = new AST_Function(decl);\n                    break;\n                  case AST_GeneratorDefun:\n                    decl = new AST_GeneratorFunction(decl);\n                    break;\n                }\n                return new AST_ExportDefault({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    body: decl,\n                });\n            },\n            ExportNamedDeclaration: function(M) {\n                if (M.declaration) return new AST_ExportDeclaration({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    body: from_moz(M.declaration),\n                });\n                if (M.source) {\n                    var aliases = [], keys = [];\n                    M.specifiers.forEach(function(prop) {\n                        aliases.push(from_moz_alias(prop.exported));\n                        keys.push(from_moz_alias(prop.local));\n                    });\n                    return new AST_ExportForeign({\n                        start: my_start_token(M),\n                        end: my_end_token(M),\n                        aliases: aliases,\n                        keys: keys,\n                        path: from_moz(M.source),\n                    });\n                }\n                return new AST_ExportReferences({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    properties: M.specifiers.map(function(prop) {\n                        var sym = new AST_SymbolExport(from_moz(prop.local));\n                        sym.alias = from_moz_alias(prop.exported);\n                        return sym;\n                    }),\n                });\n            },\n            ImportDeclaration: function(M) {\n                var start = my_start_token(M);\n                var end = my_end_token(M);\n                var all = null, def = null, props = null;\n                M.specifiers.forEach(function(prop) {\n                    var sym = new AST_SymbolImport(from_moz(prop.local));\n                    switch (prop.type) {\n                      case \"ImportDefaultSpecifier\":\n                        def = sym;\n                        def.key = new AST_String({\n                            start: start,\n                            value: \"\",\n                            end: end,\n                        });\n                        break;\n                      case \"ImportNamespaceSpecifier\":\n                        all = sym;\n                        all.key = new AST_String({\n                            start: start,\n                            value: \"*\",\n                            end: end,\n                        });\n                        break;\n                      default:\n                        sym.key = from_moz_alias(prop.imported);\n                        if (!props) props = [];\n                        props.push(sym);\n                        break;\n                    }\n                });\n                return new AST_Import({\n                    start: start,\n                    end: end,\n                    all: all,\n                    default: def,\n                    properties: props,\n                    path: from_moz(M.source),\n                });\n            },\n            ImportExpression: function(M) {\n                var start = my_start_token(M);\n                var arg = from_moz(M.source);\n                return new AST_Call({\n                    start: start,\n                    end: my_end_token(M),\n                    expression: new AST_SymbolRef({\n                        start: start,\n                        end: arg.start,\n                        name: \"import\",\n                    }),\n                    args: [ arg ],\n                });\n            },\n            VariableDeclaration: function(M) {\n                return new ({\n                    const: AST_Const,\n                    let: AST_Let,\n                }[M.kind] || AST_Var)({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    definitions: M.declarations.map(from_moz),\n                });\n            },\n            Literal: function(M) {\n                var args = {\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                };\n                if (M.bigint) {\n                    args.value = M.bigint.toLowerCase() + \"n\";\n                    return new AST_BigInt(args);\n                }\n                var val = M.value;\n                if (val === null) return new AST_Null(args);\n                var rx = M.regex;\n                if (rx && rx.pattern) {\n                    // RegExpLiteral as per ESTree AST spec\n                    args.value = new RegExp(rx.pattern, rx.flags);\n                    args.value.raw_source = rx.pattern;\n                    return new AST_RegExp(args);\n                } else if (rx) {\n                    // support legacy RegExp\n                    args.value = M.regex && M.raw ? M.raw : val;\n                    return new AST_RegExp(args);\n                }\n                switch (typeof val) {\n                  case \"string\":\n                    args.value = val;\n                    return new AST_String(args);\n                  case \"number\":\n                    if (isNaN(val)) return new AST_NaN(args);\n                    var negate, node;\n                    if (isFinite(val)) {\n                        negate = 1 / val < 0;\n                        args.value = negate ? -val : val;\n                        node = new AST_Number(args);\n                    } else {\n                        negate = val < 0;\n                        node = new AST_Infinity(args);\n                    }\n                    return negate ? new AST_UnaryPrefix({\n                        start: args.start,\n                        end: args.end,\n                        operator: \"-\",\n                        expression: node,\n                    }) : node;\n                  case \"boolean\":\n                    return new (val ? AST_True : AST_False)(args);\n                }\n            },\n            TemplateLiteral: function(M) {\n                return new AST_Template({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    expressions: M.expressions.map(from_moz),\n                    strings: M.quasis.map(function(el) {\n                        return el.value.raw;\n                    }),\n                });\n            },\n            TaggedTemplateExpression: function(M) {\n                var tmpl = from_moz(M.quasi);\n                tmpl.start = my_start_token(M);\n                tmpl.end = my_end_token(M);\n                tmpl.tag = from_moz(M.tag);\n                return tmpl;\n            },\n            Identifier: function(M) {\n                var p, level = FROM_MOZ_STACK.length - 1;\n                do {\n                    p = FROM_MOZ_STACK[--level];\n                } while (p.type == \"ArrayPattern\"\n                    || p.type == \"AssignmentPattern\" && p.left === FROM_MOZ_STACK[level + 1]\n                    || p.type == \"ObjectPattern\"\n                    || p.type == \"Property\" && p.value === FROM_MOZ_STACK[level + 1]\n                    || p.type == \"VariableDeclarator\" && p.id === FROM_MOZ_STACK[level + 1]);\n                var ctor = AST_SymbolRef;\n                switch (p.type) {\n                  case \"ArrowFunctionExpression\":\n                    if (p.body !== FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolFunarg;\n                    break;\n                  case \"BreakStatement\":\n                  case \"ContinueStatement\":\n                    ctor = AST_LabelRef;\n                    break;\n                  case \"CatchClause\":\n                    ctor = AST_SymbolCatch;\n                    break;\n                  case \"ClassDeclaration\":\n                    if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolDefClass;\n                    break;\n                  case \"ClassExpression\":\n                    if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolClass;\n                    break;\n                  case \"FunctionDeclaration\":\n                    ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolDefun : AST_SymbolFunarg;\n                    break;\n                  case \"FunctionExpression\":\n                    ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolLambda : AST_SymbolFunarg;\n                    break;\n                  case \"LabeledStatement\":\n                    ctor = AST_Label;\n                    break;\n                  case \"VariableDeclaration\":\n                    ctor = {\n                        const: AST_SymbolConst,\n                        let: AST_SymbolLet,\n                    }[p.kind] || AST_SymbolVar;\n                    break;\n                }\n                return new ctor({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: M.name,\n                });\n            },\n            Super: function(M) {\n                return new AST_Super({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: \"super\",\n                });\n            },\n            ThisExpression: function(M) {\n                return new AST_This({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: \"this\",\n                });\n            },\n            ParenthesizedExpression: function(M) {\n                var node = from_moz(M.expression);\n                if (!node.start.parens) node.start.parens = [];\n                node.start.parens.push(my_start_token(M));\n                if (!node.end.parens) node.end.parens = [];\n                node.end.parens.push(my_end_token(M));\n                return node;\n            },\n            ChainExpression: function(M) {\n                var node = from_moz(M.expression);\n                node.terminal = true;\n                return node;\n            },\n        };\n\n        MOZ_TO_ME.UpdateExpression =\n        MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n            var prefix = \"prefix\" in M ? M.prefix\n                : M.type == \"UnaryExpression\" ? true : false;\n            return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                operator   : M.operator,\n                expression : from_moz(M.argument)\n            });\n        };\n\n        map(\"EmptyStatement\", AST_EmptyStatement);\n        map(\"ExpressionStatement\", AST_SimpleStatement, \"expression>body\");\n        map(\"BlockStatement\", AST_BlockStatement, \"body@body\");\n        map(\"IfStatement\", AST_If, \"test>condition, consequent>body, alternate>alternative\");\n        map(\"LabeledStatement\", AST_LabeledStatement, \"label>label, body>body\");\n        map(\"BreakStatement\", AST_Break, \"label>label\");\n        map(\"ContinueStatement\", AST_Continue, \"label>label\");\n        map(\"WithStatement\", AST_With, \"object>expression, body>body\");\n        map(\"SwitchStatement\", AST_Switch, \"discriminant>expression, cases@body\");\n        map(\"ReturnStatement\", AST_Return, \"argument>value\");\n        map(\"ThrowStatement\", AST_Throw, \"argument>value\");\n        map(\"WhileStatement\", AST_While, \"test>condition, body>body\");\n        map(\"DoWhileStatement\", AST_Do, \"test>condition, body>body\");\n        map(\"ForStatement\", AST_For, \"init>init, test>condition, update>step, body>body\");\n        map(\"ForInStatement\", AST_ForIn, \"left>init, right>object, body>body\");\n        map(\"DebuggerStatement\", AST_Debugger);\n        map(\"VariableDeclarator\", AST_VarDef, \"id>name, init>value\");\n        map(\"CatchClause\", AST_Catch, \"param>argname, body%body\");\n\n        map(\"BinaryExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n        map(\"LogicalExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n        map(\"AssignmentExpression\", AST_Assign, \"operator=operator, left>left, right>right\");\n        map(\"AssignmentPattern\", AST_DefaultValue, \"left>name, right>value\");\n        map(\"ConditionalExpression\", AST_Conditional, \"test>condition, consequent>consequent, alternate>alternative\");\n        map(\"NewExpression\", AST_New, \"callee>expression, arguments@args, pure=pure\");\n        map(\"CallExpression\", AST_Call, \"callee>expression, arguments@args, optional=optional, pure=pure\");\n        map(\"SequenceExpression\", AST_Sequence, \"expressions@expressions\");\n        map(\"SpreadElement\", AST_Spread, \"argument>expression\");\n        map(\"ObjectExpression\", AST_Object, \"properties@properties\");\n        map(\"AwaitExpression\", AST_Await, \"argument>expression\");\n        map(\"YieldExpression\", AST_Yield, \"argument>expression, delegate=nested\");\n\n        def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n            return to_moz_scope(\"Program\", M);\n        });\n\n        def_to_moz(AST_LambdaDefinition, function To_Moz_FunctionDeclaration(M) {\n            var params = M.argnames.map(to_moz);\n            if (M.rest) params.push({\n                type: \"RestElement\",\n                argument: to_moz(M.rest),\n            });\n            return {\n                type: \"FunctionDeclaration\",\n                id: to_moz(M.name),\n                async: is_async(M),\n                generator: is_generator(M),\n                params: params,\n                body: to_moz_scope(\"BlockStatement\", M),\n            };\n        });\n\n        def_to_moz(AST_Lambda, function To_Moz_FunctionExpression(M) {\n            var params = M.argnames.map(to_moz);\n            if (M.rest) params.push({\n                type: \"RestElement\",\n                argument: to_moz(M.rest),\n            });\n            if (is_arrow(M)) return {\n                type: \"ArrowFunctionExpression\",\n                async: is_async(M),\n                params: params,\n                body: M.value ? to_moz(M.value) : to_moz_scope(\"BlockStatement\", M),\n            };\n            return {\n                type: \"FunctionExpression\",\n                id: to_moz(M.name),\n                async: is_async(M),\n                generator: is_generator(M),\n                params: params,\n                body: to_moz_scope(\"BlockStatement\", M),\n            };\n        });\n\n        def_to_moz(AST_DefClass, function To_Moz_ClassDeclaration(M) {\n            return {\n                type: \"ClassDeclaration\",\n                id: to_moz(M.name),\n                superClass: to_moz(M.extends),\n                body: {\n                    type: \"ClassBody\",\n                    body: M.properties.map(to_moz),\n                },\n            };\n        });\n\n        def_to_moz(AST_ClassExpression, function To_Moz_ClassExpression(M) {\n            return {\n                type: \"ClassExpression\",\n                id: to_moz(M.name),\n                superClass: to_moz(M.extends),\n                body: {\n                    type: \"ClassBody\",\n                    body: M.properties.map(to_moz),\n                },\n            };\n        });\n\n        function To_Moz_MethodDefinition(kind) {\n            return function(M) {\n                var computed = M.key instanceof AST_Node;\n                var key = computed ? to_moz(M.key) : M.private ? {\n                    type: \"PrivateIdentifier\",\n                    name: M.key.slice(1),\n                } : {\n                    type: \"Literal\",\n                    value: M.key,\n                };\n                return {\n                    type: \"MethodDefinition\",\n                    kind: kind,\n                    computed: computed,\n                    key: key,\n                    static: M.static,\n                    value: to_moz(M.value),\n                };\n            };\n        }\n        def_to_moz(AST_ClassGetter, To_Moz_MethodDefinition(\"get\"));\n        def_to_moz(AST_ClassSetter, To_Moz_MethodDefinition(\"set\"));\n        def_to_moz(AST_ClassMethod, To_Moz_MethodDefinition(\"method\"));\n\n        def_to_moz(AST_ClassField, function To_Moz_PropertyDefinition(M) {\n            var computed = M.key instanceof AST_Node;\n            var key = computed ? to_moz(M.key) : M.private ? {\n                type: \"PrivateIdentifier\",\n                name: M.key.slice(1),\n            } : {\n                type: \"Literal\",\n                value: M.key,\n            };\n            return {\n                type: \"PropertyDefinition\",\n                computed: computed,\n                key: key,\n                static: M.static,\n                value: to_moz(M.value),\n            };\n        });\n\n        def_to_moz(AST_ClassInit, function To_Moz_StaticBlock(M) {\n            return to_moz_scope(\"StaticBlock\", M.value);\n        });\n\n        function To_Moz_ForOfStatement(is_await) {\n            return function(M) {\n                return {\n                    type: \"ForOfStatement\",\n                    await: is_await,\n                    left: to_moz(M.init),\n                    right: to_moz(M.object),\n                    body: to_moz(M.body),\n                };\n            };\n        }\n        def_to_moz(AST_ForAwaitOf, To_Moz_ForOfStatement(true));\n        def_to_moz(AST_ForOf, To_Moz_ForOfStatement(false));\n\n        def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n            return {\n                type: \"ExpressionStatement\",\n                expression: set_moz_loc(M, {\n                    type: \"Literal\",\n                    value: M.value,\n                }),\n            };\n        });\n\n        def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n            return {\n                type: \"SwitchCase\",\n                test: to_moz(M.expression),\n                consequent: M.body.map(to_moz),\n            };\n        });\n\n        def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n            return {\n                type: \"TryStatement\",\n                block: to_moz_block(M),\n                handler: to_moz(M.bcatch),\n                guardedHandlers: [],\n                finalizer: to_moz(M.bfinally),\n            };\n        });\n\n        def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n            return {\n                type: \"CatchClause\",\n                param: to_moz(M.argname),\n                guard: null,\n                body: to_moz_block(M),\n            };\n        });\n\n        def_to_moz(AST_ExportDeclaration, function To_Moz_ExportNamedDeclaration_declaration(M) {\n            return {\n                type: \"ExportNamedDeclaration\",\n                declaration: to_moz(M.body),\n            };\n        });\n\n        def_to_moz(AST_ExportDefault, function To_Moz_ExportDefaultDeclaration(M) {\n            return {\n                type: \"ExportDefaultDeclaration\",\n                declaration: to_moz(M.body),\n            };\n        });\n\n        def_to_moz(AST_ExportForeign, function To_Moz_ExportAllDeclaration_ExportNamedDeclaration(M) {\n            if (M.keys[0].value == \"*\") return {\n                type: \"ExportAllDeclaration\",\n                exported: M.aliases[0].value == \"*\" ? null : to_moz_alias(M.aliases[0]),\n                source: to_moz(M.path),\n            };\n            var specifiers = [];\n            for (var i = 0; i < M.aliases.length; i++) {\n                specifiers.push(set_moz_loc({\n                    start: M.keys[i].start,\n                    end: M.aliases[i].end,\n                }, {\n                    type: \"ExportSpecifier\",\n                    local: to_moz_alias(M.keys[i]),\n                    exported: to_moz_alias(M.aliases[i]),\n                }));\n            }\n            return {\n                type: \"ExportNamedDeclaration\",\n                specifiers: specifiers,\n                source: to_moz(M.path),\n            };\n        });\n\n        def_to_moz(AST_ExportReferences, function To_Moz_ExportNamedDeclaration_specifiers(M) {\n            return {\n                type: \"ExportNamedDeclaration\",\n                specifiers: M.properties.map(function(prop) {\n                    return set_moz_loc({\n                        start: prop.start,\n                        end: prop.alias.end,\n                    }, {\n                        type: \"ExportSpecifier\",\n                        local: to_moz(prop),\n                        exported: to_moz_alias(prop.alias),\n                    });\n                }),\n            };\n        });\n\n        def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n            var specifiers = M.properties ? M.properties.map(function(prop) {\n                return set_moz_loc({\n                    start: prop.key.start,\n                    end: prop.end,\n                }, {\n                    type: \"ImportSpecifier\",\n                    local: to_moz(prop),\n                    imported: to_moz_alias(prop.key),\n                });\n            }) : [];\n            if (M.all) specifiers.unshift(set_moz_loc(M.all, {\n                type: \"ImportNamespaceSpecifier\",\n                local: to_moz(M.all),\n            }));\n            if (M.default) specifiers.unshift(set_moz_loc(M.default, {\n                type: \"ImportDefaultSpecifier\",\n                local: to_moz(M.default),\n            }));\n            return {\n                type: \"ImportDeclaration\",\n                specifiers: specifiers,\n                source: to_moz(M.path),\n            };\n        });\n\n        def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {\n            return {\n                type: \"VariableDeclaration\",\n                kind: M.TYPE.toLowerCase(),\n                declarations: M.definitions.map(to_moz),\n            };\n        });\n\n        def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n            var computed = M instanceof AST_Sub;\n            var expr = {\n                type: \"MemberExpression\",\n                object: to_moz(M.expression),\n                computed: computed,\n                optional: M.optional,\n                property: computed ? to_moz(M.property) : {\n                    type: \"Identifier\",\n                    name: M.property,\n                },\n            };\n            return M.terminal ? {\n                type: \"ChainExpression\",\n                expression: expr,\n            } : expr;\n        });\n\n        def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n            return {\n                type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n                operator: M.operator,\n                prefix: M instanceof AST_UnaryPrefix,\n                argument: to_moz(M.expression)\n            };\n        });\n\n        def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n            return {\n                type: M.operator == \"&&\" || M.operator == \"||\" ? \"LogicalExpression\" : \"BinaryExpression\",\n                left: to_moz(M.left),\n                operator: M.operator,\n                right: to_moz(M.right)\n            };\n        });\n\n        def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n            return {\n                type: \"ArrayExpression\",\n                elements: M.elements.map(to_moz),\n            };\n        });\n\n        def_to_moz(AST_DestructuredArray, function To_Moz_ArrayPattern(M) {\n            var elements = M.elements.map(to_moz);\n            if (M.rest) elements.push({\n                type: \"RestElement\",\n                argument: to_moz(M.rest),\n            });\n            return {\n                type: \"ArrayPattern\",\n                elements: elements,\n            };\n        });\n\n        def_to_moz(AST_DestructuredKeyVal, function To_Moz_Property(M) {\n            var computed = M.key instanceof AST_Node;\n            var key = computed ? to_moz(M.key) : {\n                type: \"Literal\",\n                value: M.key,\n            };\n            return {\n                type: \"Property\",\n                kind: \"init\",\n                computed: computed,\n                key: key,\n                value: to_moz(M.value),\n            };\n        });\n\n        def_to_moz(AST_DestructuredObject, function To_Moz_ObjectPattern(M) {\n            var props = M.properties.map(to_moz);\n            if (M.rest) props.push({\n                type: \"RestElement\",\n                argument: to_moz(M.rest),\n            });\n            return {\n                type: \"ObjectPattern\",\n                properties: props,\n            };\n        });\n\n        def_to_moz(AST_ObjectProperty, function To_Moz_Property(M) {\n            var computed = M.key instanceof AST_Node;\n            var key = computed ? to_moz(M.key) : {\n                type: \"Literal\",\n                value: M.key,\n            };\n            var kind;\n            if (M instanceof AST_ObjectKeyVal) {\n                kind = \"init\";\n            } else if (M instanceof AST_ObjectGetter) {\n                kind = \"get\";\n            } else if (M instanceof AST_ObjectSetter) {\n                kind = \"set\";\n            }\n            return {\n                type: \"Property\",\n                kind: kind,\n                computed: computed,\n                method: M instanceof AST_ObjectMethod,\n                key: key,\n                value: to_moz(M.value),\n            };\n        });\n\n        def_to_moz(AST_Symbol, function To_Moz_Identifier(M) {\n            var def = M.definition();\n            return {\n                type: \"Identifier\",\n                name: def && def.mangled_name || M.name,\n            };\n        });\n\n        def_to_moz(AST_Super, function To_Moz_Super() {\n            return { type: \"Super\" };\n        });\n\n        def_to_moz(AST_This, function To_Moz_ThisExpression() {\n            return { type: \"ThisExpression\" };\n        });\n\n        def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n            return {\n                type: \"MetaProperty\",\n                meta: {\n                    type: \"Identifier\",\n                    name: \"new\",\n                },\n                property: {\n                    type: \"Identifier\",\n                    name: \"target\",\n                },\n            };\n        });\n\n        def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n            var flags = M.value.toString().match(/\\/([gimuy]*)$/)[1];\n            var value = \"/\" + M.value.raw_source + \"/\" + flags;\n            return {\n                type: \"Literal\",\n                value: value,\n                raw: value,\n                regex: {\n                    pattern: M.value.raw_source,\n                    flags: flags,\n                },\n            };\n        });\n\n        def_to_moz(AST_BigInt, function To_Moz_BigInt(M) {\n            var value = M.value;\n            return {\n                type: \"Literal\",\n                bigint: value.slice(0, -1),\n                raw: value,\n            };\n        });\n\n        function To_Moz_Literal(M) {\n            var value = M.value;\n            if (typeof value === \"number\" && (value < 0 || (value === 0 && 1 / value < 0))) {\n                return {\n                    type: \"UnaryExpression\",\n                    operator: \"-\",\n                    prefix: true,\n                    argument: {\n                        type: \"Literal\",\n                        value: -value,\n                        raw: M.start.raw,\n                    },\n                };\n            }\n            return {\n                type: \"Literal\",\n                value: value,\n                raw: M.start.raw,\n            };\n        }\n        def_to_moz(AST_Boolean, To_Moz_Literal);\n        def_to_moz(AST_Constant, To_Moz_Literal);\n        def_to_moz(AST_Null, To_Moz_Literal);\n\n        def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n            return {\n                type: \"Identifier\",\n                name: String(M.value),\n            };\n        });\n\n        def_to_moz(AST_Template, function To_Moz_TemplateLiteral_TaggedTemplateExpression(M) {\n            var last = M.strings.length - 1;\n            var tmpl = {\n                type: \"TemplateLiteral\",\n                expressions: M.expressions.map(to_moz),\n                quasis: M.strings.map(function(str, index) {\n                    return {\n                        type: \"TemplateElement\",\n                        tail: index == last,\n                        value: { raw: str },\n                    };\n                }),\n            };\n            if (!M.tag) return tmpl;\n            return {\n                type: \"TaggedTemplateExpression\",\n                tag: to_moz(M.tag),\n                quasi: tmpl,\n            };\n        });\n\n        AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n        AST_Hole.DEFMETHOD(\"to_mozilla_ast\", return_null);\n        AST_Node.DEFMETHOD(\"to_mozilla_ast\", function() {\n            throw new Error(\"Cannot convert AST_\" + this.TYPE);\n        });\n\n        /* -----[ tools ]----- */\n\n        function normalize_directives(body) {\n            for (var i = 0; i < body.length; i++) {\n                var stat = body[i];\n                if (!(stat instanceof AST_SimpleStatement)) break;\n                var node = stat.body;\n                if (!(node instanceof AST_String)) break;\n                if (stat.start.pos !== node.start.pos) break;\n                body[i] = new AST_Directive(node);\n            }\n            return body;\n        }\n\n        function raw_token(moznode) {\n            if (moznode.type == \"Literal\") {\n                return moznode.raw != null ? moznode.raw : moznode.value + \"\";\n            }\n        }\n\n        function my_start_token(moznode) {\n            var loc = moznode.loc, start = loc && loc.start;\n            var range = moznode.range;\n            return new AST_Token({\n                file    : loc && loc.source,\n                line    : start && start.line,\n                col     : start && start.column,\n                pos     : range ? range[0] : moznode.start,\n                endline : start && start.line,\n                endcol  : start && start.column,\n                endpos  : range ? range[0] : moznode.start,\n                raw     : raw_token(moznode),\n            });\n        }\n\n        function my_end_token(moznode) {\n            var loc = moznode.loc, end = loc && loc.end;\n            var range = moznode.range;\n            return new AST_Token({\n                file    : loc && loc.source,\n                line    : end && end.line,\n                col     : end && end.column,\n                pos     : range ? range[1] : moznode.end,\n                endline : end && end.line,\n                endcol  : end && end.column,\n                endpos  : range ? range[1] : moznode.end,\n                raw     : raw_token(moznode),\n            });\n        }\n\n        function read_name(M) {\n            return \"\" + M[M.type == \"Identifier\" ? \"name\" : \"value\"];\n        }\n\n        function map(moztype, mytype, propmap) {\n            var moz_to_me = [\n                \"start: my_start_token(M)\",\n                \"end: my_end_token(M)\",\n            ];\n            var me_to_moz = [\n                \"type: \" + JSON.stringify(moztype),\n            ];\n\n            if (propmap) propmap.split(/\\s*,\\s*/).forEach(function(prop) {\n                var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);\n                if (!m) throw new Error(\"Can't understand property map: \" + prop);\n                var moz = m[1], how = m[2], my = m[3];\n                switch (how) {\n                  case \"@\":\n                    moz_to_me.push(my + \": M.\" + moz + \".map(from_moz)\");\n                    me_to_moz.push(moz + \": M.\" +  my + \".map(to_moz)\");\n                    break;\n                  case \">\":\n                    moz_to_me.push(my + \": from_moz(M.\" + moz + \")\");\n                    me_to_moz.push(moz + \": to_moz(M.\" + my + \")\");\n                    break;\n                  case \"=\":\n                    moz_to_me.push(my + \": M.\" + moz);\n                    me_to_moz.push(moz + \": M.\" + my);\n                    break;\n                  case \"%\":\n                    moz_to_me.push(my + \": from_moz(M.\" + moz + \").body\");\n                    me_to_moz.push(moz + \": to_moz_block(M)\");\n                    break;\n                  default:\n                    throw new Error(\"Can't understand operator in propmap: \" + prop);\n                }\n            });\n\n            MOZ_TO_ME[moztype] = new Function(\"U2\", \"my_start_token\", \"my_end_token\", \"from_moz\", [\n                \"return function From_Moz_\" + moztype + \"(M) {\",\n                \"    return new U2.AST_\" + mytype.TYPE + \"({\",\n                moz_to_me.join(\",\\n\"),\n                \"    });\",\n                \"};\",\n            ].join(\"\\n\"))(exports, my_start_token, my_end_token, from_moz);\n            def_to_moz(mytype, new Function(\"to_moz\", \"to_moz_block\", \"to_moz_scope\", [\n                \"return function To_Moz_\" + moztype + \"(M) {\",\n                \"    return {\",\n                me_to_moz.join(\",\\n\"),\n                \"    };\",\n                \"};\",\n            ].join(\"\\n\"))(to_moz, to_moz_block, to_moz_scope));\n        }\n\n        var FROM_MOZ_STACK = null;\n\n        function from_moz(moz) {\n            FROM_MOZ_STACK.push(moz);\n            var node = null;\n            if (moz) {\n                if (!HOP(MOZ_TO_ME, moz.type)) throw new Error(\"Unsupported type: \" + moz.type);\n                node = MOZ_TO_ME[moz.type](moz);\n            }\n            FROM_MOZ_STACK.pop();\n            return node;\n        }\n\n        function from_moz_alias(moz) {\n            return new AST_String({\n                start: my_start_token(moz),\n                value: read_name(moz),\n                end: my_end_token(moz),\n            });\n        }\n\n        AST_Node.from_mozilla_ast = function(node) {\n            var save_stack = FROM_MOZ_STACK;\n            FROM_MOZ_STACK = [];\n            var ast = from_moz(node);\n            FROM_MOZ_STACK = save_stack;\n            ast.walk(new TreeWalker(function(node) {\n                if (node instanceof AST_LabelRef) {\n                    for (var level = 0, parent; parent = this.parent(level); level++) {\n                        if (parent instanceof AST_Scope) break;\n                        if (parent instanceof AST_LabeledStatement && parent.label.name == node.name) {\n                            node.thedef = parent.label;\n                            break;\n                        }\n                    }\n                    if (!node.thedef) {\n                        var s = node.start;\n                        js_error(\"Undefined label \" + node.name, s.file, s.line, s.col, s.pos);\n                    }\n                }\n            }));\n            return ast;\n        };\n\n        function set_moz_loc(mynode, moznode) {\n            var start = mynode.start;\n            var end = mynode.end;\n            if (start.pos != null && end.endpos != null) {\n                moznode.range = [start.pos, end.endpos];\n            }\n            if (start.line) {\n                moznode.loc = {\n                    start: {line: start.line, column: start.col},\n                    end: end.endline ? {line: end.endline, column: end.endcol} : null,\n                };\n                if (start.file) {\n                    moznode.loc.source = start.file;\n                }\n            }\n            return moznode;\n        }\n\n        function def_to_moz(mytype, handler) {\n            mytype.DEFMETHOD(\"to_mozilla_ast\", function() {\n                return set_moz_loc(this, handler(this));\n            });\n        }\n\n        function to_moz(node) {\n            return node != null ? node.to_mozilla_ast() : null;\n        }\n\n        function to_moz_alias(alias) {\n            return is_identifier_string(alias.value) ? set_moz_loc(alias, {\n                type: \"Identifier\",\n                name: alias.value,\n            }) : to_moz(alias);\n        }\n\n        function to_moz_block(node) {\n            return {\n                type: \"BlockStatement\",\n                body: node.body.map(to_moz),\n            };\n        }\n\n        function to_moz_scope(type, node) {\n            var body = node.body.map(to_moz);\n            if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n                body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n            }\n            return {\n                type: type,\n                body: body,\n            };\n        }\n    })();\n});"]}