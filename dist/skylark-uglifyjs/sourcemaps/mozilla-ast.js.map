{"version":3,"sources":["mozilla-ast.js"],"names":["define","m_ast","AST_Accessor","AST_Array","AST_Arrow","AST_Assign","AST_Atom","AST_Await","AST_BigInt","AST_Binary","AST_Block","AST_BlockStatement","AST_Boolean","AST_Break","AST_Call","AST_Case","AST_Catch","AST_Chain","AST_Class","AST_ClassStaticBlock","AST_ClassExpression","AST_ClassProperty","AST_ClassPrivateProperty","AST_ConciseMethod","AST_Conditional","AST_Const","AST_Constant","AST_Continue","AST_Debugger","AST_Default","AST_DefaultAssign","AST_DefClass","AST_Definitions","AST_Defun","AST_Destructuring","AST_Directive","AST_Do","AST_Dot","AST_DotHash","AST_EmptyStatement","AST_Expansion","AST_Export","AST_ExportDeclaration","AST_False","AST_Finally","AST_For","AST_ForIn","AST_ForOf","AST_Function","AST_Hole","AST_If","AST_Import","AST_ImportMeta","AST_Label","AST_LabeledStatement","AST_LabelRef","AST_Lambda","AST_Let","AST_NameMapping","AST_New","AST_NewTarget","AST_Node","AST_Null","AST_Number","AST_Object","AST_ObjectGetter","AST_ObjectKeyVal","AST_ObjectProperty","AST_ObjectSetter","AST_PrefixedTemplateString","AST_PrivateGetter","AST_PrivateMethod","AST_PrivateSetter","AST_PrivateIn","AST_PropAccess","AST_RegExp","AST_Return","AST_Sequence","AST_SimpleStatement","AST_Statement","AST_String","AST_Sub","AST_Super","AST_Switch","AST_SwitchBranch","AST_Symbol","AST_SymbolCatch","AST_SymbolClass","AST_SymbolClassProperty","AST_SymbolPrivateProperty","AST_SymbolConst","AST_SymbolDefClass","AST_SymbolDefun","AST_SymbolExport","AST_SymbolExportForeign","AST_SymbolFunarg","AST_SymbolImport","AST_SymbolImportForeign","AST_SymbolLambda","AST_SymbolLet","AST_SymbolMethod","AST_SymbolRef","AST_SymbolVar","AST_TemplateSegment","AST_TemplateString","AST_This","AST_Throw","AST_Token","AST_Toplevel","AST_True","AST_Try","AST_TryBlock","AST_Unary","AST_UnaryPostfix","AST_UnaryPrefix","AST_Var","AST_VarDef","AST_While","AST_With","AST_Yield","is_generator","MOZ_TO_ME","Program","M","start","my_start_token","end","my_end_token","body","normalize_directives","map","from_moz","ArrowFunctionExpression","argnames","rest","params","forEach","param","type","argument","push","fn","async","AST_AsyncArrow","node","value","FunctionDeclaration","ctor","generator","AST_AsyncGeneratorDefun","AST_AsyncDefun","AST_GeneratorDefun","name","id","FunctionExpression","AST_AsyncGeneratorFunction","AST_AsyncFunction","AST_GeneratorFunction","ClassDeclaration","extends","superClass","properties","ClassExpression","MethodDefinition","key","internal","computed","read_name","AST_ClassMethod","kind","AST_ClassGetter","AST_ClassSetter","private","static","PropertyDefinition","AST_ClassField","StaticBlock","AST_ClassInit","AST_ClassInitBlock","ForOfStatement","await","AST_ForAwaitOf","init","left","object","right","TryStatement","handlers","handler","length","guardedHandlers","Error","block","bcatch","bfinally","finalizer","Property","args","method","AST_ObjectMethod","ArrayExpression","elements","elem","ArrayPattern","el","AST_DestructuredArray","ObjectPattern","props","prop","AST_DestructuredKeyVal","AST_DestructuredObject","MemberExpression","optional","expression","property","MetaProperty","expr","meta","SwitchCase","test","consequent","ExportAllDeclaration","AST_ExportForeign","aliases","exported","from_moz_alias","keys","path","source","ExportDefaultDeclaration","decl","declaration","CTOR","AST_ExportDefault","ExportNamedDeclaration","specifiers","local","AST_ExportReferences","sym","alias","ImportDeclaration","all","def","imported","default","ImportExpression","arg","VariableDeclaration","const","let","definitions","declarations","Literal","bigint","toLowerCase","val","rx","regex","pattern","RegExp","flags","raw_source","raw","isNaN","AST_NaN","isFinite","negate","AST_Infinity","operator","TemplateLiteral","AST_Template","expressions","strings","quasis","TaggedTemplateExpression","tmpl","quasi","tag","Identifier","p","level","FROM_MOZ_STACK","Super","ThisExpression","ParenthesizedExpression","parens","ChainExpression","terminal","To_Moz_MethodDefinition","to_moz","slice","To_Moz_ForOfStatement","is_await","To_Moz_Literal","prefix","i","stat","pos","raw_token","moznode","loc","range","file","line","col","column","endline","endcol","endpos","moztype","mytype","propmap","moz_to_me","me_to_moz","JSON","stringify","split","m","exec","moz","how","my","Function","TYPE","join","exports","def_to_moz","to_moz_block","to_moz_scope","UpdateExpression","UnaryExpression","AST_DefaultValue","AST_Spread","AST_LambdaDefinition","is_async","is_arrow","set_moz_loc","argname","guard","to_moz_alias","unshift","definition","mangled_name","toString","match","String","last","str","index","tail","DEFMETHOD","prototype","to_mozilla_ast","return_null","this","HOP","pop","mynode","is_identifier_string","from_mozilla_ast","save_stack","ast","walk","TreeWalker","parent","AST_Scope","label","thedef","s","js_error"],"mappings":";;;;;;;AAAAA,QACI,SACF,SAASC,GA4CP,aAEA,MAAMC,aACFA,EAAYC,UACZA,EAASC,UACTA,EAASC,WACTA,EAAUC,SACVA,EAAQC,UACRA,EAASC,WACTA,EAAUC,WACVA,EAAUC,UACVA,EAASC,mBACTA,EAAkBC,YAClBA,EAAWC,UACXA,EAASC,SACTA,EAAQC,SACRA,EAAQC,UACRA,EAASC,UACTA,EAASC,UACTA,EAASC,qBACTA,EAAoBC,oBACpBA,EAAmBC,kBACnBA,EAAiBC,yBACjBA,EAAwBC,kBACxBA,EAAiBC,gBACjBA,EAAeC,UACfA,EAASC,aACTA,EAAYC,aACZA,EAAYC,aACZA,EAAYC,YACZA,EAAWC,kBACXA,EAAiBC,aACjBA,EAAYC,gBACZA,EAAeC,UACfA,EAASC,kBACTA,EAAiBC,cACjBA,EAAaC,OACbA,EAAMC,QACNA,EAAOC,YACPA,EAAWC,mBACXA,EAAkBC,cAClBA,EAAaC,WACbA,EAAUC,sBACVA,EAAqBC,UACrBA,EAASC,YACTA,EAAWC,QACXA,EAAOC,UACPA,EAASC,UACTA,EAASC,aACTA,EAAYC,SACZA,EAAQC,OACRA,EAAMC,WACNA,EAAUC,eACVA,EAAcC,UACdA,EAASC,qBACTA,EAAoBC,aACpBA,GAAYC,WACZA,GAAUC,QACVA,GAAOC,gBACPA,GAAeC,QACfA,GAAOC,cACPA,GAAaC,SACbA,GAAQC,SACRA,GAAQC,WACRA,GAAUC,WACVA,GAAUC,iBACVA,GAAgBC,iBAChBA,GAAgBC,mBAChBA,GAAkBC,iBAClBA,GAAgBC,2BAChBA,GAA0BC,kBAC1BA,GAAiBC,kBACjBA,GAAiBC,kBACjBA,GAAiBC,cACjBA,GAAaC,eACbA,GAAcC,WACdA,GAAUC,WACVA,GAAUC,aACVA,GAAYC,oBACZA,GAAmBC,cACnBA,GAAaC,WACbA,GAAUC,QACVA,GAAOC,UACPA,GAASC,WACTA,GAAUC,iBACVA,GAAgBC,WAChBA,GAAUC,gBACVA,GAAeC,gBACfA,GAAeC,wBACfA,GAAuBC,0BACvBA,GAAyBC,gBACzBA,GAAeC,mBACfA,GAAkBC,gBAClBA,GAAeC,iBACfA,GAAgBC,wBAChBA,GAAuBC,iBACvBA,GAAgBC,iBAChBA,GAAgBC,wBAChBA,GAAuBC,iBACvBA,GAAgBC,cAChBA,GAAaC,iBACbA,GAAgBC,cAChBA,GAAaC,cACbA,GAAaC,oBACbA,GAAmBC,mBACnBA,GAAkBC,SAClBA,GAAQC,UACRA,GAASC,UACTA,GAASC,aACTA,GAAYC,SACZA,GAAQC,QACRA,GAAOC,aACPA,GAAYC,UACZA,GAASC,iBACTA,GAAgBC,gBAChBA,GAAeC,QACfA,GAAOC,WACPA,GAAUC,UACVA,GAASC,SACTA,GAAQC,UACRA,GAASC,aAETA,IACAvH,GAEJ,WACI,IAAIwH,GACAC,QAAS,SAASC,GACd,OAAO,IAAIf,IACPgB,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClBK,KAAMC,EAAqBN,EAAEK,KAAKE,IAAIC,OAG9CC,wBAAyB,SAAST,GAC9B,IAAIU,KAAeC,EAAO,KAC1BX,EAAEY,OAAOC,QAAQ,SAASC,GACJ,eAAdA,EAAMC,KACNJ,EAAOH,EAASM,EAAME,UAEtBN,EAASO,KAAKT,EAASM,MAG/B,IAAII,EAAK,IAAKlB,EAAEmB,MAAQC,eAAiB3I,IACrCwH,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClBU,SAAUA,EACVC,KAAMA,IAENU,EAAOb,EAASR,EAAEK,MAQtB,OAPIgB,aAAgBrI,GAChBkI,EAAGb,KAAOC,EAAqBe,EAAKhB,MACpCa,EAAGI,MAAQ,OAEXJ,EAAGb,QACHa,EAAGI,MAAQD,GAERH,GAEXK,oBAAqB,SAASvB,GAC1B,IAAIwB,EAEAA,EADAxB,EAAEmB,MACKnB,EAAEyB,UAAYC,wBAA0BC,eAExC3B,EAAEyB,UAAYG,mBAAqBtH,EAE9C,IAAIoG,KAAeC,EAAO,KAQ1B,OAPAX,EAAEY,OAAOC,QAAQ,SAASC,GACJ,eAAdA,EAAMC,KACNJ,EAAOH,EAASM,EAAME,UAEtBN,EAASO,KAAKT,EAASM,MAGxB,IAAIU,GACPvB,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClB6B,KAAMrB,EAASR,EAAE8B,IACjBpB,SAAUA,EACVC,KAAMA,EACNN,KAAMC,EAAqBE,EAASR,EAAEK,MAAMA,SAGpD0B,mBAAoB,SAAS/B,GACzB,IAAIwB,EAEAA,EADAxB,EAAEmB,MACKnB,EAAEyB,UAAYO,2BAA6BC,kBAE3CjC,EAAEyB,UAAYS,sBAAwB7G,EAEjD,IAAIqF,KAAeC,EAAO,KAQ1B,OAPAX,EAAEY,OAAOC,QAAQ,SAASC,GACJ,eAAdA,EAAMC,KACNJ,EAAOH,EAASM,EAAME,UAEtBN,EAASO,KAAKT,EAASM,MAGxB,IAAIU,GACPvB,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClB6B,KAAMrB,EAASR,EAAE8B,IACjBpB,SAAUA,EACVC,KAAMA,EACNN,KAAMC,EAAqBE,EAASR,EAAEK,MAAMA,SAGpD8B,iBAAkB,SAASnC,GACvB,OAAO,IAAI5F,GACP6F,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClB6B,KAAMrB,EAASR,EAAE8B,IACjBM,QAAS5B,EAASR,EAAEqC,YACpBC,WAAYtC,EAAEK,KAAKA,KAAKE,IAAIC,MAGpC+B,gBAAiB,SAASvC,GACtB,OAAO,IAAIvG,GACPwG,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClB6B,KAAMrB,EAASR,EAAE8B,IACjBM,QAAS5B,EAASR,EAAEqC,YACpBC,WAAYtC,EAAEK,KAAKA,KAAKE,IAAIC,MAGpCgC,iBAAkB,SAASxC,GACvB,IAAIyC,EAAMzC,EAAEyC,IAAKC,GAAW,EACxB1C,EAAE2C,SACFF,EAAMjC,EAASiC,GACI,qBAAZA,EAAI1B,MACX2B,GAAW,EACXD,EAAM,IAAMA,EAAIZ,MAEhBY,EAAMG,EAAUH,GAEpB,IAAIjB,EAAOqB,gBAAiBvB,EAAQd,EAASR,EAAEsB,OAC/C,OAAQtB,EAAE8C,MACR,IAAK,MACHtB,EAAOuB,gBACPzB,EAAQ,IAAI/I,EAAa+I,GACzB,MACF,IAAK,MACHE,EAAOwB,gBACP1B,EAAQ,IAAI/I,EAAa+I,GAG7B,OAAO,IAAIE,GACPvB,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClByC,IAAKA,EACLQ,QAASP,EACTQ,OAAQlD,EAAEkD,OACV5B,MAAOA,KAGf6B,mBAAoB,SAASnD,GACzB,IAAIyC,EAAMzC,EAAEyC,IAAKC,GAAW,EAS5B,OARI1C,EAAE2C,SACFF,EAAMjC,EAASiC,GACI,qBAAZA,EAAI1B,MACX2B,GAAW,EACXD,EAAM,IAAMA,EAAIZ,MAEhBY,EAAMG,EAAUH,GAEb,IAAIW,gBACPnD,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClByC,IAAKA,EACLQ,QAASP,EACTQ,OAAQlD,EAAEkD,OACV5B,MAAOd,EAASR,EAAEsB,UAG1B+B,YAAa,SAASrD,GAClB,IAAIC,EAAQC,EAAeF,GACvBG,EAAMC,EAAaJ,GACvB,OAAO,IAAIsD,eACPrD,MAAOA,EACPE,IAAKA,EACLmB,MAAO,IAAIiC,oBACPtD,MAAOA,EACPE,IAAKA,EACLE,KAAMC,EAAqBN,EAAEK,KAAKE,IAAIC,SAIlDgD,eAAgB,SAASxD,GACrB,OAAO,IAAKA,EAAEyD,MAAQC,eAAiBtI,IACnC6E,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClB2D,KAAMnD,EAASR,EAAE4D,MACjBC,OAAQrD,EAASR,EAAE8D,OACnBzD,KAAMG,EAASR,EAAEK,SAGzB0D,aAAc,SAAS/D,GACnB,IAAIgE,EAAWhE,EAAEgE,WAAahE,EAAEiE,SAChC,GAAID,EAASE,OAAS,GAAKlE,EAAEmE,iBAAmBnE,EAAEmE,gBAAgBD,OAC9D,MAAM,IAAIE,MAAM,6CAEpB,OAAO,IAAIjF,IACPc,MAAWC,EAAeF,GAC1BG,IAAWC,EAAaJ,GACxBK,KAAWG,EAASR,EAAEqE,OAAOhE,KAC7BiE,OAAW9D,EAASwD,EAAS,IAC7BO,SAAWvE,EAAEwE,UAAY,IAAIvJ,EAAYuF,EAASR,EAAEwE,YAAc,QAG1EC,SAAU,SAASzE,GACf,IAAIyC,EAAMzC,EAAE2C,SAAWnC,EAASR,EAAEyC,KAAOG,EAAU5C,EAAEyC,KACjDiC,GACAzE,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClByC,IAAKA,EACLnB,MAAOd,EAASR,EAAEsB,QAEtB,MAAc,QAAVtB,EAAE8C,KAAuB,IAAK9C,EAAE2E,OAASC,iBAAmBrI,IAAkBmI,IAClFA,EAAKpD,MAAQ,IAAI/I,EAAamM,EAAKpD,OACrB,OAAVtB,EAAE8C,KAAsB,IAAIxG,GAAiBoI,GACnC,OAAV1E,EAAE8C,KAAsB,IAAIrG,GAAiBiI,QAAjD,IAEJG,gBAAiB,SAAS7E,GACtB,OAAO,IAAIxH,GACPyH,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClB8E,SAAU9E,EAAE8E,SAASvE,IAAI,SAASwE,GAC9B,OAAgB,OAATA,EAAgB,IAAIzJ,EAAakF,EAASuE,QAI7DC,aAAc,SAAShF,GACnB,IAAI8E,KAAenE,EAAO,KAU1B,OATAX,EAAE8E,SAASjE,QAAQ,SAASoE,GACb,OAAPA,EACAH,EAAS7D,KAAK,IAAI3F,GACA,eAAX2J,EAAGlE,KACVJ,EAAOH,EAASyE,EAAGjE,UAEnB8D,EAAS7D,KAAKT,EAASyE,MAGxB,IAAIC,uBACPjF,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClB8E,SAAUA,EACVnE,KAAMA,KAGdwE,cAAe,SAASnF,GACpB,IAAIoF,KAAYzE,EAAO,KAQvB,OAPAX,EAAEsC,WAAWzB,QAAQ,SAASwE,GACT,eAAbA,EAAKtE,KACLJ,EAAOH,EAAS6E,EAAKrE,UAErBoE,EAAMnE,KAAK,IAAIqE,uBAAuB9E,EAAS6E,OAGhD,IAAIE,wBACPtF,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClBsC,WAAY8C,EACZzE,KAAMA,KAGd6E,iBAAkB,SAASxF,GACvB,OAAO,IAAKA,EAAE2C,SAAWrF,GAAU5C,IAC/BuF,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClByF,SAAUzF,EAAEyF,SACZC,WAAYlF,EAASR,EAAE6D,QACvB8B,SAAU3F,EAAE2C,SAAWnC,EAASR,EAAE2F,UAAY3F,EAAE2F,SAAS9D,QAGjE+D,aAAc,SAAS5F,GACnB,IAAI6F,EAAOrF,EAASR,EAAE8F,MAClBT,EAAOzC,EAAU5C,EAAE2F,UACvB,MAAiB,OAAbE,EAAKhE,MAAyB,UAARwD,EAAyB,IAAIpJ,IACnDgE,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClB6B,KAAM,eAEH,IAAInH,GACPuF,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClB0F,WAAYG,EACZF,SAAUN,KAGlBU,WAAY,SAAS/F,GACjB,OAAO,IAAKA,EAAEgG,KAAO5M,EAAWc,IAC5B+F,MAAaC,EAAeF,GAC5BG,IAAaC,EAAaJ,GAC1B0F,WAAalF,EAASR,EAAEgG,MACxB3F,KAAaL,EAAEiG,WAAW1F,IAAIC,MAGtC0F,qBAAsB,SAASlG,GAC3B,IAAIC,EAAQC,EAAeF,GACvBG,EAAMC,EAAaJ,GACvB,OAAO,IAAImG,mBACPlG,MAAOA,EACPE,IAAKA,EACLiG,SAAWpG,EAAEqG,SAAWC,EAAetG,EAAEqG,UAAY,IAAIhJ,IACrD4C,MAAOA,EACPqB,MAAO,IACPnB,IAAKA,KAEToG,MAAQ,IAAIlJ,IACR4C,MAAOA,EACPqB,MAAO,IACPnB,IAAKA,KAETqG,KAAMhG,EAASR,EAAEyG,WAGzBC,yBAA0B,SAAS1G,GAC/B,IAAI2G,EAAOnG,EAASR,EAAE4G,aACtB,IAAKD,EAAK9E,KAAM,OAAQ8E,EAAKE,MAC3B,KAAKlF,eACHgF,EAAO,IAAI1E,kBAAkB0E,GAC7B,MACF,KAAKjF,wBACHiF,EAAO,IAAI3E,2BAA2B2E,GACtC,MACF,KAAKvM,EACHuM,EAAO,IAAIlN,EAAoBkN,GAC/B,MACF,KAAKrM,EACHqM,EAAO,IAAItL,EAAasL,GACxB,MACF,KAAK/E,mBACH+E,EAAO,IAAIzE,sBAAsByE,GAGrC,OAAO,IAAIG,mBACP7G,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClBK,KAAMsG,KAGdI,uBAAwB,SAAS/G,GAC7B,GAAIA,EAAE4G,YAAa,OAAO,IAAI7L,GAC1BkF,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClBK,KAAMG,EAASR,EAAE4G,eAErB,GAAI5G,EAAEyG,OAAQ,CACV,IAAIL,KAAcG,KAKlB,OAJAvG,EAAEgH,WAAWnG,QAAQ,SAASwE,GAC1Be,EAAQnF,KAAKqF,EAAejB,EAAKgB,WACjCE,EAAKtF,KAAKqF,EAAejB,EAAK4B,UAE3B,IAAId,mBACPlG,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClBoG,QAASA,EACTG,KAAMA,EACNC,KAAMhG,EAASR,EAAEyG,UAGzB,OAAO,IAAIS,sBACPjH,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClBsC,WAAYtC,EAAEgH,WAAWzG,IAAI,SAAS8E,GAClC,IAAI8B,EAAM,IAAIjJ,GAAiBsC,EAAS6E,EAAK4B,QAE7C,OADAE,EAAIC,MAAQd,EAAejB,EAAKgB,UACzBc,OAInBE,kBAAmB,SAASrH,GACxB,IAAIC,EAAQC,EAAeF,GACvBG,EAAMC,EAAaJ,GACnBsH,EAAM,KAAMC,EAAM,KAAMnC,EAAQ,KA2BpC,OA1BApF,EAAEgH,WAAWnG,QAAQ,SAASwE,GAC1B,IAAI8B,EAAM,IAAI9I,GAAiBmC,EAAS6E,EAAK4B,QAC7C,OAAQ5B,EAAKtE,MACX,IAAK,0BACHwG,EAAMJ,GACF1E,IAAM,IAAIpF,IACV4C,MAAOA,EACPqB,MAAO,GACPnB,IAAKA,IAET,MACF,IAAK,4BACHmH,EAAMH,GACF1E,IAAM,IAAIpF,IACV4C,MAAOA,EACPqB,MAAO,IACPnB,IAAKA,IAET,MACF,QACEgH,EAAI1E,IAAM6D,EAAejB,EAAKmC,UACzBpC,IAAOA,MACZA,EAAMnE,KAAKkG,MAIZ,IAAI3L,GACPyE,MAAOA,EACPE,IAAKA,EACLmH,IAAKA,EACLG,QAASF,EACTjF,WAAY8C,EACZoB,KAAMhG,EAASR,EAAEyG,WAGzBiB,iBAAkB,SAAS1H,GACvB,IAAIC,EAAQC,EAAeF,GACvB2H,EAAMnH,EAASR,EAAEyG,QACrB,OAAO,IAAItN,GACP8G,MAAOA,EACPE,IAAKC,EAAaJ,GAClB0F,WAAY,IAAIhH,IACZuB,MAAOA,EACPE,IAAKwH,EAAI1H,MACT4B,KAAM,WAEV6C,MAAQiD,MAGhBC,oBAAqB,SAAS5H,GAC1B,OAAO,KACH6H,MAAO/N,EACPgO,IAAKhM,IACPkE,EAAE8C,OAAStD,KACTS,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClB+H,YAAa/H,EAAEgI,aAAazH,IAAIC,MAGxCyH,QAAS,SAASjI,GACd,IAAI0E,GACAzE,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,IAEtB,GAAIA,EAAEkI,OAEF,OADAxD,EAAKpD,MAAQtB,EAAEkI,OAAOC,cAAgB,IAC/B,IAAItP,EAAW6L,GAE1B,IAAI0D,EAAMpI,EAAEsB,MACZ,GAAY,OAAR8G,EAAc,OAAO,IAAIjM,GAASuI,GACtC,IAAI2D,EAAKrI,EAAEsI,MACX,GAAID,GAAMA,EAAGE,QAIT,OAFA7D,EAAKpD,MAAQ,IAAIkH,OAAOH,EAAGE,QAASF,EAAGI,OACvC/D,EAAKpD,MAAMoH,WAAaL,EAAGE,QACpB,IAAIvL,GAAW0H,GACnB,GAAI2D,EAGP,OADA3D,EAAKpD,MAAQtB,EAAEsI,OAAStI,EAAE2I,IAAM3I,EAAE2I,IAAMP,EACjC,IAAIpL,GAAW0H,GAE1B,cAAe0D,GACb,IAAK,SAEH,OADA1D,EAAKpD,MAAQ8G,EACN,IAAI/K,GAAWqH,GACxB,IAAK,SACH,OAAIkE,MAAMR,GAAa,IAAIS,QAAQnE,IAE/BoE,SAASV,IACTW,EAAS,EAAIX,EAAM,EACnB1D,EAAKpD,MAAQyH,GAAUX,EAAMA,EAC7B/G,EAAO,IAAIjF,GAAWsI,KAEtBqE,EAASX,EAAM,EACf/G,EAAO,IAAI2H,aAAatE,IAErBqE,EAAS,IAAIxJ,IAChBU,MAAOyE,EAAKzE,MACZE,IAAKuE,EAAKvE,IACV8I,SAAU,IACVvD,WAAYrE,IACXA,GAdL,IAAI0H,EAAQ1H,EAed,IAAK,UACH,OAAO,IAAK+G,EAAMlJ,GAAWlE,GAAW0J,KAGhDwE,gBAAiB,SAASlJ,GACtB,OAAO,IAAImJ,cACPlJ,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClBoJ,YAAapJ,EAAEoJ,YAAY7I,IAAIC,GAC/B6I,QAASrJ,EAAEsJ,OAAO/I,IAAI,SAAS0E,GAC3B,OAAOA,EAAG3D,MAAMqH,SAI5BY,yBAA0B,SAASvJ,GAC/B,IAAIwJ,EAAOhJ,EAASR,EAAEyJ,OAItB,OAHAD,EAAKvJ,MAAQC,EAAeF,GAC5BwJ,EAAKrJ,IAAMC,EAAaJ,GACxBwJ,EAAKE,IAAMlJ,EAASR,EAAE0J,KACfF,GAEXG,WAAY,SAAS3J,GACjB,IAAI4J,EAAGC,EAAQC,EAAe5F,OAAS,EACvC,GACI0F,EAAIE,IAAiBD,SACN,gBAAVD,EAAE7I,MACM,qBAAV6I,EAAE7I,MAA+B6I,EAAEhG,OAASkG,EAAeD,EAAQ,IACzD,iBAAVD,EAAE7I,MACQ,YAAV6I,EAAE7I,MAAsB6I,EAAEtI,QAAUwI,EAAeD,EAAQ,IACjD,sBAAVD,EAAE7I,MAAgC6I,EAAE9H,KAAOgI,EAAeD,EAAQ,IACzE,IAAIrI,EAAO9C,GACX,OAAQkL,EAAE7I,MACR,IAAK,0BACC6I,EAAEvJ,OAASyJ,EAAeD,EAAQ,KAAIrI,EAAOpD,IACjD,MACF,IAAK,iBACL,IAAK,oBACHoD,EAAO5F,GACP,MACF,IAAK,cACH4F,EAAO7D,GACP,MACF,IAAK,mBACCiM,EAAE9H,KAAOgI,EAAeD,EAAQ,KAAIrI,EAAOxD,IAC/C,MACF,IAAK,kBACC4L,EAAE9H,KAAOgI,EAAeD,EAAQ,KAAIrI,EAAO5D,IAC/C,MACF,IAAK,sBACH4D,EAAOoI,EAAE9H,KAAOgI,EAAeD,EAAQ,GAAK5L,GAAkBG,GAC9D,MACF,IAAK,qBACHoD,EAAOoI,EAAE9H,KAAOgI,EAAeD,EAAQ,GAAKtL,GAAmBH,GAC/D,MACF,IAAK,mBACHoD,EAAO9F,EACP,MACF,IAAK,sBACH8F,GACIqG,MAAO9J,GACP+J,IAAKtJ,IACPoL,EAAE9G,OAASnE,GAGjB,OAAO,IAAI6C,GACPvB,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClB6B,KAAM7B,EAAE6B,QAGhBkI,MAAO,SAAS/J,GACZ,OAAO,IAAIzC,IACP0C,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClB6B,KAAM,WAGdmI,eAAgB,SAAShK,GACrB,OAAO,IAAIlB,IACPmB,MAAOC,EAAeF,GACtBG,IAAKC,EAAaJ,GAClB6B,KAAM,UAGdoI,wBAAyB,SAASjK,GAC9B,IAAIqB,EAAOb,EAASR,EAAE0F,YAKtB,OAJKrE,EAAKpB,MAAMiK,SAAQ7I,EAAKpB,MAAMiK,WACnC7I,EAAKpB,MAAMiK,OAAOjJ,KAAKf,EAAeF,IACjCqB,EAAKlB,IAAI+J,SAAQ7I,EAAKlB,IAAI+J,WAC/B7I,EAAKlB,IAAI+J,OAAOjJ,KAAKb,EAAaJ,IAC3BqB,GAEX8I,gBAAiB,SAASnK,GACtB,IAAIqB,EAAOb,EAASR,EAAE0F,YAEtB,OADArE,EAAK+I,UAAW,EACT/I,IAkHf,SAASgJ,EAAwBvH,GAC7B,OAAO,SAAS9C,GACZ,IAAI2C,EAAW3C,EAAEyC,eAAevG,GAC5BuG,EAAME,EAAW2H,GAAOtK,EAAEyC,KAAOzC,EAAEiD,SACnClC,KAAM,oBACNc,KAAM7B,EAAEyC,IAAI8H,MAAM,KAElBxJ,KAAM,UACNO,MAAOtB,EAAEyC,KAEb,OACI1B,KAAM,mBACN+B,KAAMA,EACNH,SAAUA,EACVF,IAAKA,EACLS,OAAQlD,EAAEkD,OACV5B,MAAOgJ,GAAOtK,EAAEsB,SA8B5B,SAASkJ,EAAsBC,GAC3B,OAAO,SAASzK,GACZ,OACIe,KAAM,iBACN0C,MAAOgH,EACP7G,KAAM0G,GAAOtK,EAAE2D,MACfG,MAAOwG,GAAOtK,EAAE6D,QAChBxD,KAAMiK,GAAOtK,EAAEK,QAmS3B,SAASqK,EAAe1K,GACpB,IAAIsB,EAAQtB,EAAEsB,MACd,MAAqB,iBAAVA,IAAuBA,EAAQ,GAAgB,IAAVA,GAAe,EAAIA,EAAQ,IAEnEP,KAAM,kBACNkI,SAAU,IACV0B,QAAQ,EACR3J,UACID,KAAM,UACNO,OAAQA,EACRqH,IAAK3I,EAAEC,MAAM0I,OAKrB5H,KAAM,UACNO,MAAOA,EACPqH,IAAK3I,EAAEC,MAAM0I,KA2CrB,SAASrI,EAAqBD,GAC1B,IAAK,IAAIuK,EAAI,EAAGA,EAAIvK,EAAK6D,OAAQ0G,IAAK,CAClC,IAAIC,EAAOxK,EAAKuK,GAChB,KAAMC,aAAgB1N,IAAsB,MAC5C,IAAIkE,EAAOwJ,EAAKxK,KAChB,KAAMgB,aAAgBhE,IAAa,MACnC,GAAIwN,EAAK5K,MAAM6K,MAAQzJ,EAAKpB,MAAM6K,IAAK,MACvCzK,EAAKuK,GAAK,IAAIpQ,EAAc6G,GAEhC,OAAOhB,EAGX,SAAS0K,EAAUC,GACf,GAAoB,WAAhBA,EAAQjK,KACR,OAAsB,MAAfiK,EAAQrC,IAAcqC,EAAQrC,IAAMqC,EAAQ1J,MAAQ,GAInE,SAASpB,EAAe8K,GACpB,IAAIC,EAAMD,EAAQC,IAAKhL,EAAQgL,GAAOA,EAAIhL,MACtCiL,EAAQF,EAAQE,MACpB,OAAO,IAAIlM,IACPmM,KAAUF,GAAOA,EAAIxE,OACrB2E,KAAUnL,GAASA,EAAMmL,KACzBC,IAAUpL,GAASA,EAAMqL,OACzBR,IAAUI,EAAQA,EAAM,GAAKF,EAAQ/K,MACrCsL,QAAUtL,GAASA,EAAMmL,KACzBI,OAAUvL,GAASA,EAAMqL,OACzBG,OAAUP,EAAQA,EAAM,GAAKF,EAAQ/K,MACrC0I,IAAUoC,EAAUC,KAI5B,SAAS5K,EAAa4K,GAClB,IAAIC,EAAMD,EAAQC,IAAK9K,EAAM8K,GAAOA,EAAI9K,IACpC+K,EAAQF,EAAQE,MACpB,OAAO,IAAIlM,IACPmM,KAAUF,GAAOA,EAAIxE,OACrB2E,KAAUjL,GAAOA,EAAIiL,KACrBC,IAAUlL,GAAOA,EAAImL,OACrBR,IAAUI,EAAQA,EAAM,GAAKF,EAAQ7K,IACrCoL,QAAUpL,GAAOA,EAAIiL,KACrBI,OAAUrL,GAAOA,EAAImL,OACrBG,OAAUP,EAAQA,EAAM,GAAKF,EAAQ7K,IACrCwI,IAAUoC,EAAUC,KAI5B,SAASpI,EAAU5C,GACf,MAAO,GAAKA,EAAY,cAAVA,EAAEe,KAAuB,OAAS,SAGpD,SAASR,EAAImL,EAASC,EAAQC,GAC1B,IAAIC,GACA,2BACA,wBAEAC,GACA,SAAWC,KAAKC,UAAUN,IAG1BE,GAASA,EAAQK,MAAM,WAAWpL,QAAQ,SAASwE,GACnD,IAAI6G,EAAI,uCAAuCC,KAAK9G,GACpD,IAAK6G,EAAG,MAAM,IAAI9H,MAAM,kCAAoCiB,GAC5D,IAAI+G,EAAMF,EAAE,GAAIG,EAAMH,EAAE,GAAII,EAAKJ,EAAE,GACnC,OAAQG,GACN,IAAK,IACHR,EAAU5K,KAAKqL,EAAK,OAASF,EAAM,kBACnCN,EAAU7K,KAAKmL,EAAM,OAAUE,EAAK,gBACpC,MACF,IAAK,IACHT,EAAU5K,KAAKqL,EAAK,gBAAkBF,EAAM,KAC5CN,EAAU7K,KAAKmL,EAAM,cAAgBE,EAAK,KAC1C,MACF,IAAK,IACHT,EAAU5K,KAAKqL,EAAK,OAASF,GAC7BN,EAAU7K,KAAKmL,EAAM,OAASE,GAC9B,MACF,IAAK,IACHT,EAAU5K,KAAKqL,EAAK,gBAAkBF,EAAM,UAC5CN,EAAU7K,KAAKmL,EAAM,qBACrB,MACF,QACE,MAAM,IAAIhI,MAAM,yCAA2CiB,MAInEvF,EAAU4L,GAAW,IAAIa,SAAS,KAAM,iBAAkB,eAAgB,YACtE,4BAA8Bb,EAAU,QACxC,yBAA2BC,EAAOa,KAAO,KACzCX,EAAUY,KAAK,OACf,UACA,MACFA,KAAK,MANc,CAMPC,QAASxM,EAAgBE,EAAcI,GACrDmM,GAAWhB,EAAQ,IAAIY,SAAS,SAAU,eAAgB,gBACtD,0BAA4Bb,EAAU,QACtC,eACAI,EAAUW,KAAK,OACf,SACA,MACFA,KAAK,MANY,CAMLnC,GAAQsC,GAAcC,KAtmBxC/M,EAAUgN,iBACVhN,EAAUiN,gBAAkB,SAAsB/M,GAG9C,OAAO,KAFM,WAAYA,EAAIA,EAAE2K,OACf,mBAAV3K,EAAEe,MACaxB,GAAkBD,KACnCW,MAAaC,EAAeF,GAC5BG,IAAaC,EAAaJ,GAC1BiJ,SAAajJ,EAAEiJ,SACfvD,WAAalF,EAASR,EAAEgB,aAIhCT,EAAI,iBAAkB3F,GACtB2F,EAAI,sBAAuBpD,GAAqB,mBAChDoD,EAAI,iBAAkBvH,EAAoB,aAC1CuH,EAAI,cAAehF,EAAQ,0DAC3BgF,EAAI,mBAAoB5E,EAAsB,0BAC9C4E,EAAI,iBAAkBrH,EAAW,eACjCqH,EAAI,oBAAqBvG,EAAc,eACvCuG,EAAI,gBAAiBZ,GAAU,gCAC/BY,EAAI,kBAAmB/C,GAAY,uCACnC+C,EAAI,kBAAmBtD,GAAY,kBACnCsD,EAAI,iBAAkBxB,GAAW,kBACjCwB,EAAI,iBAAkBb,GAAW,6BACjCa,EAAI,mBAAoB9F,EAAQ,6BAChC8F,EAAI,eAAgBrF,EAAS,qDAC7BqF,EAAI,iBAAkBpF,EAAW,sCACjCoF,EAAI,oBAAqBtG,GACzBsG,EAAI,qBAAsBd,GAAY,uBACtCc,EAAI,cAAelH,EAAW,4BAE9BkH,EAAI,mBAAoBzH,EAAY,6CACpCyH,EAAI,oBAAqBzH,EAAY,6CACrCyH,EAAI,uBAAwB7H,EAAY,6CACxC6H,EAAI,oBAAqByM,iBAAkB,0BAC3CzM,EAAI,wBAAyB1G,EAAiB,gEAC9C0G,EAAI,gBAAiBvE,GAAS,gDAC9BuE,EAAI,iBAAkBpH,EAAU,mEAChCoH,EAAI,qBAAsBrD,GAAc,2BACxCqD,EAAI,gBAAiB0M,WAAY,uBACjC1M,EAAI,mBAAoBlE,GAAY,yBACpCkE,EAAI,kBAAmB3H,EAAW,uBAClC2H,EAAI,kBAAmBX,GAAW,wCAElC+M,GAAW1N,GAAc,SAAwBe,GAC7C,OAAO6M,GAAa,UAAW7M,KAGnC2M,GAAWO,qBAAsB,SAAoClN,GACjE,IAAIY,EAASZ,EAAEU,SAASH,IAAI+J,IAK5B,OAJItK,EAAEW,MAAMC,EAAOK,MACfF,KAAM,cACNC,SAAUsJ,GAAOtK,EAAEW,SAGnBI,KAAM,sBACNe,GAAIwI,GAAOtK,EAAE6B,MACbV,MAAOgM,SAASnN,GAChByB,UAAW5B,GAAaG,GACxBY,OAAQA,EACRP,KAAMwM,GAAa,iBAAkB7M,MAI7C2M,GAAW9Q,GAAY,SAAmCmE,GACtD,IAAIY,EAASZ,EAAEU,SAASH,IAAI+J,IAK5B,OAJItK,EAAEW,MAAMC,EAAOK,MACfF,KAAM,cACNC,SAAUsJ,GAAOtK,EAAEW,QAEnByM,SAASpN,IACTe,KAAM,0BACNI,MAAOgM,SAASnN,GAChBY,OAAQA,EACRP,KAAML,EAAEsB,MAAQgJ,GAAOtK,EAAEsB,OAASuL,GAAa,iBAAkB7M,KAGjEe,KAAM,qBACNe,GAAIwI,GAAOtK,EAAE6B,MACbV,MAAOgM,SAASnN,GAChByB,UAAW5B,GAAaG,GACxBY,OAAQA,EACRP,KAAMwM,GAAa,iBAAkB7M,MAI7C2M,GAAWvS,EAAc,SAAiC4F,GACtD,OACIe,KAAM,mBACNe,GAAIwI,GAAOtK,EAAE6B,MACbQ,WAAYiI,GAAOtK,EAAEoC,SACrB/B,MACIU,KAAM,YACNV,KAAML,EAAEsC,WAAW/B,IAAI+J,QAKnCqC,GAAWlT,EAAqB,SAAgCuG,GAC5D,OACIe,KAAM,kBACNe,GAAIwI,GAAOtK,EAAE6B,MACbQ,WAAYiI,GAAOtK,EAAEoC,SACrB/B,MACIU,KAAM,YACNV,KAAML,EAAEsC,WAAW/B,IAAI+J,QAyBnCqC,GAAW5J,gBAAiBsH,EAAwB,QACpDsC,GAAW3J,gBAAiBqH,EAAwB,QACpDsC,GAAW9J,gBAAiBwH,EAAwB,WAEpDsC,GAAWvJ,eAAgB,SAAmCpD,GAC1D,IAAI2C,EAAW3C,EAAEyC,eAAevG,GAQhC,OACI6E,KAAM,qBACN4B,SAAUA,EACVF,IAVME,EAAW2H,GAAOtK,EAAEyC,KAAOzC,EAAEiD,SACnClC,KAAM,oBACNc,KAAM7B,EAAEyC,IAAI8H,MAAM,KAElBxJ,KAAM,UACNO,MAAOtB,EAAEyC,KAMTS,OAAQlD,EAAEkD,OACV5B,MAAOgJ,GAAOtK,EAAEsB,UAIxBqL,GAAWrJ,cAAe,SAA4BtD,GAClD,OAAO6M,GAAa,cAAe7M,EAAEsB,SAczCqL,GAAWjJ,eAAgB8G,GAAsB,IACjDmC,GAAWvR,EAAWoP,GAAsB,IAE5CmC,GAAWnS,EAAe,SAA0BwF,GAChD,OACIe,KAAM,sBACN2E,WAAY2H,GAAYrN,GACpBe,KAAM,UACNO,MAAOtB,EAAEsB,WAKrBqL,GAAWlP,GAAkB,SAA2BuC,GACpD,OACIe,KAAM,aACNiF,KAAMsE,GAAOtK,EAAE0F,YACfO,WAAYjG,EAAEK,KAAKE,IAAI+J,OAI/BqC,GAAWxN,GAAS,SAA6Ba,GAC7C,OACIe,KAAM,eACNsD,MAAOuI,GAAa5M,GACpBiE,QAASqG,GAAOtK,EAAEsE,QAClBH,mBACAK,UAAW8F,GAAOtK,EAAEuE,aAI5BoI,GAAWtT,EAAW,SAA4B2G,GAC9C,OACIe,KAAM,cACND,MAAOwJ,GAAOtK,EAAEsN,SAChBC,MAAO,KACPlN,KAAMuM,GAAa5M,MAI3B2M,GAAW5R,EAAuB,SAAmDiF,GACjF,OACIe,KAAM,yBACN6F,YAAa0D,GAAOtK,EAAEK,SAI9BsM,GAAW7F,kBAAmB,SAAyC9G,GACnE,OACIe,KAAM,2BACN6F,YAAa0D,GAAOtK,EAAEK,SAI9BsM,GAAWxG,kBAAmB,SAA4DnG,GACtF,GAAuB,KAAnBA,EAAEuG,KAAK,GAAGjF,MAAc,OACxBP,KAAM,uBACNsF,SAAgC,KAAtBrG,EAAEoG,QAAQ,GAAG9E,MAAe,KAAOkM,GAAaxN,EAAEoG,QAAQ,IACpEK,OAAQ6D,GAAOtK,EAAEwG,OAGrB,IADA,IAAIQ,KACK4D,EAAI,EAAGA,EAAI5K,EAAEoG,QAAQlC,OAAQ0G,IAClC5D,EAAW/F,KAAKoM,IACZpN,MAAOD,EAAEuG,KAAKqE,GAAG3K,MACjBE,IAAKH,EAAEoG,QAAQwE,GAAGzK,MAElBY,KAAM,kBACNkG,MAAOuG,GAAaxN,EAAEuG,KAAKqE,IAC3BvE,SAAUmH,GAAaxN,EAAEoG,QAAQwE,OAGzC,OACI7J,KAAM,yBACNiG,WAAYA,EACZP,OAAQ6D,GAAOtK,EAAEwG,SAIzBmG,GAAWzF,qBAAsB,SAAkDlH,GAC/E,OACIe,KAAM,yBACNiG,WAAYhH,EAAEsC,WAAW/B,IAAI,SAAS8E,GAClC,OAAOgI,IACHpN,MAAOoF,EAAKpF,MACZE,IAAKkF,EAAK+B,MAAMjH,MAEhBY,KAAM,kBACNkG,MAAOqD,GAAOjF,GACdgB,SAAUmH,GAAanI,EAAK+B,cAM5CuF,GAAWnR,EAAY,SAAkCwE,GACrD,IAAIgH,EAAahH,EAAEsC,WAAatC,EAAEsC,WAAW/B,IAAI,SAAS8E,GACtD,OAAOgI,IACHpN,MAAOoF,EAAK5C,IAAIxC,MAChBE,IAAKkF,EAAKlF,MAEVY,KAAM,kBACNkG,MAAOqD,GAAOjF,GACdmC,SAAUgG,GAAanI,EAAK5C,YAWpC,OARIzC,EAAEsH,KAAKN,EAAWyG,QAAQJ,GAAYrN,EAAEsH,KACxCvG,KAAM,2BACNkG,MAAOqD,GAAOtK,EAAEsH,QAEhBtH,EAAEyH,SAAST,EAAWyG,QAAQJ,GAAYrN,EAAEyH,SAC5C1G,KAAM,yBACNkG,MAAOqD,GAAOtK,EAAEyH,aAGhB1G,KAAM,oBACNiG,WAAYA,EACZP,OAAQ6D,GAAOtK,EAAEwG,SAIzBmG,GAAWtS,EAAiB,SAAoC2F,GAC5D,OACIe,KAAM,sBACN+B,KAAM9C,EAAEwM,KAAKrE,cACbH,aAAchI,EAAE+H,YAAYxH,IAAI+J,OAIxCqC,GAAW5P,GAAgB,SAAiCiD,GACxD,IAAI2C,EAAW3C,aAAa1C,GACxBuI,GACA9E,KAAM,mBACN8C,OAAQyG,GAAOtK,EAAE0F,YACjB/C,SAAUA,EACV8C,SAAUzF,EAAEyF,SACZE,SAAUhD,EAAW2H,GAAOtK,EAAE2F,WAC1B5E,KAAM,aACNc,KAAM7B,EAAE2F,WAGhB,OAAO3F,EAAEoK,UACLrJ,KAAM,kBACN2E,WAAYG,GACZA,IAGR8G,GAAWtN,GAAW,SAAsBW,GACxC,OACIe,KAAoB,MAAdf,EAAEiJ,UAAkC,MAAdjJ,EAAEiJ,SAAmB,mBAAqB,kBACtEA,SAAUjJ,EAAEiJ,SACZ0B,OAAQ3K,aAAaT,GACrByB,SAAUsJ,GAAOtK,EAAE0F,eAI3BiH,GAAW7T,EAAY,SAAiCkH,GACpD,OACIe,KAAoB,MAAdf,EAAEiJ,UAAkC,MAAdjJ,EAAEiJ,SAAmB,oBAAsB,mBACvErF,KAAM0G,GAAOtK,EAAE4D,MACfqF,SAAUjJ,EAAEiJ,SACZnF,MAAOwG,GAAOtK,EAAE8D,UAIxB6I,GAAWnU,EAAW,SAAgCwH,GAClD,OACIe,KAAM,kBACN+D,SAAU9E,EAAE8E,SAASvE,IAAI+J,OAIjCqC,GAAWzH,sBAAuB,SAA6BlF,GAC3D,IAAI8E,EAAW9E,EAAE8E,SAASvE,IAAI+J,IAK9B,OAJItK,EAAEW,MAAMmE,EAAS7D,MACjBF,KAAM,cACNC,SAAUsJ,GAAOtK,EAAEW,SAGnBI,KAAM,eACN+D,SAAUA,KAIlB6H,GAAWrH,uBAAwB,SAAyBtF,GACxD,IAAI2C,EAAW3C,EAAEyC,eAAevG,GAKhC,OACI6E,KAAM,WACN+B,KAAM,OACNH,SAAUA,EACVF,IARME,EAAW2H,GAAOtK,EAAEyC,MAC1B1B,KAAM,UACNO,MAAOtB,EAAEyC,KAOTnB,MAAOgJ,GAAOtK,EAAEsB,UAIxBqL,GAAWpH,uBAAwB,SAA8BvF,GAC7D,IAAIoF,EAAQpF,EAAEsC,WAAW/B,IAAI+J,IAK7B,OAJItK,EAAEW,MAAMyE,EAAMnE,MACdF,KAAM,cACNC,SAAUsJ,GAAOtK,EAAEW,SAGnBI,KAAM,gBACNuB,WAAY8C,KAIpBuH,GAAWnQ,GAAoB,SAAyBwD,GACpD,IAKI8C,EALAH,EAAW3C,EAAEyC,eAAevG,GAC5BuG,EAAME,EAAW2H,GAAOtK,EAAEyC,MAC1B1B,KAAM,UACNO,MAAOtB,EAAEyC,KAUb,OAPIzC,aAAazD,GACbuG,EAAO,OACA9C,aAAa1D,GACpBwG,EAAO,MACA9C,aAAavD,KACpBqG,EAAO,QAGP/B,KAAM,WACN+B,KAAMA,EACNH,SAAUA,EACVgC,OAAQ3E,aAAa4E,iBACrBnC,IAAKA,EACLnB,MAAOgJ,GAAOtK,EAAEsB,UAIxBqL,GAAWjP,GAAY,SAA2BsC,GAC9C,IAAIuH,EAAMvH,EAAE0N,aACZ,OACI3M,KAAM,aACNc,KAAM0F,GAAOA,EAAIoG,cAAgB3N,EAAE6B,QAI3C8K,GAAWpP,GAAW,WAClB,OAASwD,KAAM,WAGnB4L,GAAW7N,GAAU,WACjB,OAASiC,KAAM,oBAGnB4L,GAAW1Q,GAAe,WACtB,OACI8E,KAAM,eACN+E,MACI/E,KAAM,aACNc,KAAM,OAEV8D,UACI5E,KAAM,aACNc,KAAM,aAKlB8K,GAAW3P,GAAY,SAA8BgD,GACjD,IAAIyI,EAAQzI,EAAEsB,MAAMsM,WAAWC,MAAM,iBAAiB,GAClDvM,EAAQ,IAAMtB,EAAEsB,MAAMoH,WAAa,IAAMD,EAC7C,OACI1H,KAAM,UACNO,MAAOA,EACPqH,IAAKrH,EACLgH,OACIC,QAASvI,EAAEsB,MAAMoH,WACjBD,MAAOA,MAKnBkE,GAAW9T,EAAY,SAAuBmH,GAC1C,IAAIsB,EAAQtB,EAAEsB,MACd,OACIP,KAAM,UACNmH,OAAQ5G,EAAMiJ,MAAM,GAAI,GACxB5B,IAAKrH,KAwBbqL,GAAW1T,EAAayR,GACxBiC,GAAW5S,EAAc2Q,GACzBiC,GAAWxQ,GAAUuO,GAErBiC,GAAWhU,EAAU,SAAqBqH,GACtC,OACIe,KAAM,aACNc,KAAMiM,OAAO9N,EAAEsB,UAIvBqL,GAAWxD,aAAc,SAAyDnJ,GAC9E,IAAI+N,EAAO/N,EAAEqJ,QAAQnF,OAAS,EAC1BsF,GACAzI,KAAM,kBACNqI,YAAapJ,EAAEoJ,YAAY7I,IAAI+J,IAC/BhB,OAAQtJ,EAAEqJ,QAAQ9I,IAAI,SAASyN,EAAKC,GAChC,OACIlN,KAAM,kBACNmN,KAAMD,GAASF,EACfzM,OAASqH,IAAKqF,OAI1B,OAAKhO,EAAE0J,KAEH3I,KAAM,2BACN2I,IAAKY,GAAOtK,EAAE0J,KACdD,MAAOD,GAJQA,IAQvBzQ,EAAUoV,UAAU,iBAAkBnV,EAAmBoV,UAAUC,gBACnE/S,EAAS6S,UAAU,iBAAkBG,aACrCpS,GAASiS,UAAU,iBAAkB,WACjC,MAAM,IAAI/J,MAAM,sBAAwBmK,KAAK/B,QA4GjD,IAAI1C,EAAiB,KAErB,SAAStJ,EAAS4L,GACdtC,EAAe7I,KAAKmL,GACpB,IAAI/K,EAAO,KACX,GAAI+K,EAAK,CACL,IAAKoC,IAAI1O,EAAWsM,EAAIrL,MAAO,MAAM,IAAIqD,MAAM,qBAAuBgI,EAAIrL,MAC1EM,EAAOvB,EAAUsM,EAAIrL,MAAMqL,GAG/B,OADAtC,EAAe2E,MACRpN,EAGX,SAASiF,EAAe8F,GACpB,OAAO,IAAI/O,IACP4C,MAAOC,EAAekM,GACtB9K,MAAOsB,EAAUwJ,GACjBjM,IAAKC,EAAagM,KA2B1B,SAASiB,GAAYqB,EAAQ1D,GACzB,IAAI/K,EAAQyO,EAAOzO,MACfE,EAAMuO,EAAOvO,IAajB,OAZiB,MAAbF,EAAM6K,KAA6B,MAAd3K,EAAIsL,SACzBT,EAAQE,OAASjL,EAAM6K,IAAK3K,EAAIsL,SAEhCxL,EAAMmL,OACNJ,EAAQC,KACJhL,OAAQmL,KAAMnL,EAAMmL,KAAME,OAAQrL,EAAMoL,KACxClL,IAAKA,EAAIoL,SAAWH,KAAMjL,EAAIoL,QAASD,OAAQnL,EAAIqL,QAAU,MAE7DvL,EAAMkL,OACNH,EAAQC,IAAIxE,OAASxG,EAAMkL,OAG5BH,EAGX,SAAS2B,GAAWhB,EAAQ1H,GACxB0H,EAAOwC,UAAU,iBAAkB,WAC/B,OAAOd,GAAYkB,KAAMtK,EAAQsK,SAIzC,SAASjE,GAAOjJ,GACZ,OAAe,MAARA,EAAeA,EAAKgN,iBAAmB,KAGlD,SAASb,GAAapG,GAClB,OAAOuH,qBAAqBvH,EAAM9F,OAAS+L,GAAYjG,GACnDrG,KAAM,aACNc,KAAMuF,EAAM9F,QACXgJ,GAAOlD,GAGhB,SAASwF,GAAavL,GAClB,OACIN,KAAM,iBACNV,KAAMgB,EAAKhB,KAAKE,IAAI+J,KAI5B,SAASuC,GAAa9L,EAAMM,GACxB,IAAIhB,EAAOgB,EAAKhB,KAAKE,IAAI+J,IAIzB,OAHIjJ,EAAKhB,KAAK,aAAclD,IAAuBkE,EAAKhB,KAAK,GAAGA,gBAAgBhD,IAC5EgD,EAAKoN,QAAQnD,GAAO,IAAI1P,EAAmByG,EAAKhB,KAAK,OAGrDU,KAAMA,EACNV,KAAMA,GAxEdnE,GAAS0S,iBAAmB,SAASvN,GACjC,IAAIwN,EAAa/E,EACjBA,KACA,IAAIgF,EAAMtO,EAASa,GAiBnB,OAhBAyI,EAAiB+E,EACjBC,EAAIC,KAAK,IAAIC,WAAW,SAAS3N,GAC7B,GAAIA,aAAgBzF,GAAc,CAC9B,IAAK,IAAeqT,EAAXpF,EAAQ,GAAWoF,EAASV,KAAKU,OAAOpF,OACzCoF,aAAkBC,WAD+BrF,IAErD,GAAIoF,aAAkBtT,GAAwBsT,EAAOE,MAAMtN,MAAQR,EAAKQ,KAAM,CAC1ER,EAAK+N,OAASH,EAAOE,MACrB,MAGR,IAAK9N,EAAK+N,OAAQ,CACd,IAAIC,EAAIhO,EAAKpB,MACbqP,SAAS,mBAAqBjO,EAAKQ,KAAMwN,EAAElE,KAAMkE,EAAEjE,KAAMiE,EAAEhE,IAAKgE,EAAEvE,UAIvEgE,GAzrCf","file":"../mozilla-ast.js","sourcesContent":["define([\n    \"./ast\"\n],function(m_ast){\n    /***********************************************************************\n\n      A JavaScript tokenizer / parser / beautifier / compressor.\n      https://github.com/mishoo/UglifyJS\n\n      -------------------------------- (C) ---------------------------------\n\n                               Author: Mihai Bazon\n                             <mihai.bazon@gmail.com>\n                           http://mihai.bazon.net/blog\n\n      Distributed under the BSD license:\n\n        Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n        Redistribution and use in source and binary forms, with or without\n        modification, are permitted provided that the following conditions\n        are met:\n\n            * Redistributions of source code must retain the above\n              copyright notice, this list of conditions and the following\n              disclaimer.\n\n            * Redistributions in binary form must reproduce the above\n              copyright notice, this list of conditions and the following\n              disclaimer in the documentation and/or other materials\n              provided with the distribution.\n\n        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n        EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n        IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n        PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n        LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n        OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n        PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n        PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n        THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n        TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n        THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n        SUCH DAMAGE.\n\n     ***********************************************************************/\n\n    \"use strict\";\n\n    const {\n        AST_Accessor,\n        AST_Array,\n        AST_Arrow,\n        AST_Assign,\n        AST_Atom,\n        AST_Await,\n        AST_BigInt,\n        AST_Binary,\n        AST_Block,\n        AST_BlockStatement,\n        AST_Boolean,\n        AST_Break,\n        AST_Call,\n        AST_Case,\n        AST_Catch,\n        AST_Chain,\n        AST_Class,\n        AST_ClassStaticBlock,\n        AST_ClassExpression,\n        AST_ClassProperty,\n        AST_ClassPrivateProperty,\n        AST_ConciseMethod,\n        AST_Conditional,\n        AST_Const,\n        AST_Constant,\n        AST_Continue,\n        AST_Debugger,\n        AST_Default,\n        AST_DefaultAssign,\n        AST_DefClass,\n        AST_Definitions,\n        AST_Defun,\n        AST_Destructuring,\n        AST_Directive,\n        AST_Do,\n        AST_Dot,\n        AST_DotHash,\n        AST_EmptyStatement,\n        AST_Expansion,\n        AST_Export,\n        AST_ExportDeclaration,\n        AST_False,\n        AST_Finally,\n        AST_For,\n        AST_ForIn,\n        AST_ForOf,\n        AST_Function,\n        AST_Hole,\n        AST_If,\n        AST_Import,\n        AST_ImportMeta,\n        AST_Label,\n        AST_LabeledStatement,\n        AST_LabelRef,\n        AST_Lambda,\n        AST_Let,\n        AST_NameMapping,\n        AST_New,\n        AST_NewTarget,\n        AST_Node,\n        AST_Null,\n        AST_Number,\n        AST_Object,\n        AST_ObjectGetter,\n        AST_ObjectKeyVal,\n        AST_ObjectProperty,\n        AST_ObjectSetter,\n        AST_PrefixedTemplateString,\n        AST_PrivateGetter,\n        AST_PrivateMethod,\n        AST_PrivateSetter,\n        AST_PrivateIn,\n        AST_PropAccess,\n        AST_RegExp,\n        AST_Return,\n        AST_Sequence,\n        AST_SimpleStatement,\n        AST_Statement,\n        AST_String,\n        AST_Sub,\n        AST_Super,\n        AST_Switch,\n        AST_SwitchBranch,\n        AST_Symbol,\n        AST_SymbolCatch,\n        AST_SymbolClass,\n        AST_SymbolClassProperty,\n        AST_SymbolPrivateProperty,\n        AST_SymbolConst,\n        AST_SymbolDefClass,\n        AST_SymbolDefun,\n        AST_SymbolExport,\n        AST_SymbolExportForeign,\n        AST_SymbolFunarg,\n        AST_SymbolImport,\n        AST_SymbolImportForeign,\n        AST_SymbolLambda,\n        AST_SymbolLet,\n        AST_SymbolMethod,\n        AST_SymbolRef,\n        AST_SymbolVar,\n        AST_TemplateSegment,\n        AST_TemplateString,\n        AST_This,\n        AST_Throw,\n        AST_Token,\n        AST_Toplevel,\n        AST_True,\n        AST_Try,\n        AST_TryBlock,\n        AST_Unary,\n        AST_UnaryPostfix,\n        AST_UnaryPrefix,\n        AST_Var,\n        AST_VarDef,\n        AST_While,\n        AST_With,\n        AST_Yield,\n\n        is_generator\n    } = m_ast;\n\n    (function() {\n        var MOZ_TO_ME = {\n            Program: function(M) {\n                return new AST_Toplevel({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    body: normalize_directives(M.body.map(from_moz)),\n                });\n            },\n            ArrowFunctionExpression: function(M) {\n                var argnames = [], rest = null;\n                M.params.forEach(function(param) {\n                    if (param.type == \"RestElement\") {\n                        rest = from_moz(param.argument);\n                    } else {\n                        argnames.push(from_moz(param));\n                    }\n                });\n                var fn = new (M.async ? AST_AsyncArrow : AST_Arrow)({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    argnames: argnames,\n                    rest: rest,\n                });\n                var node = from_moz(M.body);\n                if (node instanceof AST_BlockStatement) {\n                    fn.body = normalize_directives(node.body);\n                    fn.value = null;\n                } else {\n                    fn.body = [];\n                    fn.value = node;\n                }\n                return fn;\n            },\n            FunctionDeclaration: function(M) {\n                var ctor;\n                if (M.async) {\n                    ctor = M.generator ? AST_AsyncGeneratorDefun : AST_AsyncDefun;\n                } else {\n                    ctor = M.generator ? AST_GeneratorDefun : AST_Defun;\n                }\n                var argnames = [], rest = null;\n                M.params.forEach(function(param) {\n                    if (param.type == \"RestElement\") {\n                        rest = from_moz(param.argument);\n                    } else {\n                        argnames.push(from_moz(param));\n                    }\n                });\n                return new ctor({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: from_moz(M.id),\n                    argnames: argnames,\n                    rest: rest,\n                    body: normalize_directives(from_moz(M.body).body),\n                });\n            },\n            FunctionExpression: function(M) {\n                var ctor;\n                if (M.async) {\n                    ctor = M.generator ? AST_AsyncGeneratorFunction : AST_AsyncFunction;\n                } else {\n                    ctor = M.generator ? AST_GeneratorFunction : AST_Function;\n                }\n                var argnames = [], rest = null;\n                M.params.forEach(function(param) {\n                    if (param.type == \"RestElement\") {\n                        rest = from_moz(param.argument);\n                    } else {\n                        argnames.push(from_moz(param));\n                    }\n                });\n                return new ctor({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: from_moz(M.id),\n                    argnames: argnames,\n                    rest: rest,\n                    body: normalize_directives(from_moz(M.body).body),\n                });\n            },\n            ClassDeclaration: function(M) {\n                return new AST_DefClass({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: from_moz(M.id),\n                    extends: from_moz(M.superClass),\n                    properties: M.body.body.map(from_moz),\n                });\n            },\n            ClassExpression: function(M) {\n                return new AST_ClassExpression({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: from_moz(M.id),\n                    extends: from_moz(M.superClass),\n                    properties: M.body.body.map(from_moz),\n                });\n            },\n            MethodDefinition: function(M) {\n                var key = M.key, internal = false;\n                if (M.computed) {\n                    key = from_moz(key);\n                } else if (key.type == \"PrivateIdentifier\") {\n                    internal = true;\n                    key = \"#\" + key.name;\n                } else {\n                    key = read_name(key);\n                }\n                var ctor = AST_ClassMethod, value = from_moz(M.value);\n                switch (M.kind) {\n                  case \"get\":\n                    ctor = AST_ClassGetter;\n                    value = new AST_Accessor(value);\n                    break;\n                  case \"set\":\n                    ctor = AST_ClassSetter;\n                    value = new AST_Accessor(value);\n                    break;\n                }\n                return new ctor({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    key: key,\n                    private: internal,\n                    static: M.static,\n                    value: value,\n                });\n            },\n            PropertyDefinition: function(M) {\n                var key = M.key, internal = false;\n                if (M.computed) {\n                    key = from_moz(key);\n                } else if (key.type == \"PrivateIdentifier\") {\n                    internal = true;\n                    key = \"#\" + key.name;\n                } else {\n                    key = read_name(key);\n                }\n                return new AST_ClassField({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    key: key,\n                    private: internal,\n                    static: M.static,\n                    value: from_moz(M.value),\n                });\n            },\n            StaticBlock: function(M) {\n                var start = my_start_token(M);\n                var end = my_end_token(M);\n                return new AST_ClassInit({\n                    start: start,\n                    end: end,\n                    value: new AST_ClassInitBlock({\n                        start: start,\n                        end: end,\n                        body: normalize_directives(M.body.map(from_moz)),\n                    }),\n                });\n            },\n            ForOfStatement: function(M) {\n                return new (M.await ? AST_ForAwaitOf : AST_ForOf)({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    init: from_moz(M.left),\n                    object: from_moz(M.right),\n                    body: from_moz(M.body),\n                });\n            },\n            TryStatement: function(M) {\n                var handlers = M.handlers || [M.handler];\n                if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n                    throw new Error(\"Multiple catch clauses are not supported.\");\n                }\n                return new AST_Try({\n                    start    : my_start_token(M),\n                    end      : my_end_token(M),\n                    body     : from_moz(M.block).body,\n                    bcatch   : from_moz(handlers[0]),\n                    bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null,\n                });\n            },\n            Property: function(M) {\n                var key = M.computed ? from_moz(M.key) : read_name(M.key);\n                var args = {\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    key: key,\n                    value: from_moz(M.value),\n                };\n                if (M.kind == \"init\") return new (M.method ? AST_ObjectMethod : AST_ObjectKeyVal)(args);\n                args.value = new AST_Accessor(args.value);\n                if (M.kind == \"get\") return new AST_ObjectGetter(args);\n                if (M.kind == \"set\") return new AST_ObjectSetter(args);\n            },\n            ArrayExpression: function(M) {\n                return new AST_Array({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    elements: M.elements.map(function(elem) {\n                        return elem === null ? new AST_Hole() : from_moz(elem);\n                    }),\n                });\n            },\n            ArrayPattern: function(M) {\n                var elements = [], rest = null;\n                M.elements.forEach(function(el) {\n                    if (el === null) {\n                        elements.push(new AST_Hole());\n                    } else if (el.type == \"RestElement\") {\n                        rest = from_moz(el.argument);\n                    } else {\n                        elements.push(from_moz(el));\n                    }\n                });\n                return new AST_DestructuredArray({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    elements: elements,\n                    rest: rest,\n                });\n            },\n            ObjectPattern: function(M) {\n                var props = [], rest = null;\n                M.properties.forEach(function(prop) {\n                    if (prop.type == \"RestElement\") {\n                        rest = from_moz(prop.argument);\n                    } else {\n                        props.push(new AST_DestructuredKeyVal(from_moz(prop)));\n                    }\n                });\n                return new AST_DestructuredObject({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    properties: props,\n                    rest: rest,\n                });\n            },\n            MemberExpression: function(M) {\n                return new (M.computed ? AST_Sub : AST_Dot)({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    optional: M.optional,\n                    expression: from_moz(M.object),\n                    property: M.computed ? from_moz(M.property) : M.property.name,\n                });\n            },\n            MetaProperty: function(M) {\n                var expr = from_moz(M.meta);\n                var prop = read_name(M.property);\n                if (expr.name == \"new\" && prop == \"target\") return new AST_NewTarget({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: \"new.target\",\n                });\n                return new AST_Dot({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    expression: expr,\n                    property: prop,\n                });\n            },\n            SwitchCase: function(M) {\n                return new (M.test ? AST_Case : AST_Default)({\n                    start      : my_start_token(M),\n                    end        : my_end_token(M),\n                    expression : from_moz(M.test),\n                    body       : M.consequent.map(from_moz),\n                });\n            },\n            ExportAllDeclaration: function(M) {\n                var start = my_start_token(M);\n                var end = my_end_token(M);\n                return new AST_ExportForeign({\n                    start: start,\n                    end: end,\n                    aliases: [ M.exported ? from_moz_alias(M.exported) : new AST_String({\n                        start: start,\n                        value: \"*\",\n                        end: end,\n                    }) ],\n                    keys: [ new AST_String({\n                        start: start,\n                        value: \"*\",\n                        end: end,\n                    }) ],\n                    path: from_moz(M.source),\n                });\n            },\n            ExportDefaultDeclaration: function(M) {\n                var decl = from_moz(M.declaration);\n                if (!decl.name) switch (decl.CTOR) {\n                  case AST_AsyncDefun:\n                    decl = new AST_AsyncFunction(decl);\n                    break;\n                  case AST_AsyncGeneratorDefun:\n                    decl = new AST_AsyncGeneratorFunction(decl);\n                    break;\n                  case AST_DefClass:\n                    decl = new AST_ClassExpression(decl);\n                    break;\n                  case AST_Defun:\n                    decl = new AST_Function(decl);\n                    break;\n                  case AST_GeneratorDefun:\n                    decl = new AST_GeneratorFunction(decl);\n                    break;\n                }\n                return new AST_ExportDefault({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    body: decl,\n                });\n            },\n            ExportNamedDeclaration: function(M) {\n                if (M.declaration) return new AST_ExportDeclaration({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    body: from_moz(M.declaration),\n                });\n                if (M.source) {\n                    var aliases = [], keys = [];\n                    M.specifiers.forEach(function(prop) {\n                        aliases.push(from_moz_alias(prop.exported));\n                        keys.push(from_moz_alias(prop.local));\n                    });\n                    return new AST_ExportForeign({\n                        start: my_start_token(M),\n                        end: my_end_token(M),\n                        aliases: aliases,\n                        keys: keys,\n                        path: from_moz(M.source),\n                    });\n                }\n                return new AST_ExportReferences({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    properties: M.specifiers.map(function(prop) {\n                        var sym = new AST_SymbolExport(from_moz(prop.local));\n                        sym.alias = from_moz_alias(prop.exported);\n                        return sym;\n                    }),\n                });\n            },\n            ImportDeclaration: function(M) {\n                var start = my_start_token(M);\n                var end = my_end_token(M);\n                var all = null, def = null, props = null;\n                M.specifiers.forEach(function(prop) {\n                    var sym = new AST_SymbolImport(from_moz(prop.local));\n                    switch (prop.type) {\n                      case \"ImportDefaultSpecifier\":\n                        def = sym;\n                        def.key = new AST_String({\n                            start: start,\n                            value: \"\",\n                            end: end,\n                        });\n                        break;\n                      case \"ImportNamespaceSpecifier\":\n                        all = sym;\n                        all.key = new AST_String({\n                            start: start,\n                            value: \"*\",\n                            end: end,\n                        });\n                        break;\n                      default:\n                        sym.key = from_moz_alias(prop.imported);\n                        if (!props) props = [];\n                        props.push(sym);\n                        break;\n                    }\n                });\n                return new AST_Import({\n                    start: start,\n                    end: end,\n                    all: all,\n                    default: def,\n                    properties: props,\n                    path: from_moz(M.source),\n                });\n            },\n            ImportExpression: function(M) {\n                var start = my_start_token(M);\n                var arg = from_moz(M.source);\n                return new AST_Call({\n                    start: start,\n                    end: my_end_token(M),\n                    expression: new AST_SymbolRef({\n                        start: start,\n                        end: arg.start,\n                        name: \"import\",\n                    }),\n                    args: [ arg ],\n                });\n            },\n            VariableDeclaration: function(M) {\n                return new ({\n                    const: AST_Const,\n                    let: AST_Let,\n                }[M.kind] || AST_Var)({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    definitions: M.declarations.map(from_moz),\n                });\n            },\n            Literal: function(M) {\n                var args = {\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                };\n                if (M.bigint) {\n                    args.value = M.bigint.toLowerCase() + \"n\";\n                    return new AST_BigInt(args);\n                }\n                var val = M.value;\n                if (val === null) return new AST_Null(args);\n                var rx = M.regex;\n                if (rx && rx.pattern) {\n                    // RegExpLiteral as per ESTree AST spec\n                    args.value = new RegExp(rx.pattern, rx.flags);\n                    args.value.raw_source = rx.pattern;\n                    return new AST_RegExp(args);\n                } else if (rx) {\n                    // support legacy RegExp\n                    args.value = M.regex && M.raw ? M.raw : val;\n                    return new AST_RegExp(args);\n                }\n                switch (typeof val) {\n                  case \"string\":\n                    args.value = val;\n                    return new AST_String(args);\n                  case \"number\":\n                    if (isNaN(val)) return new AST_NaN(args);\n                    var negate, node;\n                    if (isFinite(val)) {\n                        negate = 1 / val < 0;\n                        args.value = negate ? -val : val;\n                        node = new AST_Number(args);\n                    } else {\n                        negate = val < 0;\n                        node = new AST_Infinity(args);\n                    }\n                    return negate ? new AST_UnaryPrefix({\n                        start: args.start,\n                        end: args.end,\n                        operator: \"-\",\n                        expression: node,\n                    }) : node;\n                  case \"boolean\":\n                    return new (val ? AST_True : AST_False)(args);\n                }\n            },\n            TemplateLiteral: function(M) {\n                return new AST_Template({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    expressions: M.expressions.map(from_moz),\n                    strings: M.quasis.map(function(el) {\n                        return el.value.raw;\n                    }),\n                });\n            },\n            TaggedTemplateExpression: function(M) {\n                var tmpl = from_moz(M.quasi);\n                tmpl.start = my_start_token(M);\n                tmpl.end = my_end_token(M);\n                tmpl.tag = from_moz(M.tag);\n                return tmpl;\n            },\n            Identifier: function(M) {\n                var p, level = FROM_MOZ_STACK.length - 1;\n                do {\n                    p = FROM_MOZ_STACK[--level];\n                } while (p.type == \"ArrayPattern\"\n                    || p.type == \"AssignmentPattern\" && p.left === FROM_MOZ_STACK[level + 1]\n                    || p.type == \"ObjectPattern\"\n                    || p.type == \"Property\" && p.value === FROM_MOZ_STACK[level + 1]\n                    || p.type == \"VariableDeclarator\" && p.id === FROM_MOZ_STACK[level + 1]);\n                var ctor = AST_SymbolRef;\n                switch (p.type) {\n                  case \"ArrowFunctionExpression\":\n                    if (p.body !== FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolFunarg;\n                    break;\n                  case \"BreakStatement\":\n                  case \"ContinueStatement\":\n                    ctor = AST_LabelRef;\n                    break;\n                  case \"CatchClause\":\n                    ctor = AST_SymbolCatch;\n                    break;\n                  case \"ClassDeclaration\":\n                    if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolDefClass;\n                    break;\n                  case \"ClassExpression\":\n                    if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolClass;\n                    break;\n                  case \"FunctionDeclaration\":\n                    ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolDefun : AST_SymbolFunarg;\n                    break;\n                  case \"FunctionExpression\":\n                    ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolLambda : AST_SymbolFunarg;\n                    break;\n                  case \"LabeledStatement\":\n                    ctor = AST_Label;\n                    break;\n                  case \"VariableDeclaration\":\n                    ctor = {\n                        const: AST_SymbolConst,\n                        let: AST_SymbolLet,\n                    }[p.kind] || AST_SymbolVar;\n                    break;\n                }\n                return new ctor({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: M.name,\n                });\n            },\n            Super: function(M) {\n                return new AST_Super({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: \"super\",\n                });\n            },\n            ThisExpression: function(M) {\n                return new AST_This({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: \"this\",\n                });\n            },\n            ParenthesizedExpression: function(M) {\n                var node = from_moz(M.expression);\n                if (!node.start.parens) node.start.parens = [];\n                node.start.parens.push(my_start_token(M));\n                if (!node.end.parens) node.end.parens = [];\n                node.end.parens.push(my_end_token(M));\n                return node;\n            },\n            ChainExpression: function(M) {\n                var node = from_moz(M.expression);\n                node.terminal = true;\n                return node;\n            },\n        };\n\n        MOZ_TO_ME.UpdateExpression =\n        MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n            var prefix = \"prefix\" in M ? M.prefix\n                : M.type == \"UnaryExpression\" ? true : false;\n            return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                operator   : M.operator,\n                expression : from_moz(M.argument)\n            });\n        };\n\n        map(\"EmptyStatement\", AST_EmptyStatement);\n        map(\"ExpressionStatement\", AST_SimpleStatement, \"expression>body\");\n        map(\"BlockStatement\", AST_BlockStatement, \"body@body\");\n        map(\"IfStatement\", AST_If, \"test>condition, consequent>body, alternate>alternative\");\n        map(\"LabeledStatement\", AST_LabeledStatement, \"label>label, body>body\");\n        map(\"BreakStatement\", AST_Break, \"label>label\");\n        map(\"ContinueStatement\", AST_Continue, \"label>label\");\n        map(\"WithStatement\", AST_With, \"object>expression, body>body\");\n        map(\"SwitchStatement\", AST_Switch, \"discriminant>expression, cases@body\");\n        map(\"ReturnStatement\", AST_Return, \"argument>value\");\n        map(\"ThrowStatement\", AST_Throw, \"argument>value\");\n        map(\"WhileStatement\", AST_While, \"test>condition, body>body\");\n        map(\"DoWhileStatement\", AST_Do, \"test>condition, body>body\");\n        map(\"ForStatement\", AST_For, \"init>init, test>condition, update>step, body>body\");\n        map(\"ForInStatement\", AST_ForIn, \"left>init, right>object, body>body\");\n        map(\"DebuggerStatement\", AST_Debugger);\n        map(\"VariableDeclarator\", AST_VarDef, \"id>name, init>value\");\n        map(\"CatchClause\", AST_Catch, \"param>argname, body%body\");\n\n        map(\"BinaryExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n        map(\"LogicalExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n        map(\"AssignmentExpression\", AST_Assign, \"operator=operator, left>left, right>right\");\n        map(\"AssignmentPattern\", AST_DefaultValue, \"left>name, right>value\");\n        map(\"ConditionalExpression\", AST_Conditional, \"test>condition, consequent>consequent, alternate>alternative\");\n        map(\"NewExpression\", AST_New, \"callee>expression, arguments@args, pure=pure\");\n        map(\"CallExpression\", AST_Call, \"callee>expression, arguments@args, optional=optional, pure=pure\");\n        map(\"SequenceExpression\", AST_Sequence, \"expressions@expressions\");\n        map(\"SpreadElement\", AST_Spread, \"argument>expression\");\n        map(\"ObjectExpression\", AST_Object, \"properties@properties\");\n        map(\"AwaitExpression\", AST_Await, \"argument>expression\");\n        map(\"YieldExpression\", AST_Yield, \"argument>expression, delegate=nested\");\n\n        def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n            return to_moz_scope(\"Program\", M);\n        });\n\n        def_to_moz(AST_LambdaDefinition, function To_Moz_FunctionDeclaration(M) {\n            var params = M.argnames.map(to_moz);\n            if (M.rest) params.push({\n                type: \"RestElement\",\n                argument: to_moz(M.rest),\n            });\n            return {\n                type: \"FunctionDeclaration\",\n                id: to_moz(M.name),\n                async: is_async(M),\n                generator: is_generator(M),\n                params: params,\n                body: to_moz_scope(\"BlockStatement\", M),\n            };\n        });\n\n        def_to_moz(AST_Lambda, function To_Moz_FunctionExpression(M) {\n            var params = M.argnames.map(to_moz);\n            if (M.rest) params.push({\n                type: \"RestElement\",\n                argument: to_moz(M.rest),\n            });\n            if (is_arrow(M)) return {\n                type: \"ArrowFunctionExpression\",\n                async: is_async(M),\n                params: params,\n                body: M.value ? to_moz(M.value) : to_moz_scope(\"BlockStatement\", M),\n            };\n            return {\n                type: \"FunctionExpression\",\n                id: to_moz(M.name),\n                async: is_async(M),\n                generator: is_generator(M),\n                params: params,\n                body: to_moz_scope(\"BlockStatement\", M),\n            };\n        });\n\n        def_to_moz(AST_DefClass, function To_Moz_ClassDeclaration(M) {\n            return {\n                type: \"ClassDeclaration\",\n                id: to_moz(M.name),\n                superClass: to_moz(M.extends),\n                body: {\n                    type: \"ClassBody\",\n                    body: M.properties.map(to_moz),\n                },\n            };\n        });\n\n        def_to_moz(AST_ClassExpression, function To_Moz_ClassExpression(M) {\n            return {\n                type: \"ClassExpression\",\n                id: to_moz(M.name),\n                superClass: to_moz(M.extends),\n                body: {\n                    type: \"ClassBody\",\n                    body: M.properties.map(to_moz),\n                },\n            };\n        });\n\n        function To_Moz_MethodDefinition(kind) {\n            return function(M) {\n                var computed = M.key instanceof AST_Node;\n                var key = computed ? to_moz(M.key) : M.private ? {\n                    type: \"PrivateIdentifier\",\n                    name: M.key.slice(1),\n                } : {\n                    type: \"Literal\",\n                    value: M.key,\n                };\n                return {\n                    type: \"MethodDefinition\",\n                    kind: kind,\n                    computed: computed,\n                    key: key,\n                    static: M.static,\n                    value: to_moz(M.value),\n                };\n            };\n        }\n        def_to_moz(AST_ClassGetter, To_Moz_MethodDefinition(\"get\"));\n        def_to_moz(AST_ClassSetter, To_Moz_MethodDefinition(\"set\"));\n        def_to_moz(AST_ClassMethod, To_Moz_MethodDefinition(\"method\"));\n\n        def_to_moz(AST_ClassField, function To_Moz_PropertyDefinition(M) {\n            var computed = M.key instanceof AST_Node;\n            var key = computed ? to_moz(M.key) : M.private ? {\n                type: \"PrivateIdentifier\",\n                name: M.key.slice(1),\n            } : {\n                type: \"Literal\",\n                value: M.key,\n            };\n            return {\n                type: \"PropertyDefinition\",\n                computed: computed,\n                key: key,\n                static: M.static,\n                value: to_moz(M.value),\n            };\n        });\n\n        def_to_moz(AST_ClassInit, function To_Moz_StaticBlock(M) {\n            return to_moz_scope(\"StaticBlock\", M.value);\n        });\n\n        function To_Moz_ForOfStatement(is_await) {\n            return function(M) {\n                return {\n                    type: \"ForOfStatement\",\n                    await: is_await,\n                    left: to_moz(M.init),\n                    right: to_moz(M.object),\n                    body: to_moz(M.body),\n                };\n            };\n        }\n        def_to_moz(AST_ForAwaitOf, To_Moz_ForOfStatement(true));\n        def_to_moz(AST_ForOf, To_Moz_ForOfStatement(false));\n\n        def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n            return {\n                type: \"ExpressionStatement\",\n                expression: set_moz_loc(M, {\n                    type: \"Literal\",\n                    value: M.value,\n                }),\n            };\n        });\n\n        def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n            return {\n                type: \"SwitchCase\",\n                test: to_moz(M.expression),\n                consequent: M.body.map(to_moz),\n            };\n        });\n\n        def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n            return {\n                type: \"TryStatement\",\n                block: to_moz_block(M),\n                handler: to_moz(M.bcatch),\n                guardedHandlers: [],\n                finalizer: to_moz(M.bfinally),\n            };\n        });\n\n        def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n            return {\n                type: \"CatchClause\",\n                param: to_moz(M.argname),\n                guard: null,\n                body: to_moz_block(M),\n            };\n        });\n\n        def_to_moz(AST_ExportDeclaration, function To_Moz_ExportNamedDeclaration_declaration(M) {\n            return {\n                type: \"ExportNamedDeclaration\",\n                declaration: to_moz(M.body),\n            };\n        });\n\n        def_to_moz(AST_ExportDefault, function To_Moz_ExportDefaultDeclaration(M) {\n            return {\n                type: \"ExportDefaultDeclaration\",\n                declaration: to_moz(M.body),\n            };\n        });\n\n        def_to_moz(AST_ExportForeign, function To_Moz_ExportAllDeclaration_ExportNamedDeclaration(M) {\n            if (M.keys[0].value == \"*\") return {\n                type: \"ExportAllDeclaration\",\n                exported: M.aliases[0].value == \"*\" ? null : to_moz_alias(M.aliases[0]),\n                source: to_moz(M.path),\n            };\n            var specifiers = [];\n            for (var i = 0; i < M.aliases.length; i++) {\n                specifiers.push(set_moz_loc({\n                    start: M.keys[i].start,\n                    end: M.aliases[i].end,\n                }, {\n                    type: \"ExportSpecifier\",\n                    local: to_moz_alias(M.keys[i]),\n                    exported: to_moz_alias(M.aliases[i]),\n                }));\n            }\n            return {\n                type: \"ExportNamedDeclaration\",\n                specifiers: specifiers,\n                source: to_moz(M.path),\n            };\n        });\n\n        def_to_moz(AST_ExportReferences, function To_Moz_ExportNamedDeclaration_specifiers(M) {\n            return {\n                type: \"ExportNamedDeclaration\",\n                specifiers: M.properties.map(function(prop) {\n                    return set_moz_loc({\n                        start: prop.start,\n                        end: prop.alias.end,\n                    }, {\n                        type: \"ExportSpecifier\",\n                        local: to_moz(prop),\n                        exported: to_moz_alias(prop.alias),\n                    });\n                }),\n            };\n        });\n\n        def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n            var specifiers = M.properties ? M.properties.map(function(prop) {\n                return set_moz_loc({\n                    start: prop.key.start,\n                    end: prop.end,\n                }, {\n                    type: \"ImportSpecifier\",\n                    local: to_moz(prop),\n                    imported: to_moz_alias(prop.key),\n                });\n            }) : [];\n            if (M.all) specifiers.unshift(set_moz_loc(M.all, {\n                type: \"ImportNamespaceSpecifier\",\n                local: to_moz(M.all),\n            }));\n            if (M.default) specifiers.unshift(set_moz_loc(M.default, {\n                type: \"ImportDefaultSpecifier\",\n                local: to_moz(M.default),\n            }));\n            return {\n                type: \"ImportDeclaration\",\n                specifiers: specifiers,\n                source: to_moz(M.path),\n            };\n        });\n\n        def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {\n            return {\n                type: \"VariableDeclaration\",\n                kind: M.TYPE.toLowerCase(),\n                declarations: M.definitions.map(to_moz),\n            };\n        });\n\n        def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n            var computed = M instanceof AST_Sub;\n            var expr = {\n                type: \"MemberExpression\",\n                object: to_moz(M.expression),\n                computed: computed,\n                optional: M.optional,\n                property: computed ? to_moz(M.property) : {\n                    type: \"Identifier\",\n                    name: M.property,\n                },\n            };\n            return M.terminal ? {\n                type: \"ChainExpression\",\n                expression: expr,\n            } : expr;\n        });\n\n        def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n            return {\n                type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n                operator: M.operator,\n                prefix: M instanceof AST_UnaryPrefix,\n                argument: to_moz(M.expression)\n            };\n        });\n\n        def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n            return {\n                type: M.operator == \"&&\" || M.operator == \"||\" ? \"LogicalExpression\" : \"BinaryExpression\",\n                left: to_moz(M.left),\n                operator: M.operator,\n                right: to_moz(M.right)\n            };\n        });\n\n        def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n            return {\n                type: \"ArrayExpression\",\n                elements: M.elements.map(to_moz),\n            };\n        });\n\n        def_to_moz(AST_DestructuredArray, function To_Moz_ArrayPattern(M) {\n            var elements = M.elements.map(to_moz);\n            if (M.rest) elements.push({\n                type: \"RestElement\",\n                argument: to_moz(M.rest),\n            });\n            return {\n                type: \"ArrayPattern\",\n                elements: elements,\n            };\n        });\n\n        def_to_moz(AST_DestructuredKeyVal, function To_Moz_Property(M) {\n            var computed = M.key instanceof AST_Node;\n            var key = computed ? to_moz(M.key) : {\n                type: \"Literal\",\n                value: M.key,\n            };\n            return {\n                type: \"Property\",\n                kind: \"init\",\n                computed: computed,\n                key: key,\n                value: to_moz(M.value),\n            };\n        });\n\n        def_to_moz(AST_DestructuredObject, function To_Moz_ObjectPattern(M) {\n            var props = M.properties.map(to_moz);\n            if (M.rest) props.push({\n                type: \"RestElement\",\n                argument: to_moz(M.rest),\n            });\n            return {\n                type: \"ObjectPattern\",\n                properties: props,\n            };\n        });\n\n        def_to_moz(AST_ObjectProperty, function To_Moz_Property(M) {\n            var computed = M.key instanceof AST_Node;\n            var key = computed ? to_moz(M.key) : {\n                type: \"Literal\",\n                value: M.key,\n            };\n            var kind;\n            if (M instanceof AST_ObjectKeyVal) {\n                kind = \"init\";\n            } else if (M instanceof AST_ObjectGetter) {\n                kind = \"get\";\n            } else if (M instanceof AST_ObjectSetter) {\n                kind = \"set\";\n            }\n            return {\n                type: \"Property\",\n                kind: kind,\n                computed: computed,\n                method: M instanceof AST_ObjectMethod,\n                key: key,\n                value: to_moz(M.value),\n            };\n        });\n\n        def_to_moz(AST_Symbol, function To_Moz_Identifier(M) {\n            var def = M.definition();\n            return {\n                type: \"Identifier\",\n                name: def && def.mangled_name || M.name,\n            };\n        });\n\n        def_to_moz(AST_Super, function To_Moz_Super() {\n            return { type: \"Super\" };\n        });\n\n        def_to_moz(AST_This, function To_Moz_ThisExpression() {\n            return { type: \"ThisExpression\" };\n        });\n\n        def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n            return {\n                type: \"MetaProperty\",\n                meta: {\n                    type: \"Identifier\",\n                    name: \"new\",\n                },\n                property: {\n                    type: \"Identifier\",\n                    name: \"target\",\n                },\n            };\n        });\n\n        def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n            var flags = M.value.toString().match(/\\/([gimuy]*)$/)[1];\n            var value = \"/\" + M.value.raw_source + \"/\" + flags;\n            return {\n                type: \"Literal\",\n                value: value,\n                raw: value,\n                regex: {\n                    pattern: M.value.raw_source,\n                    flags: flags,\n                },\n            };\n        });\n\n        def_to_moz(AST_BigInt, function To_Moz_BigInt(M) {\n            var value = M.value;\n            return {\n                type: \"Literal\",\n                bigint: value.slice(0, -1),\n                raw: value,\n            };\n        });\n\n        function To_Moz_Literal(M) {\n            var value = M.value;\n            if (typeof value === \"number\" && (value < 0 || (value === 0 && 1 / value < 0))) {\n                return {\n                    type: \"UnaryExpression\",\n                    operator: \"-\",\n                    prefix: true,\n                    argument: {\n                        type: \"Literal\",\n                        value: -value,\n                        raw: M.start.raw,\n                    },\n                };\n            }\n            return {\n                type: \"Literal\",\n                value: value,\n                raw: M.start.raw,\n            };\n        }\n        def_to_moz(AST_Boolean, To_Moz_Literal);\n        def_to_moz(AST_Constant, To_Moz_Literal);\n        def_to_moz(AST_Null, To_Moz_Literal);\n\n        def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n            return {\n                type: \"Identifier\",\n                name: String(M.value),\n            };\n        });\n\n        def_to_moz(AST_Template, function To_Moz_TemplateLiteral_TaggedTemplateExpression(M) {\n            var last = M.strings.length - 1;\n            var tmpl = {\n                type: \"TemplateLiteral\",\n                expressions: M.expressions.map(to_moz),\n                quasis: M.strings.map(function(str, index) {\n                    return {\n                        type: \"TemplateElement\",\n                        tail: index == last,\n                        value: { raw: str },\n                    };\n                }),\n            };\n            if (!M.tag) return tmpl;\n            return {\n                type: \"TaggedTemplateExpression\",\n                tag: to_moz(M.tag),\n                quasi: tmpl,\n            };\n        });\n\n        AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n        AST_Hole.DEFMETHOD(\"to_mozilla_ast\", return_null);\n        AST_Node.DEFMETHOD(\"to_mozilla_ast\", function() {\n            throw new Error(\"Cannot convert AST_\" + this.TYPE);\n        });\n\n        /* -----[ tools ]----- */\n\n        function normalize_directives(body) {\n            for (var i = 0; i < body.length; i++) {\n                var stat = body[i];\n                if (!(stat instanceof AST_SimpleStatement)) break;\n                var node = stat.body;\n                if (!(node instanceof AST_String)) break;\n                if (stat.start.pos !== node.start.pos) break;\n                body[i] = new AST_Directive(node);\n            }\n            return body;\n        }\n\n        function raw_token(moznode) {\n            if (moznode.type == \"Literal\") {\n                return moznode.raw != null ? moznode.raw : moznode.value + \"\";\n            }\n        }\n\n        function my_start_token(moznode) {\n            var loc = moznode.loc, start = loc && loc.start;\n            var range = moznode.range;\n            return new AST_Token({\n                file    : loc && loc.source,\n                line    : start && start.line,\n                col     : start && start.column,\n                pos     : range ? range[0] : moznode.start,\n                endline : start && start.line,\n                endcol  : start && start.column,\n                endpos  : range ? range[0] : moznode.start,\n                raw     : raw_token(moznode),\n            });\n        }\n\n        function my_end_token(moznode) {\n            var loc = moznode.loc, end = loc && loc.end;\n            var range = moznode.range;\n            return new AST_Token({\n                file    : loc && loc.source,\n                line    : end && end.line,\n                col     : end && end.column,\n                pos     : range ? range[1] : moznode.end,\n                endline : end && end.line,\n                endcol  : end && end.column,\n                endpos  : range ? range[1] : moznode.end,\n                raw     : raw_token(moznode),\n            });\n        }\n\n        function read_name(M) {\n            return \"\" + M[M.type == \"Identifier\" ? \"name\" : \"value\"];\n        }\n\n        function map(moztype, mytype, propmap) {\n            var moz_to_me = [\n                \"start: my_start_token(M)\",\n                \"end: my_end_token(M)\",\n            ];\n            var me_to_moz = [\n                \"type: \" + JSON.stringify(moztype),\n            ];\n\n            if (propmap) propmap.split(/\\s*,\\s*/).forEach(function(prop) {\n                var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);\n                if (!m) throw new Error(\"Can't understand property map: \" + prop);\n                var moz = m[1], how = m[2], my = m[3];\n                switch (how) {\n                  case \"@\":\n                    moz_to_me.push(my + \": M.\" + moz + \".map(from_moz)\");\n                    me_to_moz.push(moz + \": M.\" +  my + \".map(to_moz)\");\n                    break;\n                  case \">\":\n                    moz_to_me.push(my + \": from_moz(M.\" + moz + \")\");\n                    me_to_moz.push(moz + \": to_moz(M.\" + my + \")\");\n                    break;\n                  case \"=\":\n                    moz_to_me.push(my + \": M.\" + moz);\n                    me_to_moz.push(moz + \": M.\" + my);\n                    break;\n                  case \"%\":\n                    moz_to_me.push(my + \": from_moz(M.\" + moz + \").body\");\n                    me_to_moz.push(moz + \": to_moz_block(M)\");\n                    break;\n                  default:\n                    throw new Error(\"Can't understand operator in propmap: \" + prop);\n                }\n            });\n\n            MOZ_TO_ME[moztype] = new Function(\"U2\", \"my_start_token\", \"my_end_token\", \"from_moz\", [\n                \"return function From_Moz_\" + moztype + \"(M) {\",\n                \"    return new U2.AST_\" + mytype.TYPE + \"({\",\n                moz_to_me.join(\",\\n\"),\n                \"    });\",\n                \"};\",\n            ].join(\"\\n\"))(exports, my_start_token, my_end_token, from_moz);\n            def_to_moz(mytype, new Function(\"to_moz\", \"to_moz_block\", \"to_moz_scope\", [\n                \"return function To_Moz_\" + moztype + \"(M) {\",\n                \"    return {\",\n                me_to_moz.join(\",\\n\"),\n                \"    };\",\n                \"};\",\n            ].join(\"\\n\"))(to_moz, to_moz_block, to_moz_scope));\n        }\n\n        var FROM_MOZ_STACK = null;\n\n        function from_moz(moz) {\n            FROM_MOZ_STACK.push(moz);\n            var node = null;\n            if (moz) {\n                if (!HOP(MOZ_TO_ME, moz.type)) throw new Error(\"Unsupported type: \" + moz.type);\n                node = MOZ_TO_ME[moz.type](moz);\n            }\n            FROM_MOZ_STACK.pop();\n            return node;\n        }\n\n        function from_moz_alias(moz) {\n            return new AST_String({\n                start: my_start_token(moz),\n                value: read_name(moz),\n                end: my_end_token(moz),\n            });\n        }\n\n        AST_Node.from_mozilla_ast = function(node) {\n            var save_stack = FROM_MOZ_STACK;\n            FROM_MOZ_STACK = [];\n            var ast = from_moz(node);\n            FROM_MOZ_STACK = save_stack;\n            ast.walk(new TreeWalker(function(node) {\n                if (node instanceof AST_LabelRef) {\n                    for (var level = 0, parent; parent = this.parent(level); level++) {\n                        if (parent instanceof AST_Scope) break;\n                        if (parent instanceof AST_LabeledStatement && parent.label.name == node.name) {\n                            node.thedef = parent.label;\n                            break;\n                        }\n                    }\n                    if (!node.thedef) {\n                        var s = node.start;\n                        js_error(\"Undefined label \" + node.name, s.file, s.line, s.col, s.pos);\n                    }\n                }\n            }));\n            return ast;\n        };\n\n        function set_moz_loc(mynode, moznode) {\n            var start = mynode.start;\n            var end = mynode.end;\n            if (start.pos != null && end.endpos != null) {\n                moznode.range = [start.pos, end.endpos];\n            }\n            if (start.line) {\n                moznode.loc = {\n                    start: {line: start.line, column: start.col},\n                    end: end.endline ? {line: end.endline, column: end.endcol} : null,\n                };\n                if (start.file) {\n                    moznode.loc.source = start.file;\n                }\n            }\n            return moznode;\n        }\n\n        function def_to_moz(mytype, handler) {\n            mytype.DEFMETHOD(\"to_mozilla_ast\", function() {\n                return set_moz_loc(this, handler(this));\n            });\n        }\n\n        function to_moz(node) {\n            return node != null ? node.to_mozilla_ast() : null;\n        }\n\n        function to_moz_alias(alias) {\n            return is_identifier_string(alias.value) ? set_moz_loc(alias, {\n                type: \"Identifier\",\n                name: alias.value,\n            }) : to_moz(alias);\n        }\n\n        function to_moz_block(node) {\n            return {\n                type: \"BlockStatement\",\n                body: node.body.map(to_moz),\n            };\n        }\n\n        function to_moz_scope(type, node) {\n            var body = node.body.map(to_moz);\n            if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n                body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n            }\n            return {\n                type: type,\n                body: body,\n            };\n        }\n    })();\n});"]}