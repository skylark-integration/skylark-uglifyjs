{"version":3,"sources":["mozilla-ast.js"],"names":["define","m_ast","AST_Accessor","AST_Array","AST_Arrow","AST_Assign","AST_Atom","AST_Await","AST_BigInt","AST_Binary","AST_Block","AST_BlockStatement","AST_Boolean","AST_Break","AST_Call","AST_Case","AST_Catch","AST_Chain","AST_Class","AST_ClassStaticBlock","AST_ClassExpression","AST_ClassGetter","AST_ClassInit","AST_ClassProperty","AST_ClassPrivateProperty","AST_ClassSetter","AST_ConciseMethod","AST_Conditional","AST_Const","AST_Constant","AST_Continue","AST_Debugger","AST_Default","AST_DefaultAssign","AST_DefClass","AST_Definitions","AST_Defun","AST_Destructuring","AST_Directive","AST_Do","AST_Dot","AST_DotHash","AST_EmptyStatement","AST_Expansion","AST_Export","AST_ExportDeclaration","AST_False","AST_Finally","AST_For","AST_ForIn","AST_ForOf","AST_Function","AST_Hole","AST_If","AST_Import","AST_ImportMeta","AST_Label","AST_LabeledStatement","AST_LabelRef","AST_Lambda","AST_Let","AST_NameMapping","AST_New","AST_NewTarget","AST_Node","AST_Null","AST_Number","AST_Object","AST_ObjectGetter","AST_ObjectKeyVal","AST_ObjectProperty","AST_ObjectSetter","AST_PrefixedTemplateString","AST_PrivateGetter","AST_PrivateMethod","AST_PrivateSetter","AST_PrivateIn","AST_PropAccess","AST_RegExp","AST_Return","AST_Sequence","AST_SimpleStatement","AST_Statement","AST_String","AST_Sub","AST_Super","AST_Switch","AST_SwitchBranch","AST_Symbol","AST_SymbolCatch","AST_SymbolClass","AST_SymbolClassProperty","AST_SymbolPrivateProperty","AST_SymbolConst","AST_SymbolDefClass","AST_SymbolDefun","AST_SymbolExport","AST_SymbolExportForeign","AST_SymbolFunarg","AST_SymbolImport","AST_SymbolImportForeign","AST_SymbolLambda","AST_SymbolLet","AST_SymbolMethod","AST_SymbolRef","AST_SymbolVar","AST_TemplateSegment","AST_TemplateString","AST_This","AST_Throw","AST_Token","AST_Toplevel","AST_True","AST_Try","AST_TryBlock","AST_Unary","AST_UnaryPostfix","AST_UnaryPrefix","AST_Var","AST_VarDef","AST_While","AST_With","AST_Yield","is_generator","is_arrow","is_async","MOZ_TO_ME","Program","M","start","my_start_token","end","my_end_token","body","normalize_directives","map","from_moz","ArrowFunctionExpression","argnames","rest","params","forEach","param","type","argument","push","fn","async","AST_AsyncArrow","node","value","FunctionDeclaration","ctor","generator","AST_AsyncGeneratorDefun","AST_AsyncDefun","AST_GeneratorDefun","name","id","FunctionExpression","AST_AsyncGeneratorFunction","AST_AsyncFunction","AST_GeneratorFunction","ClassDeclaration","extends","superClass","properties","ClassExpression","MethodDefinition","key","internal","computed","read_name","AST_ClassMethod","kind","private","static","PropertyDefinition","AST_ClassField","StaticBlock","AST_ClassInitBlock","ForOfStatement","await","AST_ForAwaitOf","init","left","object","right","TryStatement","handlers","handler","length","guardedHandlers","Error","block","bcatch","bfinally","finalizer","Property","args","method","AST_ObjectMethod","ArrayExpression","elements","elem","ArrayPattern","el","AST_DestructuredArray","ObjectPattern","props","prop","AST_DestructuredKeyVal","AST_DestructuredObject","MemberExpression","optional","expression","property","MetaProperty","expr","meta","SwitchCase","test","consequent","ExportAllDeclaration","AST_ExportForeign","aliases","exported","from_moz_alias","keys","path","source","ExportDefaultDeclaration","decl","declaration","CTOR","AST_ExportDefault","ExportNamedDeclaration","specifiers","local","AST_ExportReferences","sym","alias","ImportDeclaration","all","def","imported","default","ImportExpression","arg","VariableDeclaration","const","let","definitions","declarations","Literal","bigint","toLowerCase","val","rx","regex","pattern","RegExp","flags","raw_source","raw","isNaN","AST_NaN","isFinite","negate","AST_Infinity","operator","TemplateLiteral","AST_Template","expressions","strings","quasis","TaggedTemplateExpression","tmpl","quasi","tag","Identifier","p","level","FROM_MOZ_STACK","Super","ThisExpression","ParenthesizedExpression","parens","ChainExpression","terminal","To_Moz_MethodDefinition","to_moz","slice","To_Moz_ForOfStatement","is_await","To_Moz_Literal","prefix","i","stat","pos","raw_token","moznode","loc","range","file","line","col","column","endline","endcol","endpos","moztype","mytype","propmap","moz_to_me","me_to_moz","JSON","stringify","split","m","exec","moz","how","my","Function","TYPE","join","exports","def_to_moz","to_moz_block","to_moz_scope","UpdateExpression","UnaryExpression","AST_DefaultValue","AST_Spread","AST_LambdaDefinition","set_moz_loc","argname","guard","to_moz_alias","unshift","definition","mangled_name","toString","match","String","last","str","index","tail","DEFMETHOD","prototype","to_mozilla_ast","return_null","this","HOP","pop","mynode","is_identifier_string","from_mozilla_ast","save_stack","ast","walk","TreeWalker","parent","AST_Scope","label","thedef","s","js_error"],"mappings":"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","file":"../mozilla-ast.js","sourcesContent":["define([\n    \"./ast\"\n],function(m_ast){\n    /***********************************************************************\n\n      A JavaScript tokenizer / parser / beautifier / compressor.\n      https://github.com/mishoo/UglifyJS\n\n      -------------------------------- (C) ---------------------------------\n\n                               Author: Mihai Bazon\n                             <mihai.bazon@gmail.com>\n                           http://mihai.bazon.net/blog\n\n      Distributed under the BSD license:\n\n        Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n        Redistribution and use in source and binary forms, with or without\n        modification, are permitted provided that the following conditions\n        are met:\n\n            * Redistributions of source code must retain the above\n              copyright notice, this list of conditions and the following\n              disclaimer.\n\n            * Redistributions in binary form must reproduce the above\n              copyright notice, this list of conditions and the following\n              disclaimer in the documentation and/or other materials\n              provided with the distribution.\n\n        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n        EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n        IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n        PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n        LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n        OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n        PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n        PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n        THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n        TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n        THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n        SUCH DAMAGE.\n\n     ***********************************************************************/\n\n    \"use strict\";\n\n    const {\n        AST_Accessor,\n        AST_Array,\n        AST_Arrow,\n        AST_Assign,\n        AST_Atom,\n        AST_Await,\n        AST_BigInt,\n        AST_Binary,\n        AST_Block,\n        AST_BlockStatement,\n        AST_Boolean,\n        AST_Break,\n        AST_Call,\n        AST_Case,\n        AST_Catch,\n        AST_Chain,\n        AST_Class,\n        AST_ClassStaticBlock,\n        AST_ClassExpression,\n        AST_ClassGetter,\n        AST_ClassInit,\n        AST_ClassProperty,\n        AST_ClassPrivateProperty,\n        AST_ClassSetter,\n        AST_ConciseMethod,\n        AST_Conditional,\n        AST_Const,\n        AST_Constant,\n        AST_Continue,\n        AST_Debugger,\n        AST_Default,\n        AST_DefaultAssign,\n        AST_DefClass,\n        AST_Definitions,\n        AST_Defun,\n        AST_Destructuring,\n        AST_Directive,\n        AST_Do,\n        AST_Dot,\n        AST_DotHash,\n        AST_EmptyStatement,\n        AST_Expansion,\n        AST_Export,\n        AST_ExportDeclaration,\n        AST_False,\n        AST_Finally,\n        AST_For,\n        AST_ForIn,\n        AST_ForOf,\n        AST_Function,\n        AST_Hole,\n        AST_If,\n        AST_Import,\n        AST_ImportMeta,\n        AST_Label,\n        AST_LabeledStatement,\n        AST_LabelRef,\n        AST_Lambda,\n        AST_Let,\n        AST_NameMapping,\n        AST_New,\n        AST_NewTarget,\n        AST_Node,\n        AST_Null,\n        AST_Number,\n        AST_Object,\n        AST_ObjectGetter,\n        AST_ObjectKeyVal,\n        AST_ObjectProperty,\n        AST_ObjectSetter,\n        AST_PrefixedTemplateString,\n        AST_PrivateGetter,\n        AST_PrivateMethod,\n        AST_PrivateSetter,\n        AST_PrivateIn,\n        AST_PropAccess,\n        AST_RegExp,\n        AST_Return,\n        AST_Sequence,\n        AST_SimpleStatement,\n        AST_Statement,\n        AST_String,\n        AST_Sub,\n        AST_Super,\n        AST_Switch,\n        AST_SwitchBranch,\n        AST_Symbol,\n        AST_SymbolCatch,\n        AST_SymbolClass,\n        AST_SymbolClassProperty,\n        AST_SymbolPrivateProperty,\n        AST_SymbolConst,\n        AST_SymbolDefClass,\n        AST_SymbolDefun,\n        AST_SymbolExport,\n        AST_SymbolExportForeign,\n        AST_SymbolFunarg,\n        AST_SymbolImport,\n        AST_SymbolImportForeign,\n        AST_SymbolLambda,\n        AST_SymbolLet,\n        AST_SymbolMethod,\n        AST_SymbolRef,\n        AST_SymbolVar,\n        AST_TemplateSegment,\n        AST_TemplateString,\n        AST_This,\n        AST_Throw,\n        AST_Token,\n        AST_Toplevel,\n        AST_True,\n        AST_Try,\n        AST_TryBlock,\n        AST_Unary,\n        AST_UnaryPostfix,\n        AST_UnaryPrefix,\n        AST_Var,\n        AST_VarDef,\n        AST_While,\n        AST_With,\n        AST_Yield,\n\n        is_generator,\n        is_arrow,\n        is_async\n    } = m_ast;\n\n    (function() {\n        var MOZ_TO_ME = {\n            Program: function(M) {\n                return new AST_Toplevel({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    body: normalize_directives(M.body.map(from_moz)),\n                });\n            },\n            ArrowFunctionExpression: function(M) {\n                var argnames = [], rest = null;\n                M.params.forEach(function(param) {\n                    if (param.type == \"RestElement\") {\n                        rest = from_moz(param.argument);\n                    } else {\n                        argnames.push(from_moz(param));\n                    }\n                });\n                var fn = new (M.async ? AST_AsyncArrow : AST_Arrow)({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    argnames: argnames,\n                    rest: rest,\n                });\n                var node = from_moz(M.body);\n                if (node instanceof AST_BlockStatement) {\n                    fn.body = normalize_directives(node.body);\n                    fn.value = null;\n                } else {\n                    fn.body = [];\n                    fn.value = node;\n                }\n                return fn;\n            },\n            FunctionDeclaration: function(M) {\n                var ctor;\n                if (M.async) {\n                    ctor = M.generator ? AST_AsyncGeneratorDefun : AST_AsyncDefun;\n                } else {\n                    ctor = M.generator ? AST_GeneratorDefun : AST_Defun;\n                }\n                var argnames = [], rest = null;\n                M.params.forEach(function(param) {\n                    if (param.type == \"RestElement\") {\n                        rest = from_moz(param.argument);\n                    } else {\n                        argnames.push(from_moz(param));\n                    }\n                });\n                return new ctor({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: from_moz(M.id),\n                    argnames: argnames,\n                    rest: rest,\n                    body: normalize_directives(from_moz(M.body).body),\n                });\n            },\n            FunctionExpression: function(M) {\n                var ctor;\n                if (M.async) {\n                    ctor = M.generator ? AST_AsyncGeneratorFunction : AST_AsyncFunction;\n                } else {\n                    ctor = M.generator ? AST_GeneratorFunction : AST_Function;\n                }\n                var argnames = [], rest = null;\n                M.params.forEach(function(param) {\n                    if (param.type == \"RestElement\") {\n                        rest = from_moz(param.argument);\n                    } else {\n                        argnames.push(from_moz(param));\n                    }\n                });\n                return new ctor({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: from_moz(M.id),\n                    argnames: argnames,\n                    rest: rest,\n                    body: normalize_directives(from_moz(M.body).body),\n                });\n            },\n            ClassDeclaration: function(M) {\n                return new AST_DefClass({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: from_moz(M.id),\n                    extends: from_moz(M.superClass),\n                    properties: M.body.body.map(from_moz),\n                });\n            },\n            ClassExpression: function(M) {\n                return new AST_ClassExpression({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: from_moz(M.id),\n                    extends: from_moz(M.superClass),\n                    properties: M.body.body.map(from_moz),\n                });\n            },\n            MethodDefinition: function(M) {\n                var key = M.key, internal = false;\n                if (M.computed) {\n                    key = from_moz(key);\n                } else if (key.type == \"PrivateIdentifier\") {\n                    internal = true;\n                    key = \"#\" + key.name;\n                } else {\n                    key = read_name(key);\n                }\n                var ctor = AST_ClassMethod, value = from_moz(M.value);\n                switch (M.kind) {\n                  case \"get\":\n                    ctor = AST_ClassGetter;\n                    value = new AST_Accessor(value);\n                    break;\n                  case \"set\":\n                    ctor = AST_ClassSetter;\n                    value = new AST_Accessor(value);\n                    break;\n                }\n                return new ctor({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    key: key,\n                    private: internal,\n                    static: M.static,\n                    value: value,\n                });\n            },\n            PropertyDefinition: function(M) {\n                var key = M.key, internal = false;\n                if (M.computed) {\n                    key = from_moz(key);\n                } else if (key.type == \"PrivateIdentifier\") {\n                    internal = true;\n                    key = \"#\" + key.name;\n                } else {\n                    key = read_name(key);\n                }\n                return new AST_ClassField({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    key: key,\n                    private: internal,\n                    static: M.static,\n                    value: from_moz(M.value),\n                });\n            },\n            StaticBlock: function(M) {\n                var start = my_start_token(M);\n                var end = my_end_token(M);\n                return new AST_ClassInit({\n                    start: start,\n                    end: end,\n                    value: new AST_ClassInitBlock({\n                        start: start,\n                        end: end,\n                        body: normalize_directives(M.body.map(from_moz)),\n                    }),\n                });\n            },\n            ForOfStatement: function(M) {\n                return new (M.await ? AST_ForAwaitOf : AST_ForOf)({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    init: from_moz(M.left),\n                    object: from_moz(M.right),\n                    body: from_moz(M.body),\n                });\n            },\n            TryStatement: function(M) {\n                var handlers = M.handlers || [M.handler];\n                if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n                    throw new Error(\"Multiple catch clauses are not supported.\");\n                }\n                return new AST_Try({\n                    start    : my_start_token(M),\n                    end      : my_end_token(M),\n                    body     : from_moz(M.block).body,\n                    bcatch   : from_moz(handlers[0]),\n                    bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null,\n                });\n            },\n            Property: function(M) {\n                var key = M.computed ? from_moz(M.key) : read_name(M.key);\n                var args = {\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    key: key,\n                    value: from_moz(M.value),\n                };\n                if (M.kind == \"init\") return new (M.method ? AST_ObjectMethod : AST_ObjectKeyVal)(args);\n                args.value = new AST_Accessor(args.value);\n                if (M.kind == \"get\") return new AST_ObjectGetter(args);\n                if (M.kind == \"set\") return new AST_ObjectSetter(args);\n            },\n            ArrayExpression: function(M) {\n                return new AST_Array({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    elements: M.elements.map(function(elem) {\n                        return elem === null ? new AST_Hole() : from_moz(elem);\n                    }),\n                });\n            },\n            ArrayPattern: function(M) {\n                var elements = [], rest = null;\n                M.elements.forEach(function(el) {\n                    if (el === null) {\n                        elements.push(new AST_Hole());\n                    } else if (el.type == \"RestElement\") {\n                        rest = from_moz(el.argument);\n                    } else {\n                        elements.push(from_moz(el));\n                    }\n                });\n                return new AST_DestructuredArray({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    elements: elements,\n                    rest: rest,\n                });\n            },\n            ObjectPattern: function(M) {\n                var props = [], rest = null;\n                M.properties.forEach(function(prop) {\n                    if (prop.type == \"RestElement\") {\n                        rest = from_moz(prop.argument);\n                    } else {\n                        props.push(new AST_DestructuredKeyVal(from_moz(prop)));\n                    }\n                });\n                return new AST_DestructuredObject({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    properties: props,\n                    rest: rest,\n                });\n            },\n            MemberExpression: function(M) {\n                return new (M.computed ? AST_Sub : AST_Dot)({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    optional: M.optional,\n                    expression: from_moz(M.object),\n                    property: M.computed ? from_moz(M.property) : M.property.name,\n                });\n            },\n            MetaProperty: function(M) {\n                var expr = from_moz(M.meta);\n                var prop = read_name(M.property);\n                if (expr.name == \"new\" && prop == \"target\") return new AST_NewTarget({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: \"new.target\",\n                });\n                return new AST_Dot({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    expression: expr,\n                    property: prop,\n                });\n            },\n            SwitchCase: function(M) {\n                return new (M.test ? AST_Case : AST_Default)({\n                    start      : my_start_token(M),\n                    end        : my_end_token(M),\n                    expression : from_moz(M.test),\n                    body       : M.consequent.map(from_moz),\n                });\n            },\n            ExportAllDeclaration: function(M) {\n                var start = my_start_token(M);\n                var end = my_end_token(M);\n                return new AST_ExportForeign({\n                    start: start,\n                    end: end,\n                    aliases: [ M.exported ? from_moz_alias(M.exported) : new AST_String({\n                        start: start,\n                        value: \"*\",\n                        end: end,\n                    }) ],\n                    keys: [ new AST_String({\n                        start: start,\n                        value: \"*\",\n                        end: end,\n                    }) ],\n                    path: from_moz(M.source),\n                });\n            },\n            ExportDefaultDeclaration: function(M) {\n                var decl = from_moz(M.declaration);\n                if (!decl.name) switch (decl.CTOR) {\n                  case AST_AsyncDefun:\n                    decl = new AST_AsyncFunction(decl);\n                    break;\n                  case AST_AsyncGeneratorDefun:\n                    decl = new AST_AsyncGeneratorFunction(decl);\n                    break;\n                  case AST_DefClass:\n                    decl = new AST_ClassExpression(decl);\n                    break;\n                  case AST_Defun:\n                    decl = new AST_Function(decl);\n                    break;\n                  case AST_GeneratorDefun:\n                    decl = new AST_GeneratorFunction(decl);\n                    break;\n                }\n                return new AST_ExportDefault({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    body: decl,\n                });\n            },\n            ExportNamedDeclaration: function(M) {\n                if (M.declaration) return new AST_ExportDeclaration({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    body: from_moz(M.declaration),\n                });\n                if (M.source) {\n                    var aliases = [], keys = [];\n                    M.specifiers.forEach(function(prop) {\n                        aliases.push(from_moz_alias(prop.exported));\n                        keys.push(from_moz_alias(prop.local));\n                    });\n                    return new AST_ExportForeign({\n                        start: my_start_token(M),\n                        end: my_end_token(M),\n                        aliases: aliases,\n                        keys: keys,\n                        path: from_moz(M.source),\n                    });\n                }\n                return new AST_ExportReferences({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    properties: M.specifiers.map(function(prop) {\n                        var sym = new AST_SymbolExport(from_moz(prop.local));\n                        sym.alias = from_moz_alias(prop.exported);\n                        return sym;\n                    }),\n                });\n            },\n            ImportDeclaration: function(M) {\n                var start = my_start_token(M);\n                var end = my_end_token(M);\n                var all = null, def = null, props = null;\n                M.specifiers.forEach(function(prop) {\n                    var sym = new AST_SymbolImport(from_moz(prop.local));\n                    switch (prop.type) {\n                      case \"ImportDefaultSpecifier\":\n                        def = sym;\n                        def.key = new AST_String({\n                            start: start,\n                            value: \"\",\n                            end: end,\n                        });\n                        break;\n                      case \"ImportNamespaceSpecifier\":\n                        all = sym;\n                        all.key = new AST_String({\n                            start: start,\n                            value: \"*\",\n                            end: end,\n                        });\n                        break;\n                      default:\n                        sym.key = from_moz_alias(prop.imported);\n                        if (!props) props = [];\n                        props.push(sym);\n                        break;\n                    }\n                });\n                return new AST_Import({\n                    start: start,\n                    end: end,\n                    all: all,\n                    default: def,\n                    properties: props,\n                    path: from_moz(M.source),\n                });\n            },\n            ImportExpression: function(M) {\n                var start = my_start_token(M);\n                var arg = from_moz(M.source);\n                return new AST_Call({\n                    start: start,\n                    end: my_end_token(M),\n                    expression: new AST_SymbolRef({\n                        start: start,\n                        end: arg.start,\n                        name: \"import\",\n                    }),\n                    args: [ arg ],\n                });\n            },\n            VariableDeclaration: function(M) {\n                return new ({\n                    const: AST_Const,\n                    let: AST_Let,\n                }[M.kind] || AST_Var)({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    definitions: M.declarations.map(from_moz),\n                });\n            },\n            Literal: function(M) {\n                var args = {\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                };\n                if (M.bigint) {\n                    args.value = M.bigint.toLowerCase() + \"n\";\n                    return new AST_BigInt(args);\n                }\n                var val = M.value;\n                if (val === null) return new AST_Null(args);\n                var rx = M.regex;\n                if (rx && rx.pattern) {\n                    // RegExpLiteral as per ESTree AST spec\n                    args.value = new RegExp(rx.pattern, rx.flags);\n                    args.value.raw_source = rx.pattern;\n                    return new AST_RegExp(args);\n                } else if (rx) {\n                    // support legacy RegExp\n                    args.value = M.regex && M.raw ? M.raw : val;\n                    return new AST_RegExp(args);\n                }\n                switch (typeof val) {\n                  case \"string\":\n                    args.value = val;\n                    return new AST_String(args);\n                  case \"number\":\n                    if (isNaN(val)) return new AST_NaN(args);\n                    var negate, node;\n                    if (isFinite(val)) {\n                        negate = 1 / val < 0;\n                        args.value = negate ? -val : val;\n                        node = new AST_Number(args);\n                    } else {\n                        negate = val < 0;\n                        node = new AST_Infinity(args);\n                    }\n                    return negate ? new AST_UnaryPrefix({\n                        start: args.start,\n                        end: args.end,\n                        operator: \"-\",\n                        expression: node,\n                    }) : node;\n                  case \"boolean\":\n                    return new (val ? AST_True : AST_False)(args);\n                }\n            },\n            TemplateLiteral: function(M) {\n                return new AST_Template({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    expressions: M.expressions.map(from_moz),\n                    strings: M.quasis.map(function(el) {\n                        return el.value.raw;\n                    }),\n                });\n            },\n            TaggedTemplateExpression: function(M) {\n                var tmpl = from_moz(M.quasi);\n                tmpl.start = my_start_token(M);\n                tmpl.end = my_end_token(M);\n                tmpl.tag = from_moz(M.tag);\n                return tmpl;\n            },\n            Identifier: function(M) {\n                var p, level = FROM_MOZ_STACK.length - 1;\n                do {\n                    p = FROM_MOZ_STACK[--level];\n                } while (p.type == \"ArrayPattern\"\n                    || p.type == \"AssignmentPattern\" && p.left === FROM_MOZ_STACK[level + 1]\n                    || p.type == \"ObjectPattern\"\n                    || p.type == \"Property\" && p.value === FROM_MOZ_STACK[level + 1]\n                    || p.type == \"VariableDeclarator\" && p.id === FROM_MOZ_STACK[level + 1]);\n                var ctor = AST_SymbolRef;\n                switch (p.type) {\n                  case \"ArrowFunctionExpression\":\n                    if (p.body !== FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolFunarg;\n                    break;\n                  case \"BreakStatement\":\n                  case \"ContinueStatement\":\n                    ctor = AST_LabelRef;\n                    break;\n                  case \"CatchClause\":\n                    ctor = AST_SymbolCatch;\n                    break;\n                  case \"ClassDeclaration\":\n                    if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolDefClass;\n                    break;\n                  case \"ClassExpression\":\n                    if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolClass;\n                    break;\n                  case \"FunctionDeclaration\":\n                    ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolDefun : AST_SymbolFunarg;\n                    break;\n                  case \"FunctionExpression\":\n                    ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolLambda : AST_SymbolFunarg;\n                    break;\n                  case \"LabeledStatement\":\n                    ctor = AST_Label;\n                    break;\n                  case \"VariableDeclaration\":\n                    ctor = {\n                        const: AST_SymbolConst,\n                        let: AST_SymbolLet,\n                    }[p.kind] || AST_SymbolVar;\n                    break;\n                }\n                return new ctor({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: M.name,\n                });\n            },\n            Super: function(M) {\n                return new AST_Super({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: \"super\",\n                });\n            },\n            ThisExpression: function(M) {\n                return new AST_This({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: \"this\",\n                });\n            },\n            ParenthesizedExpression: function(M) {\n                var node = from_moz(M.expression);\n                if (!node.start.parens) node.start.parens = [];\n                node.start.parens.push(my_start_token(M));\n                if (!node.end.parens) node.end.parens = [];\n                node.end.parens.push(my_end_token(M));\n                return node;\n            },\n            ChainExpression: function(M) {\n                var node = from_moz(M.expression);\n                node.terminal = true;\n                return node;\n            },\n        };\n\n        MOZ_TO_ME.UpdateExpression =\n        MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n            var prefix = \"prefix\" in M ? M.prefix\n                : M.type == \"UnaryExpression\" ? true : false;\n            return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                operator   : M.operator,\n                expression : from_moz(M.argument)\n            });\n        };\n\n        map(\"EmptyStatement\", AST_EmptyStatement);\n        map(\"ExpressionStatement\", AST_SimpleStatement, \"expression>body\");\n        map(\"BlockStatement\", AST_BlockStatement, \"body@body\");\n        map(\"IfStatement\", AST_If, \"test>condition, consequent>body, alternate>alternative\");\n        map(\"LabeledStatement\", AST_LabeledStatement, \"label>label, body>body\");\n        map(\"BreakStatement\", AST_Break, \"label>label\");\n        map(\"ContinueStatement\", AST_Continue, \"label>label\");\n        map(\"WithStatement\", AST_With, \"object>expression, body>body\");\n        map(\"SwitchStatement\", AST_Switch, \"discriminant>expression, cases@body\");\n        map(\"ReturnStatement\", AST_Return, \"argument>value\");\n        map(\"ThrowStatement\", AST_Throw, \"argument>value\");\n        map(\"WhileStatement\", AST_While, \"test>condition, body>body\");\n        map(\"DoWhileStatement\", AST_Do, \"test>condition, body>body\");\n        map(\"ForStatement\", AST_For, \"init>init, test>condition, update>step, body>body\");\n        map(\"ForInStatement\", AST_ForIn, \"left>init, right>object, body>body\");\n        map(\"DebuggerStatement\", AST_Debugger);\n        map(\"VariableDeclarator\", AST_VarDef, \"id>name, init>value\");\n        map(\"CatchClause\", AST_Catch, \"param>argname, body%body\");\n\n        map(\"BinaryExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n        map(\"LogicalExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n        map(\"AssignmentExpression\", AST_Assign, \"operator=operator, left>left, right>right\");\n        map(\"AssignmentPattern\", AST_DefaultValue, \"left>name, right>value\");\n        map(\"ConditionalExpression\", AST_Conditional, \"test>condition, consequent>consequent, alternate>alternative\");\n        map(\"NewExpression\", AST_New, \"callee>expression, arguments@args, pure=pure\");\n        map(\"CallExpression\", AST_Call, \"callee>expression, arguments@args, optional=optional, pure=pure\");\n        map(\"SequenceExpression\", AST_Sequence, \"expressions@expressions\");\n        map(\"SpreadElement\", AST_Spread, \"argument>expression\");\n        map(\"ObjectExpression\", AST_Object, \"properties@properties\");\n        map(\"AwaitExpression\", AST_Await, \"argument>expression\");\n        map(\"YieldExpression\", AST_Yield, \"argument>expression, delegate=nested\");\n\n        def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n            return to_moz_scope(\"Program\", M);\n        });\n\n        def_to_moz(AST_LambdaDefinition, function To_Moz_FunctionDeclaration(M) {\n            var params = M.argnames.map(to_moz);\n            if (M.rest) params.push({\n                type: \"RestElement\",\n                argument: to_moz(M.rest),\n            });\n            return {\n                type: \"FunctionDeclaration\",\n                id: to_moz(M.name),\n                async: is_async(M),\n                generator: is_generator(M),\n                params: params,\n                body: to_moz_scope(\"BlockStatement\", M),\n            };\n        });\n\n        def_to_moz(AST_Lambda, function To_Moz_FunctionExpression(M) {\n            var params = M.argnames.map(to_moz);\n            if (M.rest) params.push({\n                type: \"RestElement\",\n                argument: to_moz(M.rest),\n            });\n            if (is_arrow(M)) return {\n                type: \"ArrowFunctionExpression\",\n                async: is_async(M),\n                params: params,\n                body: M.value ? to_moz(M.value) : to_moz_scope(\"BlockStatement\", M),\n            };\n            return {\n                type: \"FunctionExpression\",\n                id: to_moz(M.name),\n                async: is_async(M),\n                generator: is_generator(M),\n                params: params,\n                body: to_moz_scope(\"BlockStatement\", M),\n            };\n        });\n\n        def_to_moz(AST_DefClass, function To_Moz_ClassDeclaration(M) {\n            return {\n                type: \"ClassDeclaration\",\n                id: to_moz(M.name),\n                superClass: to_moz(M.extends),\n                body: {\n                    type: \"ClassBody\",\n                    body: M.properties.map(to_moz),\n                },\n            };\n        });\n\n        def_to_moz(AST_ClassExpression, function To_Moz_ClassExpression(M) {\n            return {\n                type: \"ClassExpression\",\n                id: to_moz(M.name),\n                superClass: to_moz(M.extends),\n                body: {\n                    type: \"ClassBody\",\n                    body: M.properties.map(to_moz),\n                },\n            };\n        });\n\n        function To_Moz_MethodDefinition(kind) {\n            return function(M) {\n                var computed = M.key instanceof AST_Node;\n                var key = computed ? to_moz(M.key) : M.private ? {\n                    type: \"PrivateIdentifier\",\n                    name: M.key.slice(1),\n                } : {\n                    type: \"Literal\",\n                    value: M.key,\n                };\n                return {\n                    type: \"MethodDefinition\",\n                    kind: kind,\n                    computed: computed,\n                    key: key,\n                    static: M.static,\n                    value: to_moz(M.value),\n                };\n            };\n        }\n        def_to_moz(AST_ClassGetter, To_Moz_MethodDefinition(\"get\"));\n        def_to_moz(AST_ClassSetter, To_Moz_MethodDefinition(\"set\"));\n        def_to_moz(AST_ClassMethod, To_Moz_MethodDefinition(\"method\"));\n\n        def_to_moz(AST_ClassField, function To_Moz_PropertyDefinition(M) {\n            var computed = M.key instanceof AST_Node;\n            var key = computed ? to_moz(M.key) : M.private ? {\n                type: \"PrivateIdentifier\",\n                name: M.key.slice(1),\n            } : {\n                type: \"Literal\",\n                value: M.key,\n            };\n            return {\n                type: \"PropertyDefinition\",\n                computed: computed,\n                key: key,\n                static: M.static,\n                value: to_moz(M.value),\n            };\n        });\n\n        def_to_moz(AST_ClassInit, function To_Moz_StaticBlock(M) {\n            return to_moz_scope(\"StaticBlock\", M.value);\n        });\n\n        function To_Moz_ForOfStatement(is_await) {\n            return function(M) {\n                return {\n                    type: \"ForOfStatement\",\n                    await: is_await,\n                    left: to_moz(M.init),\n                    right: to_moz(M.object),\n                    body: to_moz(M.body),\n                };\n            };\n        }\n        def_to_moz(AST_ForAwaitOf, To_Moz_ForOfStatement(true));\n        def_to_moz(AST_ForOf, To_Moz_ForOfStatement(false));\n\n        def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n            return {\n                type: \"ExpressionStatement\",\n                expression: set_moz_loc(M, {\n                    type: \"Literal\",\n                    value: M.value,\n                }),\n            };\n        });\n\n        def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n            return {\n                type: \"SwitchCase\",\n                test: to_moz(M.expression),\n                consequent: M.body.map(to_moz),\n            };\n        });\n\n        def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n            return {\n                type: \"TryStatement\",\n                block: to_moz_block(M),\n                handler: to_moz(M.bcatch),\n                guardedHandlers: [],\n                finalizer: to_moz(M.bfinally),\n            };\n        });\n\n        def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n            return {\n                type: \"CatchClause\",\n                param: to_moz(M.argname),\n                guard: null,\n                body: to_moz_block(M),\n            };\n        });\n\n        def_to_moz(AST_ExportDeclaration, function To_Moz_ExportNamedDeclaration_declaration(M) {\n            return {\n                type: \"ExportNamedDeclaration\",\n                declaration: to_moz(M.body),\n            };\n        });\n\n        def_to_moz(AST_ExportDefault, function To_Moz_ExportDefaultDeclaration(M) {\n            return {\n                type: \"ExportDefaultDeclaration\",\n                declaration: to_moz(M.body),\n            };\n        });\n\n        def_to_moz(AST_ExportForeign, function To_Moz_ExportAllDeclaration_ExportNamedDeclaration(M) {\n            if (M.keys[0].value == \"*\") return {\n                type: \"ExportAllDeclaration\",\n                exported: M.aliases[0].value == \"*\" ? null : to_moz_alias(M.aliases[0]),\n                source: to_moz(M.path),\n            };\n            var specifiers = [];\n            for (var i = 0; i < M.aliases.length; i++) {\n                specifiers.push(set_moz_loc({\n                    start: M.keys[i].start,\n                    end: M.aliases[i].end,\n                }, {\n                    type: \"ExportSpecifier\",\n                    local: to_moz_alias(M.keys[i]),\n                    exported: to_moz_alias(M.aliases[i]),\n                }));\n            }\n            return {\n                type: \"ExportNamedDeclaration\",\n                specifiers: specifiers,\n                source: to_moz(M.path),\n            };\n        });\n\n        def_to_moz(AST_ExportReferences, function To_Moz_ExportNamedDeclaration_specifiers(M) {\n            return {\n                type: \"ExportNamedDeclaration\",\n                specifiers: M.properties.map(function(prop) {\n                    return set_moz_loc({\n                        start: prop.start,\n                        end: prop.alias.end,\n                    }, {\n                        type: \"ExportSpecifier\",\n                        local: to_moz(prop),\n                        exported: to_moz_alias(prop.alias),\n                    });\n                }),\n            };\n        });\n\n        def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n            var specifiers = M.properties ? M.properties.map(function(prop) {\n                return set_moz_loc({\n                    start: prop.key.start,\n                    end: prop.end,\n                }, {\n                    type: \"ImportSpecifier\",\n                    local: to_moz(prop),\n                    imported: to_moz_alias(prop.key),\n                });\n            }) : [];\n            if (M.all) specifiers.unshift(set_moz_loc(M.all, {\n                type: \"ImportNamespaceSpecifier\",\n                local: to_moz(M.all),\n            }));\n            if (M.default) specifiers.unshift(set_moz_loc(M.default, {\n                type: \"ImportDefaultSpecifier\",\n                local: to_moz(M.default),\n            }));\n            return {\n                type: \"ImportDeclaration\",\n                specifiers: specifiers,\n                source: to_moz(M.path),\n            };\n        });\n\n        def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {\n            return {\n                type: \"VariableDeclaration\",\n                kind: M.TYPE.toLowerCase(),\n                declarations: M.definitions.map(to_moz),\n            };\n        });\n\n        def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n            var computed = M instanceof AST_Sub;\n            var expr = {\n                type: \"MemberExpression\",\n                object: to_moz(M.expression),\n                computed: computed,\n                optional: M.optional,\n                property: computed ? to_moz(M.property) : {\n                    type: \"Identifier\",\n                    name: M.property,\n                },\n            };\n            return M.terminal ? {\n                type: \"ChainExpression\",\n                expression: expr,\n            } : expr;\n        });\n\n        def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n            return {\n                type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n                operator: M.operator,\n                prefix: M instanceof AST_UnaryPrefix,\n                argument: to_moz(M.expression)\n            };\n        });\n\n        def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n            return {\n                type: M.operator == \"&&\" || M.operator == \"||\" ? \"LogicalExpression\" : \"BinaryExpression\",\n                left: to_moz(M.left),\n                operator: M.operator,\n                right: to_moz(M.right)\n            };\n        });\n\n        def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n            return {\n                type: \"ArrayExpression\",\n                elements: M.elements.map(to_moz),\n            };\n        });\n\n        def_to_moz(AST_DestructuredArray, function To_Moz_ArrayPattern(M) {\n            var elements = M.elements.map(to_moz);\n            if (M.rest) elements.push({\n                type: \"RestElement\",\n                argument: to_moz(M.rest),\n            });\n            return {\n                type: \"ArrayPattern\",\n                elements: elements,\n            };\n        });\n\n        def_to_moz(AST_DestructuredKeyVal, function To_Moz_Property(M) {\n            var computed = M.key instanceof AST_Node;\n            var key = computed ? to_moz(M.key) : {\n                type: \"Literal\",\n                value: M.key,\n            };\n            return {\n                type: \"Property\",\n                kind: \"init\",\n                computed: computed,\n                key: key,\n                value: to_moz(M.value),\n            };\n        });\n\n        def_to_moz(AST_DestructuredObject, function To_Moz_ObjectPattern(M) {\n            var props = M.properties.map(to_moz);\n            if (M.rest) props.push({\n                type: \"RestElement\",\n                argument: to_moz(M.rest),\n            });\n            return {\n                type: \"ObjectPattern\",\n                properties: props,\n            };\n        });\n\n        def_to_moz(AST_ObjectProperty, function To_Moz_Property(M) {\n            var computed = M.key instanceof AST_Node;\n            var key = computed ? to_moz(M.key) : {\n                type: \"Literal\",\n                value: M.key,\n            };\n            var kind;\n            if (M instanceof AST_ObjectKeyVal) {\n                kind = \"init\";\n            } else if (M instanceof AST_ObjectGetter) {\n                kind = \"get\";\n            } else if (M instanceof AST_ObjectSetter) {\n                kind = \"set\";\n            }\n            return {\n                type: \"Property\",\n                kind: kind,\n                computed: computed,\n                method: M instanceof AST_ObjectMethod,\n                key: key,\n                value: to_moz(M.value),\n            };\n        });\n\n        def_to_moz(AST_Symbol, function To_Moz_Identifier(M) {\n            var def = M.definition();\n            return {\n                type: \"Identifier\",\n                name: def && def.mangled_name || M.name,\n            };\n        });\n\n        def_to_moz(AST_Super, function To_Moz_Super() {\n            return { type: \"Super\" };\n        });\n\n        def_to_moz(AST_This, function To_Moz_ThisExpression() {\n            return { type: \"ThisExpression\" };\n        });\n\n        def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n            return {\n                type: \"MetaProperty\",\n                meta: {\n                    type: \"Identifier\",\n                    name: \"new\",\n                },\n                property: {\n                    type: \"Identifier\",\n                    name: \"target\",\n                },\n            };\n        });\n\n        def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n            var flags = M.value.toString().match(/\\/([gimuy]*)$/)[1];\n            var value = \"/\" + M.value.raw_source + \"/\" + flags;\n            return {\n                type: \"Literal\",\n                value: value,\n                raw: value,\n                regex: {\n                    pattern: M.value.raw_source,\n                    flags: flags,\n                },\n            };\n        });\n\n        def_to_moz(AST_BigInt, function To_Moz_BigInt(M) {\n            var value = M.value;\n            return {\n                type: \"Literal\",\n                bigint: value.slice(0, -1),\n                raw: value,\n            };\n        });\n\n        function To_Moz_Literal(M) {\n            var value = M.value;\n            if (typeof value === \"number\" && (value < 0 || (value === 0 && 1 / value < 0))) {\n                return {\n                    type: \"UnaryExpression\",\n                    operator: \"-\",\n                    prefix: true,\n                    argument: {\n                        type: \"Literal\",\n                        value: -value,\n                        raw: M.start.raw,\n                    },\n                };\n            }\n            return {\n                type: \"Literal\",\n                value: value,\n                raw: M.start.raw,\n            };\n        }\n        def_to_moz(AST_Boolean, To_Moz_Literal);\n        def_to_moz(AST_Constant, To_Moz_Literal);\n        def_to_moz(AST_Null, To_Moz_Literal);\n\n        def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n            return {\n                type: \"Identifier\",\n                name: String(M.value),\n            };\n        });\n\n        def_to_moz(AST_Template, function To_Moz_TemplateLiteral_TaggedTemplateExpression(M) {\n            var last = M.strings.length - 1;\n            var tmpl = {\n                type: \"TemplateLiteral\",\n                expressions: M.expressions.map(to_moz),\n                quasis: M.strings.map(function(str, index) {\n                    return {\n                        type: \"TemplateElement\",\n                        tail: index == last,\n                        value: { raw: str },\n                    };\n                }),\n            };\n            if (!M.tag) return tmpl;\n            return {\n                type: \"TaggedTemplateExpression\",\n                tag: to_moz(M.tag),\n                quasi: tmpl,\n            };\n        });\n\n        AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n        AST_Hole.DEFMETHOD(\"to_mozilla_ast\", return_null);\n        AST_Node.DEFMETHOD(\"to_mozilla_ast\", function() {\n            throw new Error(\"Cannot convert AST_\" + this.TYPE);\n        });\n\n        /* -----[ tools ]----- */\n\n        function normalize_directives(body) {\n            for (var i = 0; i < body.length; i++) {\n                var stat = body[i];\n                if (!(stat instanceof AST_SimpleStatement)) break;\n                var node = stat.body;\n                if (!(node instanceof AST_String)) break;\n                if (stat.start.pos !== node.start.pos) break;\n                body[i] = new AST_Directive(node);\n            }\n            return body;\n        }\n\n        function raw_token(moznode) {\n            if (moznode.type == \"Literal\") {\n                return moznode.raw != null ? moznode.raw : moznode.value + \"\";\n            }\n        }\n\n        function my_start_token(moznode) {\n            var loc = moznode.loc, start = loc && loc.start;\n            var range = moznode.range;\n            return new AST_Token({\n                file    : loc && loc.source,\n                line    : start && start.line,\n                col     : start && start.column,\n                pos     : range ? range[0] : moznode.start,\n                endline : start && start.line,\n                endcol  : start && start.column,\n                endpos  : range ? range[0] : moznode.start,\n                raw     : raw_token(moznode),\n            });\n        }\n\n        function my_end_token(moznode) {\n            var loc = moznode.loc, end = loc && loc.end;\n            var range = moznode.range;\n            return new AST_Token({\n                file    : loc && loc.source,\n                line    : end && end.line,\n                col     : end && end.column,\n                pos     : range ? range[1] : moznode.end,\n                endline : end && end.line,\n                endcol  : end && end.column,\n                endpos  : range ? range[1] : moznode.end,\n                raw     : raw_token(moznode),\n            });\n        }\n\n        function read_name(M) {\n            return \"\" + M[M.type == \"Identifier\" ? \"name\" : \"value\"];\n        }\n\n        function map(moztype, mytype, propmap) {\n            var moz_to_me = [\n                \"start: my_start_token(M)\",\n                \"end: my_end_token(M)\",\n            ];\n            var me_to_moz = [\n                \"type: \" + JSON.stringify(moztype),\n            ];\n\n            if (propmap) propmap.split(/\\s*,\\s*/).forEach(function(prop) {\n                var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);\n                if (!m) throw new Error(\"Can't understand property map: \" + prop);\n                var moz = m[1], how = m[2], my = m[3];\n                switch (how) {\n                  case \"@\":\n                    moz_to_me.push(my + \": M.\" + moz + \".map(from_moz)\");\n                    me_to_moz.push(moz + \": M.\" +  my + \".map(to_moz)\");\n                    break;\n                  case \">\":\n                    moz_to_me.push(my + \": from_moz(M.\" + moz + \")\");\n                    me_to_moz.push(moz + \": to_moz(M.\" + my + \")\");\n                    break;\n                  case \"=\":\n                    moz_to_me.push(my + \": M.\" + moz);\n                    me_to_moz.push(moz + \": M.\" + my);\n                    break;\n                  case \"%\":\n                    moz_to_me.push(my + \": from_moz(M.\" + moz + \").body\");\n                    me_to_moz.push(moz + \": to_moz_block(M)\");\n                    break;\n                  default:\n                    throw new Error(\"Can't understand operator in propmap: \" + prop);\n                }\n            });\n\n            MOZ_TO_ME[moztype] = new Function(\"U2\", \"my_start_token\", \"my_end_token\", \"from_moz\", [\n                \"return function From_Moz_\" + moztype + \"(M) {\",\n                \"    return new U2.AST_\" + mytype.TYPE + \"({\",\n                moz_to_me.join(\",\\n\"),\n                \"    });\",\n                \"};\",\n            ].join(\"\\n\"))(exports, my_start_token, my_end_token, from_moz);\n            def_to_moz(mytype, new Function(\"to_moz\", \"to_moz_block\", \"to_moz_scope\", [\n                \"return function To_Moz_\" + moztype + \"(M) {\",\n                \"    return {\",\n                me_to_moz.join(\",\\n\"),\n                \"    };\",\n                \"};\",\n            ].join(\"\\n\"))(to_moz, to_moz_block, to_moz_scope));\n        }\n\n        var FROM_MOZ_STACK = null;\n\n        function from_moz(moz) {\n            FROM_MOZ_STACK.push(moz);\n            var node = null;\n            if (moz) {\n                if (!HOP(MOZ_TO_ME, moz.type)) throw new Error(\"Unsupported type: \" + moz.type);\n                node = MOZ_TO_ME[moz.type](moz);\n            }\n            FROM_MOZ_STACK.pop();\n            return node;\n        }\n\n        function from_moz_alias(moz) {\n            return new AST_String({\n                start: my_start_token(moz),\n                value: read_name(moz),\n                end: my_end_token(moz),\n            });\n        }\n\n        AST_Node.from_mozilla_ast = function(node) {\n            var save_stack = FROM_MOZ_STACK;\n            FROM_MOZ_STACK = [];\n            var ast = from_moz(node);\n            FROM_MOZ_STACK = save_stack;\n            ast.walk(new TreeWalker(function(node) {\n                if (node instanceof AST_LabelRef) {\n                    for (var level = 0, parent; parent = this.parent(level); level++) {\n                        if (parent instanceof AST_Scope) break;\n                        if (parent instanceof AST_LabeledStatement && parent.label.name == node.name) {\n                            node.thedef = parent.label;\n                            break;\n                        }\n                    }\n                    if (!node.thedef) {\n                        var s = node.start;\n                        js_error(\"Undefined label \" + node.name, s.file, s.line, s.col, s.pos);\n                    }\n                }\n            }));\n            return ast;\n        };\n\n        function set_moz_loc(mynode, moznode) {\n            var start = mynode.start;\n            var end = mynode.end;\n            if (start.pos != null && end.endpos != null) {\n                moznode.range = [start.pos, end.endpos];\n            }\n            if (start.line) {\n                moznode.loc = {\n                    start: {line: start.line, column: start.col},\n                    end: end.endline ? {line: end.endline, column: end.endcol} : null,\n                };\n                if (start.file) {\n                    moznode.loc.source = start.file;\n                }\n            }\n            return moznode;\n        }\n\n        function def_to_moz(mytype, handler) {\n            mytype.DEFMETHOD(\"to_mozilla_ast\", function() {\n                return set_moz_loc(this, handler(this));\n            });\n        }\n\n        function to_moz(node) {\n            return node != null ? node.to_mozilla_ast() : null;\n        }\n\n        function to_moz_alias(alias) {\n            return is_identifier_string(alias.value) ? set_moz_loc(alias, {\n                type: \"Identifier\",\n                name: alias.value,\n            }) : to_moz(alias);\n        }\n\n        function to_moz_block(node) {\n            return {\n                type: \"BlockStatement\",\n                body: node.body.map(to_moz),\n            };\n        }\n\n        function to_moz_scope(type, node) {\n            var body = node.body.map(to_moz);\n            if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n                body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n            }\n            return {\n                type: type,\n                body: body,\n            };\n        }\n    })();\n});"]}