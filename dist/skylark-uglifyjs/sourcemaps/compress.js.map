{"version":3,"sources":["compress.js"],"names":["define","m_utils","m_ast","m_output","m_parse","m_scope","AST_Accessor","AST_Array","AST_Arrow","AST_Assign","AST_AsyncArrow","AST_AsyncDefun","AST_AsyncFunction","AST_AsyncGeneratorDefun","AST_AsyncGeneratorFunction","AST_Atom","AST_Await","AST_BigInt","AST_Binary","AST_Block","AST_BlockScope","AST_BlockStatement","AST_Boolean","AST_Break","AST_Call","AST_Case","AST_Catch","AST_Class","AST_ClassExpression","AST_ClassField","AST_ClassGetter","AST_ClassInit","AST_ClassInitBlock","AST_ClassMethod","AST_ClassProperty","AST_ClassSetter","AST_Conditional","AST_Const","AST_Constant","AST_Continue","AST_Debugger","AST_Default","AST_DefaultValue","AST_DefClass","AST_Definitions","AST_Defun","AST_Destructured","AST_DestructuredArray","AST_DestructuredKeyVal","AST_DestructuredObject","AST_Directive","AST_Do","AST_Dot","AST_DWLoop","AST_EmptyStatement","AST_Exit","AST_ExportDeclaration","AST_ExportDefault","AST_ExportReferences","AST_False","AST_Finally","AST_For","AST_ForAwaitOf","AST_ForEnumeration","AST_ForIn","AST_Function","AST_Hole","AST_If","AST_Import","AST_Infinity","AST_IterationStatement","AST_Jump","AST_LabeledStatement","AST_Lambda","AST_LambdaDefinition","AST_LambdaExpression","AST_Let","AST_LoopControl","AST_NaN","AST_New","AST_NewTarget","AST_Node","AST_Null","AST_Number","AST_Object","AST_ObjectKeyVal","AST_ObjectGetter","AST_ObjectProperty","AST_ObjectIdentity","AST_ObjectMethod","AST_ObjectSetter","AST_PropAccess","AST_RegExp","AST_Return","AST_Scope","AST_Sequence","AST_SimpleStatement","AST_Spread","AST_Statement","AST_String","AST_Sub","AST_Super","AST_Switch","AST_SwitchBranch","AST_Symbol","AST_SymbolCatch","AST_SymbolClass","AST_SymbolConst","AST_SymbolDeclaration","AST_SymbolDefun","AST_SymbolExport","AST_SymbolFunarg","AST_SymbolImport","AST_SymbolLambda","AST_SymbolLet","AST_SymbolRef","AST_SymbolVar","AST_Template","AST_This","AST_Throw","AST_Toplevel","AST_True","AST_Try","AST_Unary","AST_UnaryPostfix","AST_UnaryPrefix","AST_Undefined","AST_Var","AST_VarDef","AST_While","AST_With","AST_Yield","TreeTransformer","TreeWalker","first_in_statement","root_expr","is_arrow","is_generator","is_statement","is_async","walk_body","walk_lambda","all","defaults","Dictionary","find_if","HOP","List","makePredicate","member","noop","push_uniq","remove","return_false","return_null","return_true","return_this","JS_Parse_Error","parse","PRECEDENCE","decode_escape_sequence","is_identifier_string","UNARY_POSTFIX","OutputStream","is_lhs","is_funarg","unary_side_effects","Compressor","options","false_by_default","this","call","before","after","annotations","arguments","arrows","assignments","awaits","booleans","collapse_vars","comparisons","conditionals","dead_code","default_values","directives","drop_console","drop_debugger","evaluate","expression","functions","global_defs","hoist_exports","hoist_funs","hoist_props","hoist_vars","ie","if_return","imports","inline","join_vars","keep_fargs","keep_fnames","keep_infinity","loops","merge_vars","module","negate_iife","objects","optional_chains","passes","properties","pure_funcs","pure_getters","reduce_funcs","reduce_vars","rests","sequences","side_effects","spreads","strings","switches","templates","top_retain","toplevel","typeofs","unsafe","unsafe_comps","unsafe_Function","unsafe_math","unsafe_proto","unsafe_regexp","unsafe_undefined","unused","varify","webkit","yields","eval_threshold","test","key","slice","drop_fargs","lambda","parent","escaped","length_read","name","fixed_value","def","definition","direct_access","depth","TYPE","node","expr","tag","print_to_string","Array","isArray","sequences_limit","RegExp","split","funcs","vars","read_property","obj","value","get_property","elements","make_node_from_constant","length","argnames","props","i","can_hoist_property","is_modified","compressor","tw","level","immutable","recursive","option","property","native_fns","Boolean","Number","String","Function","Object","global","prop","lhs","is_constant","operator","lazy_op","is_expr_pure","contains_this","condition","init","tail_node","is_lambda","safe_for_extends","is_arguments","scope","uses_arguments","cross_scope","sym","parent_scope","can_drop_symbol","ref","keep_lambda","redef","in_arg","orig","can_varify","has_escaped","d","right","static","resolve","make_ref","fixed","make_node","replace_ref","references","push","replaced","reset_def","bool_return","drop_return","cross_loop","const_redefs","pinned","exposed","reassigned","recursive_refs","single_use","undefined","reset_block_variables","variables","each","reset_variables","fn_defs","safe_ids","mark","loop_ids","id","in_loop","may_call_this","each_argname","last_ref","safe_to_visit","fn","marker","walk_fn_def","was_scanning","fn_scanning","walk","revisit_fn_def","enclosed","forEach","get","safe_to_read","mark_fn_def","visited","fn_visited","pop_scope","tangled","filter","pop","sequential","create","seq","getPrototypeOf","push_ref","safe","in_order","read","assign","safe_to_assign","declare","has_directive","find_parent","is_immutable","op","mark_escaped","is_constant_expression","mark_assignment_to_arguments","RE_POSITIVE_INTEGER","argname","make_fixed","save","prev_save","prev_value","current","scan_declaration","visit","scanner","prev_seq","fixed_node","reset_flags","ev","fuzzy_eval","make_sequence","index","rest","len","type","save_len","stack","reduce_iife","descend","iife","inlined","hit","aborts","args","j","indexOf","arg","expressions","assigns","_squeezed","_optimized","_var_names","convert_destructured","process","transform","clone","convert_symbol","process_to_assign","mark_destructured","mark_symbol","match_destructured","predicate","ignore_side_effects","found","in_async_generator","find_scope","self","find_try","may_throw","sync","bfinally","bcatch","is_lhs_read_only","identifier_atom","ctor","start","end","reduce","merge_sequence","val","isNaN","isFinite","Error","string_template","needs_unbinding","is_undeclared_ref","maintain_this_binding","wrap","merge_expression","base","target","fixed_by_id","has","set","size","array","apply","is_lexical_definition","stat","safe_to_trim","s","as_statement_array","thing","body","is_empty","has_declarations_only","block","declarations_only","loop_body","x","is_iife_call","is_iife_single","exp","undeclared","is_static_field_or_init","definitions","var_def","is_declaration","lexical","extends","is_last_statement","lastIndexOf","patch_for_init","in_list","splice","tighten_body","statements","block_scope","iife_in_try","in_iife_single","in_try","in_lambda","last_of","changed","last_changed","max_iter","eliminate_spurious_blocks","seen_dirs","concat","eliminate_dead_code","has_quit","n","lct","loopcontrol_target","label","thedef","extract_declarations_from_unreachable_code","handle_if_return","declare_only","jump","merge_jump","in_iife","chain_if_returns","drop_return_void","multiple_if_returns","next_index","next","tail","is_undefined","ab","can_merge_flow","as_statement_array_with_return","alternative","extract_functions","adjust_refs","cond","preference","best_of_expression","negate","stats","alt","mark_locally_defined","in_bool","consequent","prev_stat","prev","exprs","eliminate_returns","keep_throws","in_block","mode","match_return","trim_return","trimmed","match_target","exact","equals","preinit","defn","match_symbol","stop","defuns","last","trim_awaits","needs_enqueuing","drop_side_effect_free","inline_iife","no_return","try_inline","loop","sequencesize","push_seq","sequencesize_2","abort","cons_seq","optimize","object","decls","to_simple_statement","unshift","left","join_consecutive_vars","defs","defns","merge_assigns","join_assigns_expr","join_assigns","merge_defns","skip","collapse","force_single","candidates","stat_index","hit_stack","hit_index","handle_custom_scan_order","stop_after","value_def","find_stop_value","find_stop","hit_rhs","replace","stop_if_hit","in_conditional","compound","scan_lhs","can_replace","info","lvalues","get_lvalues","clear_write_only","candidate","folded","to_binary","rvalue","funarg","scan_rhs","is_declared","is_direct_assignment","replace_all","is_last_node","signal_abort","lhs_local","assign_used","verify_ref","assign_pos","remaining","update_symbols","to_prefix","multi_replacer","rhs_value","reference","patch_sequence","extract_args","has_await","fn_strict","in_strict_mode","arg_scope","save_scope","is_safe_lexical","names","arg_may_throw","has_side_effects","name_index","arg_index","extract_candidates","remaining_refs","matches","mangleable_var","declared","eliminated","Math","min","get_rvalue","circular","lhs_ids","rhs_exact_match","rhs_fuzzy_match","is_truthy","invariant","side_effects_external","read_toplevel","modify_toplevel","well_defined","lvalue","check_destructured","referenced","matched","remove_candidate","tt","head","fields","branch","optional","can_drop_op","recursive_ref","collapse_scanning","if_hit","reject","may_modify","symbol_in_lvalues","global_names","is_static_fn","may_throw_on_access","element","is_string","lazy","step","find_stop_unused","find_stop_logical","find_stop_expr","cont","check_assignment","rhs","fallback","in_boolean_context","write_only","find_arguments","add","scan_toplevel","same_scope","child","may_be_global","branches","has_break","line","extract_exprs","keep","can_trim","flattened","trim_assigns","merge_conditional_assignments","to_conditional_assignment","shift","join_var_assign","reverse","try_join","diff","dropped","required","remove_initializers","warn","binary","is_negative_zero","is_strict","force","is_binary_defined","is_defined","ast1","ast2","threshold","best_of_statement","best_of","convert_to_predicate","map","keys","skip_directives","arrow_first_statement","try_evaluate","static_fn","static_fns","modified","_eval","eval_all","nodes","cached","values","basic_negation","best","negated","any","list","spread","array_spread","call_may_throw","all_constant","block_aborts","trim_block","drop_rest_farg","opt_arrow","first_statement","fill_holes","to_class_expr","defcl","drop_name","cl","to_func_expr","defun","CTOR","AST_GeneratorDefun","AST_GeneratorFunction","scan_local_returns","map_self_returns","can_trim_returns","self_returns","process_boolean_returns","fn_name_unused","drop_returns","ignore_name","arrow","async","drop_body","process_expression","trim","ret","convert_spread","has_loop_control","refs","scanned","undef","defined","nullish","truthy","falsy","mark_duplicate_condition","match","make_value","may_overlap","var_names","to_var","trim_optional_chain","terminal","lift_sequence_in_expression","e","drop_unused_call_args","fns_with_marked_args","is_iife","insert","pos","drop_defaults","avoid_await_yield","avoid","safe_from_await_yield","safe_from_strict_mode","safe_from_assignment","is_object","plain","is_raw_tag","extract_lhs","repeatable","swap_chain","decode_template","str","malformed","ch","is_atomic","is_reachable","reachable","find_ref","scan_scope","safe_to_flatten","contains_super","flatten_var","redefined","has_arg_refs","insert_assign","init_ref","inline_sequence","in_await","no_ret","flush","unary","unaryPrefix","scan_modified","non_converting_unary","non_converting_binary","global_objs","static_values","regexp_props","global_pure_fns","global_pure_constructors","NO_MERGE","SIGN_OPS","MULTIPLICATIVE_OPS","indexFns","commutativeOperators","ASSIGN_OPS","ASSIGN_OPS_COMMUTATIVE","prototype","is_scope","opt","hoist_properties","hoist_declarations","process_returns","drop_unused","merge_variables","exported","compress","resolve_defines","min_count","stopping","mangle","pass","figure_out_scope","reset_opt_flags","count","OPT","optimizer","DEFMETHOD","export_symbol","alias","init_vars","func","ld","scan","walk_prop","redundant","walk_assign","walk_lazy","drop","mark_refs","save_loop","first","globals","walk_defn","ref_only","result","_dot_throw","private","new","is_boolean","is_number","keep_unary","_find_defs","suffix","defines","to_node","object_fns","toString","v","pow","digits","max","decimals","toFixed","operand","exec","static_value","evaluating","cached_args","native_fn","constructor","ex","lastIndex","decode","pure","dot","safe_to_spread","is_call_pure","scopes","scope_def","find_variable","make_var","root","segment","declarations","save_try","assigned","walk_destructured","walk_cond","mark_expression","inserted","segments","merged","tail_refs","skipped","prev_def","head_refs","mergeable","symbol_type","ldef","seg","must_visit","isPrototypeOf","drop_funcs","drop_vars","assign_as_unused","nested","extract_reference","export_defaults","assign_in_use","compose","find","for_ins","in_use","in_use_ids","lambda_ids","value_read","value_modified","var_defs","initializations","drop_fn_name","used","walk_class_prop","scan_ref_scoped","shared","verify_safe_usage","unmark_lambda","calls_to_drop_args","trimmer","trim_default","retain","trim_decl","indexOf_assign","get_rhs","log","descend_scope","default_length","trim_destructured","trim_value","log_default","duplicated","is_var","is_catch","drop_sym","old_def","forbidden","name_def","def_function","insert_statements","get_init_symbol","text","track_assigns","add_assigns","for_in","node_def","save_drop","native","was_drop","save_value","newValues","prop_keys","prop_map","can_drop","drop_keys","mapped","retain_lhs","retain_key","var_decl","consts","dirs","hoisted","p","to_assignments","del","prefix","def_variable","defs_by_id","can_hoist","decl","make_sym","new_var","negated_rhs","call_only","has_block_scope_refs","if_break_in_loop","external_target","drop_it","self_condition_length","negated_length","negated_is_best","body_defuns","tmp","body_var_defs","body_refs","body_exprs","alt_defuns","alt_var_defs","alt_refs","alt_exprs","cons_value","alt_value","has_finally","exit","body_stats","as_array","body_index","last_index","alt_stats","alt_index","alt_stat","expr1","expr2","pop_expr","process_var_def","default_branch","exact_match","is_break","eliminate_branch","default_index","prev_block","next_block","no_break","exclusive","a","terminated","params","EXIT","separator","el","join","fun","code","ast","comp","compute_char_frequency","mangle_names","_codegen","is_func","has_default","has_destructured","has_spread","can_inline","convert_args","var_assigned","return_value","arg_used","replacing","begin","resolve_index","retValue","save_inlined","safe_to_inject","var_exists","can_inject_vars","make_void_lhs","symbol","append_var","default_args","decl_var","expr_fn","expr_var","expr_loop","destructured","noop_value","is_simple_assign","may_not_delete","lift_sequences","is_strict_comparison","associative","ll","lr","rr","reversible","align","make_binary","indexRight","is_indexFn","indexLeft","uses_with","defun_def","lambda_def","def_fn_name","state","name_length","should_replace","value_length","has_symbol_ref","floor","status","strs","escape_literal","decoded","joined","strip_assignment","local","make_compound","cond_lhs","seq_tail","is_eq","alt_tail","can_shift_lhs_of_tail","pop_lhs","pop_seq","combined","combine_tail","top","is_tail_equivalent","seq_expr","fuse","alt_expr","arg_diff","is_true","is_false","booleanize","b","q","parseFloat","quoted","fn_parent","deleted","arg_def","has_reassigned","sub","flatten_object","is_hole","flatten","generated","keep_duplicate","setter","verify_body","syms","simple_argnames","find_return","make_body"],"mappings":"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","file":"../compress.js","sourcesContent":["define([\n    \"./utils\",\n    \"./ast\",\n    \"./output\",\n    \"./parse\",\n    \"./scope\"\n],function(m_utils,m_ast,m_output,m_parse,m_scope){\n    /***********************************************************************\n\n      A JavaScript tokenizer / parser / beautifier / compressor.\n      https://github.com/mishoo/UglifyJS\n\n      -------------------------------- (C) ---------------------------------\n\n                               Author: Mihai Bazon\n                             <mihai.bazon@gmail.com>\n                           http://mihai.bazon.net/blog\n\n      Distributed under the BSD license:\n\n        Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n        Redistribution and use in source and binary forms, with or without\n        modification, are permitted provided that the following conditions\n        are met:\n\n            * Redistributions of source code must retain the above\n              copyright notice, this list of conditions and the following\n              disclaimer.\n\n            * Redistributions in binary form must reproduce the above\n              copyright notice, this list of conditions and the following\n              disclaimer in the documentation and/or other materials\n              provided with the distribution.\n\n        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n        EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n        IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n        PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n        LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n        OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n        PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n        PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n        THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n        TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n        THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n        SUCH DAMAGE.\n\n     ***********************************************************************/\n\n    \"use strict\";\n\n    const {\n        AST_Accessor,\n        AST_Array,\n        AST_Arrow,\n        AST_Assign,\n        AST_AsyncArrow,\n        AST_AsyncDefun,\n        AST_AsyncFunction,\n        AST_AsyncGeneratorDefun,\n        AST_AsyncGeneratorFunction,\n        AST_Atom,\n        AST_Await,\n        AST_BigInt,\n        AST_Binary,\n        AST_Block,\n        AST_BlockScope,\n        AST_BlockStatement,\n        AST_Boolean,\n        AST_Break,\n        AST_Call,\n        AST_Case,\n        AST_Catch,\n        AST_Chain,\n        AST_Class,\n        AST_ClassExpression,\n        AST_ClassField,\n        AST_ClassGetter,\n        AST_ClassInit,\n        AST_ClassInitBlock,\n        AST_ClassMethod,\n        AST_ClassProperty,\n        AST_ClassSetter,\n        AST_ClassStaticBlock,\n        AST_ConciseMethod,\n        AST_Conditional,\n        AST_Const,\n        AST_Constant,\n        AST_Continue,\n        AST_Debugger,\n        AST_Default,\n        AST_DefaultAssign,\n        AST_DefaultValue,\n        AST_DefClass,\n        AST_Definitions,\n        AST_Defun,\n        AST_Destructuring,\n        AST_Destructured,\n        AST_DestructuredArray,\n        AST_DestructuredKeyVal,\n        AST_DestructuredObject,\n        AST_Directive,\n        AST_Do,\n        AST_Dot,\n        AST_DWLoop,\n        AST_EmptyStatement,\n        AST_Exit,\n        AST_Expansion,\n        AST_Export,\n        AST_ExportDeclaration,\n        AST_ExportDefault,\n        AST_ExportReferences,\n        AST_False,\n        AST_Finally,\n        AST_For,\n        AST_ForAwaitOf,\n        AST_ForEnumeration,\n        AST_ForIn,\n        AST_Function,\n        AST_Hole,\n        AST_If,\n        AST_Import,\n        AST_Infinity,\n        AST_IterationStatement,\n        AST_Jump,\n        AST_LabeledStatement,\n        AST_Lambda,\n        AST_LambdaDefinition,\n        AST_LambdaExpression,\n        AST_Let,\n        AST_LoopControl,\n        AST_NaN,\n        AST_New,\n        AST_NewTarget,\n        AST_Node,\n        AST_Null,\n        AST_Number,\n        AST_Object,\n        AST_ObjectKeyVal,\n        AST_ObjectGetter,\n        AST_ObjectProperty,\n        AST_ObjectIdentity,\n        AST_ObjectMethod,\n        AST_ObjectSetter,\n        AST_PrefixedTemplateString,\n        AST_PropAccess,\n        AST_RegExp,\n        AST_Return,\n        AST_Scope,\n        AST_Sequence,\n        AST_SimpleStatement,\n        AST_Spread,\n        AST_Statement,\n        AST_String,\n        AST_Sub,\n        AST_Super,\n        AST_Switch,\n        AST_SwitchBranch,\n        AST_Symbol,\n        AST_SymbolCatch,\n        AST_SymbolClass,\n        AST_SymbolClassProperty,\n        AST_SymbolConst,\n        AST_SymbolDeclaration,\n        AST_SymbolDefun,\n        AST_SymbolExport,\n        AST_SymbolFunarg,\n        AST_SymbolImport,\n        AST_SymbolLambda,\n        AST_SymbolLet,\n        AST_SymbolMethod,\n        AST_SymbolRef,\n        AST_SymbolVar,\n        AST_Template,\n        AST_TemplateString,\n        AST_This,\n        AST_Throw,\n        AST_Toplevel,\n        AST_True,\n        AST_Try,\n        AST_Unary,\n        AST_UnaryPostfix,\n        AST_UnaryPrefix,\n        AST_Undefined,\n        AST_Var,\n        AST_VarDef,\n        AST_While,\n        AST_With,\n        AST_Yield,\n\n        TreeTransformer,\n        TreeWalker,\n\n        _INLINE,\n        _NOINLINE,\n        _PURE,\n\n        first_in_statement,\n        root_expr,\n        is_arrow,\n        is_generator,\n        is_statement,\n        is_async,\n        walk_body,\n        walk_lambda\n    } = m_ast;\n\n    const {\n        all,\n        defaults,\n        Dictionary,\n        find_if,\n        has_annotation,\n        HOP,\n        List,\n        make_node,\n        makePredicate,\n        MAP,\n        member,\n        noop,\n        push_uniq,\n        regexp_source_fix,\n        regexp_is_safe,\n        remove,\n        return_false,\n        return_null,\n        return_true,\n        return_this\n    } = m_utils; \n\n    const {\n        is_basic_identifier_string,\n        JS_Parse_Error,\n        parse,\n        PRECEDENCE,\n        decode_escape_sequence,\n        is_identifier_string,\n\n        UNARY_POSTFIX \n    } = m_parse;\n\n    const  { OutputStream } = m_output;\n\n    const { \n        base54, \n        is_lhs,\n        is_funarg,\n        unary_side_effects\n    } = m_scope;\n\n    function Compressor(options, false_by_default) {\n        if (!(this instanceof Compressor))\n            return new Compressor(options, false_by_default);\n        TreeTransformer.call(this, this.before, this.after);\n        this.options = defaults(options, {\n            annotations     : !false_by_default,\n            arguments       : !false_by_default,\n            arrows          : !false_by_default,\n            assignments     : !false_by_default,\n            awaits          : !false_by_default,\n            booleans        : !false_by_default,\n            collapse_vars   : !false_by_default,\n            comparisons     : !false_by_default,\n            conditionals    : !false_by_default,\n            dead_code       : !false_by_default,\n            default_values  : !false_by_default,\n            directives      : !false_by_default,\n            drop_console    : false,\n            drop_debugger   : !false_by_default,\n            evaluate        : !false_by_default,\n            expression      : false,\n            functions       : !false_by_default,\n            global_defs     : false,\n            hoist_exports   : !false_by_default,\n            hoist_funs      : false,\n            hoist_props     : !false_by_default,\n            hoist_vars      : false,\n            ie              : false,\n            if_return       : !false_by_default,\n            imports         : !false_by_default,\n            inline          : !false_by_default,\n            join_vars       : !false_by_default,\n            keep_fargs      : false_by_default,\n            keep_fnames     : false,\n            keep_infinity   : false,\n            loops           : !false_by_default,\n            merge_vars      : !false_by_default,\n            module          : false,\n            negate_iife     : !false_by_default,\n            objects         : !false_by_default,\n            optional_chains : !false_by_default,\n            passes          : 1,\n            properties      : !false_by_default,\n            pure_funcs      : null,\n            pure_getters    : !false_by_default && \"strict\",\n            reduce_funcs    : !false_by_default,\n            reduce_vars     : !false_by_default,\n            rests           : !false_by_default,\n            sequences       : !false_by_default,\n            side_effects    : !false_by_default,\n            spreads         : !false_by_default,\n            strings         : !false_by_default,\n            switches        : !false_by_default,\n            templates       : !false_by_default,\n            top_retain      : null,\n            toplevel        : !!(options && (options[\"module\"] || options[\"top_retain\"])),\n            typeofs         : !false_by_default,\n            unsafe          : false,\n            unsafe_comps    : false,\n            unsafe_Function : false,\n            unsafe_math     : false,\n            unsafe_proto    : false,\n            unsafe_regexp   : false,\n            unsafe_undefined: false,\n            unused          : !false_by_default,\n            varify          : !false_by_default,\n            webkit          : false,\n            yields          : !false_by_default,\n        }, true);\n        var evaluate = this.options[\"evaluate\"];\n        this.eval_threshold = /eager/.test(evaluate) ? 1 / 0 : +evaluate;\n        var global_defs = this.options[\"global_defs\"];\n        if (typeof global_defs == \"object\") for (var key in global_defs) {\n            if (/^@/.test(key) && HOP(global_defs, key)) {\n                global_defs[key.slice(1)] = parse(global_defs[key], { expression: true });\n            }\n        }\n        if (this.options[\"inline\"] === true) this.options[\"inline\"] = 4;\n        this.drop_fargs = this.options[\"keep_fargs\"] ? return_false : function(lambda, parent) {\n            if (lambda.length_read) return false;\n            var name = lambda.name;\n            if (!name) return parent && parent.TYPE == \"Call\" && parent.expression === lambda;\n            if (name.fixed_value() !== lambda) return false;\n            var def = name.definition();\n            if (def.direct_access) return false;\n            var escaped = def.escaped;\n            return escaped && escaped.depth != 1;\n        };\n        if (this.options[\"module\"]) this.directives[\"use strict\"] = true;\n        var pure_funcs = this.options[\"pure_funcs\"];\n        if (typeof pure_funcs == \"function\") {\n            this.pure_funcs = pure_funcs;\n        } else if (typeof pure_funcs == \"string\") {\n            this.pure_funcs = function(node) {\n                var expr;\n                if (node instanceof AST_Call) {\n                    expr = node.expression;\n                } else if (node instanceof AST_Template) {\n                    expr = node.tag;\n                }\n                return !(expr && pure_funcs === expr.print_to_string());\n            };\n        } else if (Array.isArray(pure_funcs)) {\n            this.pure_funcs = function(node) {\n                var expr;\n                if (node instanceof AST_Call) {\n                    expr = node.expression;\n                } else if (node instanceof AST_Template) {\n                    expr = node.tag;\n                }\n                return !(expr && member(expr.print_to_string(), pure_funcs));\n            };\n        } else {\n            this.pure_funcs = return_true;\n        }\n        var sequences = this.options[\"sequences\"];\n        this.sequences_limit = sequences == 1 ? 800 : sequences | 0;\n        var top_retain = this.options[\"top_retain\"];\n        if (top_retain instanceof RegExp) {\n            this.top_retain = function(def) {\n                return top_retain.test(def.name);\n            };\n        } else if (typeof top_retain == \"function\") {\n            this.top_retain = top_retain;\n        } else if (top_retain) {\n            if (typeof top_retain == \"string\") {\n                top_retain = top_retain.split(/,/);\n            }\n            this.top_retain = function(def) {\n                return member(def.name, top_retain);\n            };\n        }\n        var toplevel = this.options[\"toplevel\"];\n        this.toplevel = typeof toplevel == \"string\" ? {\n            funcs: /funcs/.test(toplevel),\n            vars: /vars/.test(toplevel)\n        } : {\n            funcs: toplevel,\n            vars: toplevel\n        };\n    }\n\n    Compressor.prototype = new TreeTransformer(function(node, descend, in_list) {\n        if (node._squeezed) return node;\n        var is_scope = node instanceof AST_Scope;\n        if (is_scope) {\n            if (this.option(\"arrows\") && is_arrow(node) && node.value) {\n                node.body = [ node.first_statement() ];\n                node.value = null;\n            }\n            node.hoist_properties(this);\n            node.hoist_declarations(this);\n            node.process_returns(this);\n        }\n        // Before https://github.com/mishoo/UglifyJS/pull/1602 AST_Node.optimize()\n        // would call AST_Node.transform() if a different instance of AST_Node is\n        // produced after OPT().\n        // This corrupts TreeWalker.stack, which cause AST look-ups to malfunction.\n        // Migrate and defer all children's AST_Node.transform() to below, which\n        // will now happen after this parent AST_Node has been properly substituted\n        // thus gives a consistent AST snapshot.\n        descend(node, this);\n        // Existing code relies on how AST_Node.optimize() worked, and omitting the\n        // following replacement call would result in degraded efficiency of both\n        // output and performance.\n        descend(node, this);\n        var opt = node.optimize(this);\n        if (is_scope && opt === node && !this.has_directive(\"use asm\") && !opt.pinned()) {\n            opt.drop_unused(this);\n            if (opt.merge_variables(this)) opt.drop_unused(this);\n            descend(opt, this);\n        }\n        if (opt === node) opt._squeezed = true;\n        return opt;\n    });\n    Compressor.prototype.option = function(key) {\n        return this.options[key];\n    };\n    Compressor.prototype.exposed = function(def) {\n        if (def.exported) return true;\n        if (def.undeclared) return true;\n        if (!(def.global || def.scope.resolve() instanceof AST_Toplevel)) return false;\n        var toplevel = this.toplevel;\n        return !all(def.orig, function(sym) {\n            return toplevel[sym instanceof AST_SymbolDefun ? \"funcs\" : \"vars\"];\n        });\n    };\n    Compressor.prototype.compress = function(node) {\n        node = node.resolve_defines(this);\n        node.hoist_exports(this);\n        if (this.option(\"expression\")) node.process_expression(true);\n        var merge_vars = this.options.merge_vars;\n        var passes = +this.options.passes || 1;\n        var min_count = 1 / 0;\n        var stopping = false;\n        var mangle = { ie: this.option(\"ie\") };\n        for (var pass = 0; pass < passes; pass++) {\n            node.figure_out_scope(mangle);\n            if (pass > 0 || this.option(\"reduce_vars\"))\n                node.reset_opt_flags(this);\n            this.options.merge_vars = merge_vars && (stopping || pass == passes - 1);\n            node = node.transform(this);\n            if (passes > 1) {\n                var count = 0;\n                node.walk(new TreeWalker(function() {\n                    count++;\n                }));\n                AST_Node.info(\"pass {pass}: last_count: {min_count}, count: {count}\", {\n                    pass: pass,\n                    min_count: min_count,\n                    count: count,\n                });\n                if (count < min_count) {\n                    min_count = count;\n                    stopping = false;\n                } else if (stopping) {\n                    break;\n                } else {\n                    stopping = true;\n                }\n            }\n        }\n        if (this.option(\"expression\")) node.process_expression(false);\n        return node;\n    };\n\n    (function(OPT) {\n        OPT(AST_Node, function(self, compressor) {\n            return self;\n        });\n\n        AST_Toplevel.DEFMETHOD(\"hoist_exports\", function(compressor) {\n            if (!compressor.option(\"hoist_exports\")) return;\n            var body = this.body, props = [];\n            for (var i = 0; i < body.length; i++) {\n                var stat = body[i];\n                if (stat instanceof AST_ExportDeclaration) {\n                    body[i] = stat = stat.body;\n                    if (stat instanceof AST_Definitions) {\n                        stat.definitions.forEach(function(defn) {\n                            defn.name.match_symbol(export_symbol, true);\n                        });\n                    } else {\n                        export_symbol(stat.name);\n                    }\n                } else if (stat instanceof AST_ExportReferences) {\n                    body.splice(i--, 1);\n                    [].push.apply(props, stat.properties);\n                }\n            }\n            if (props.length) body.push(make_node(AST_ExportReferences, this, { properties: props }));\n\n            function export_symbol(sym) {\n                if (!(sym instanceof AST_SymbolDeclaration)) return;\n                var node = make_node(AST_SymbolExport, sym);\n                node.alias = make_node(AST_String, node, { value: node.name });\n                props.push(node);\n            }\n        });\n\n        AST_Scope.DEFMETHOD(\"process_expression\", function(insert, transform) {\n            var self = this;\n            var tt = new TreeTransformer(function(node) {\n                if (insert) {\n                    if (node instanceof AST_Directive) node = make_node(AST_SimpleStatement, node, {\n                        body: make_node(AST_String, node),\n                    });\n                    if (node instanceof AST_SimpleStatement) {\n                        return transform ? transform(node) : make_node(AST_Return, node, { value: node.body });\n                    }\n                } else if (node instanceof AST_Return) {\n                    if (transform) return transform(node);\n                    var value = node.value;\n                    if (value instanceof AST_String) return make_node(AST_Directive, value);\n                    return make_node(AST_SimpleStatement, node, {\n                        body: value || make_node(AST_UnaryPrefix, node, {\n                            operator: \"void\",\n                            expression: make_node(AST_Number, node, { value: 0 }),\n                        }),\n                    });\n                }\n                if (node instanceof AST_Block) {\n                    if (node instanceof AST_Lambda) {\n                        if (node !== self) return node;\n                    } else if (insert === \"awaits\" && node instanceof AST_Try) {\n                        if (node.bfinally) return node;\n                    }\n                    for (var index = node.body.length; --index >= 0;) {\n                        var stat = node.body[index];\n                        if (!is_declaration(stat, true)) {\n                            node.body[index] = stat.transform(tt);\n                            break;\n                        }\n                    }\n                } else if (node instanceof AST_If) {\n                    node.body = node.body.transform(tt);\n                    if (node.alternative) node.alternative = node.alternative.transform(tt);\n                } else if (node instanceof AST_With) {\n                    node.body = node.body.transform(tt);\n                }\n                return node;\n            });\n            self.transform(tt);\n        });\n        AST_Toplevel.DEFMETHOD(\"unwrap_expression\", function() {\n            var self = this;\n            switch (self.body.length) {\n              case 0:\n                return make_node(AST_UnaryPrefix, self, {\n                    operator: \"void\",\n                    expression: make_node(AST_Number, self, { value: 0 }),\n                });\n              case 1:\n                var stat = self.body[0];\n                if (stat instanceof AST_Directive) return make_node(AST_String, stat);\n                if (stat instanceof AST_SimpleStatement) return stat.body;\n              default:\n                return make_node(AST_Call, self, {\n                    expression: make_node(AST_Function, self, {\n                        argnames: [],\n                        body: self.body,\n                    }).init_vars(self),\n                    args: [],\n                });\n            }\n        });\n        AST_Node.DEFMETHOD(\"wrap_expression\", function() {\n            var self = this;\n            if (!is_statement(self)) self = make_node(AST_SimpleStatement, self, { body: self });\n            if (!(self instanceof AST_Toplevel)) self = make_node(AST_Toplevel, self, { body: [ self ] });\n            return self;\n        });\n\n        function read_property(obj, node) {\n            var key = node.get_property();\n            if (key instanceof AST_Node) return;\n            var value;\n            if (obj instanceof AST_Array) {\n                var elements = obj.elements;\n                if (key == \"length\") return make_node_from_constant(elements.length, obj);\n                if (typeof key == \"number\" && key in elements) value = elements[key];\n            } else if (obj instanceof AST_Lambda) {\n                if (key == \"length\") {\n                    obj.length_read = true;\n                    return make_node_from_constant(obj.argnames.length, obj);\n                }\n            } else if (obj instanceof AST_Object) {\n                key = \"\" + key;\n                var props = obj.properties;\n                for (var i = props.length; --i >= 0;) {\n                    var prop = props[i];\n                    if (!can_hoist_property(prop)) return;\n                    if (!value && props[i].key === key) value = props[i].value;\n                }\n            }\n            return value instanceof AST_SymbolRef && value.fixed_value() || value;\n        }\n\n        function is_read_only_fn(value, name) {\n            if (value instanceof AST_Boolean) return native_fns.Boolean[name];\n            if (value instanceof AST_Number) return native_fns.Number[name];\n            if (value instanceof AST_String) return native_fns.String[name];\n            if (name == \"valueOf\") return false;\n            if (value instanceof AST_Array) return native_fns.Array[name];\n            if (value instanceof AST_Lambda) return native_fns.Function[name];\n            if (value instanceof AST_Object) return native_fns.Object[name];\n            if (value instanceof AST_RegExp) return native_fns.RegExp[name] && !value.value.global;\n        }\n\n        function is_modified(compressor, tw, node, value, level, immutable, recursive) {\n            var parent = tw.parent(level);\n            if (compressor.option(\"unsafe\") && parent instanceof AST_Dot && is_read_only_fn(value, parent.property)) {\n                return;\n            }\n            var lhs = is_lhs(node, parent);\n            if (lhs) return lhs;\n            if (level == 0 && value && value.is_constant()) return;\n            if (parent instanceof AST_Array) return is_modified(compressor, tw, parent, parent, level + 1);\n            if (parent instanceof AST_Assign) switch (parent.operator) {\n              case \"=\":\n                return is_modified(compressor, tw, parent, value, level + 1, immutable, recursive);\n              case \"&&=\":\n              case \"||=\":\n              case \"??=\":\n                return is_modified(compressor, tw, parent, parent, level + 1);\n              default:\n                return;\n            }\n            if (parent instanceof AST_Binary) {\n                if (!lazy_op[parent.operator]) return;\n                return is_modified(compressor, tw, parent, parent, level + 1);\n            }\n            if (parent instanceof AST_Call) {\n                return !immutable\n                    && parent.expression === node\n                    && !parent.is_expr_pure(compressor)\n                    && (!(value instanceof AST_LambdaExpression) || !(parent instanceof AST_New) && value.contains_this());\n            }\n            if (parent instanceof AST_Conditional) {\n                if (parent.condition === node) return;\n                return is_modified(compressor, tw, parent, parent, level + 1);\n            }\n            if (parent instanceof AST_ForEnumeration) return parent.init === node;\n            if (parent instanceof AST_ObjectKeyVal) {\n                if (parent.value !== node) return;\n                var obj = tw.parent(level + 1);\n                return is_modified(compressor, tw, obj, obj, level + 2);\n            }\n            if (parent instanceof AST_PropAccess) {\n                if (parent.expression !== node) return;\n                var prop = read_property(value, parent);\n                return (!immutable || recursive) && is_modified(compressor, tw, parent, prop, level + 1);\n            }\n            if (parent instanceof AST_Sequence) {\n                if (parent.tail_node() !== node) return;\n                return is_modified(compressor, tw, parent, value, level + 1, immutable, recursive);\n            }\n        }\n\n        function is_lambda(node) {\n            return node instanceof AST_Class || node instanceof AST_Lambda;\n        }\n\n        function safe_for_extends(node) {\n            return node instanceof AST_Class || node instanceof AST_Defun || node instanceof AST_Function;\n        }\n\n        function is_arguments(def) {\n            return def.name == \"arguments\" && def.scope.uses_arguments;\n        }\n\n        function cross_scope(def, sym) {\n            do {\n                if (def === sym) return false;\n                if (sym instanceof AST_Scope) return true;\n            } while (sym = sym.parent_scope);\n        }\n\n        function can_drop_symbol(ref, compressor, keep_lambda) {\n            var def = ref.redef || ref.definition();\n            if (ref.in_arg && is_funarg(def)) return false;\n            return all(def.orig, function(sym) {\n                if (sym instanceof AST_SymbolConst || sym instanceof AST_SymbolLet) {\n                    if (sym instanceof AST_SymbolImport) return true;\n                    return compressor && can_varify(compressor, sym);\n                }\n                return !(keep_lambda && sym instanceof AST_SymbolLambda);\n            });\n        }\n\n        function has_escaped(d, scope, node, parent) {\n            if (parent instanceof AST_Assign) return parent.operator == \"=\" && parent.right === node;\n            if (parent instanceof AST_Call) return parent.expression !== node || parent instanceof AST_New;\n            if (parent instanceof AST_ClassField) return parent.value === node && !parent.static;\n            if (parent instanceof AST_Exit) return parent.value === node && scope.resolve() !== d.scope.resolve();\n            if (parent instanceof AST_VarDef) return parent.value === node;\n        }\n\n        function make_ref(ref, fixed) {\n            var node = make_node(AST_SymbolRef, ref);\n            node.fixed = fixed || make_node(AST_Undefined, ref);\n            return node;\n        }\n\n        function replace_ref(resolve, fixed) {\n            return function(node) {\n                var ref = resolve(node);\n                var node = make_ref(ref, fixed);\n                var def = ref.definition();\n                def.references.push(node);\n                def.replaced++;\n                return node;\n            };\n        }\n\n        var RE_POSITIVE_INTEGER = /^(0|[1-9][0-9]*)$/;\n        (function(def) {\n            def(AST_Node, noop);\n\n            function reset_def(tw, compressor, def) {\n                def.assignments = 0;\n                def.bool_return = 0;\n                def.drop_return = 0;\n                def.cross_loop = false;\n                def.direct_access = false;\n                def.escaped = [];\n                def.fixed = !def.const_redefs\n                    && !def.scope.pinned()\n                    && !compressor.exposed(def)\n                    && !(def.init instanceof AST_LambdaExpression && def.init !== def.scope)\n                    && def.init;\n                def.reassigned = 0;\n                def.recursive_refs = 0;\n                def.references = [];\n                def.single_use = undefined;\n            }\n\n            function reset_block_variables(tw, compressor, scope) {\n                scope.variables.each(function(def) {\n                    reset_def(tw, compressor, def);\n                });\n            }\n\n            function reset_variables(tw, compressor, scope) {\n                scope.fn_defs = [];\n                scope.variables.each(function(def) {\n                    reset_def(tw, compressor, def);\n                    var init = def.init;\n                    if (init instanceof AST_LambdaDefinition) {\n                        scope.fn_defs.push(init);\n                        init.safe_ids = null;\n                    }\n                    if (def.fixed === null) {\n                        def.safe_ids = tw.safe_ids;\n                        mark(tw, def);\n                    } else if (def.fixed) {\n                        tw.loop_ids[def.id] = tw.in_loop;\n                        mark(tw, def);\n                    }\n                });\n                scope.may_call_this = function() {\n                    scope.may_call_this = scope.contains_this() ? return_true : return_false;\n                };\n                if (scope.uses_arguments) scope.each_argname(function(node) {\n                    node.definition().last_ref = false;\n                });\n                if (compressor.option(\"ie\")) scope.variables.each(function(def) {\n                    var d = def.orig[0].definition();\n                    if (d !== def) d.fixed = false;\n                });\n            }\n\n            function safe_to_visit(tw, fn) {\n                var marker = fn.safe_ids;\n                return marker === undefined || marker === tw.safe_ids;\n            }\n\n            function walk_fn_def(tw, fn) {\n                var was_scanning = tw.fn_scanning;\n                tw.fn_scanning = fn;\n                fn.walk(tw);\n                tw.fn_scanning = was_scanning;\n            }\n\n            function revisit_fn_def(tw, fn) {\n                fn.enclosed.forEach(function(d) {\n                    if (fn.variables.get(d.name) === d) return;\n                    if (safe_to_read(tw, d)) return;\n                    d.single_use = false;\n                    var fixed = d.fixed;\n                    if (typeof fixed == \"function\") fixed = fixed();\n                    if (fixed instanceof AST_Lambda && fixed.safe_ids !== undefined) return;\n                    d.fixed = false;\n                });\n            }\n\n            function mark_fn_def(tw, def, fn) {\n                var marker = fn.safe_ids;\n                if (marker === undefined) return;\n                if (marker === false) return;\n                if (fn.parent_scope.resolve().may_call_this === return_true) {\n                    if (member(fn, tw.fn_visited)) revisit_fn_def(tw, fn);\n                } else if (marker) {\n                    var visited = member(fn, tw.fn_visited);\n                    if (marker === tw.safe_ids) {\n                        if (!visited) walk_fn_def(tw, fn);\n                    } else if (visited) {\n                        revisit_fn_def(tw, fn);\n                    } else {\n                        fn.safe_ids = false;\n                    }\n                } else if (tw.fn_scanning && tw.fn_scanning !== def.scope.resolve()) {\n                    fn.safe_ids = false;\n                } else {\n                    fn.safe_ids = tw.safe_ids;\n                    walk_fn_def(tw, fn);\n                }\n            }\n\n            function pop_scope(tw, scope) {\n                var fn_defs = scope.fn_defs;\n                var tangled = scope.may_call_this === return_true ? fn_defs : fn_defs.filter(function(fn) {\n                    if (fn.safe_ids === false) return true;\n                    fn.safe_ids = tw.safe_ids;\n                    walk_fn_def(tw, fn);\n                    return false;\n                });\n                pop(tw);\n                tangled.forEach(function(fn) {\n                    fn.safe_ids = tw.safe_ids;\n                    walk_fn_def(tw, fn);\n                });\n                fn_defs.forEach(function(fn) {\n                    fn.safe_ids = undefined;\n                });\n                scope.fn_defs = undefined;\n                scope.may_call_this = undefined;\n            }\n\n            function push(tw, sequential) {\n                var safe_ids = Object.create(tw.safe_ids);\n                if (!sequential) safe_ids.seq = {};\n                tw.safe_ids = safe_ids;\n            }\n\n            function pop(tw) {\n                tw.safe_ids = Object.getPrototypeOf(tw.safe_ids);\n            }\n\n            function mark(tw, def) {\n                tw.safe_ids[def.id] = {};\n            }\n\n            function push_ref(def, ref) {\n                def.references.push(ref);\n                if (def.last_ref !== false) def.last_ref = ref;\n            }\n\n            function safe_to_read(tw, def) {\n                if (def.single_use == \"m\") return false;\n                var safe = tw.safe_ids[def.id];\n                if (safe) {\n                    var in_order = HOP(tw.safe_ids, def.id);\n                    if (!in_order) {\n                        var seq = tw.safe_ids.seq;\n                        if (!safe.read) {\n                            safe.read = seq;\n                        } else if (safe.read !== seq) {\n                            safe.read = true;\n                        }\n                    }\n                    if (def.fixed == null) {\n                        if (is_arguments(def)) return false;\n                        if (def.global && def.name == \"arguments\") return false;\n                        tw.loop_ids[def.id] = null;\n                        def.fixed = make_node(AST_Undefined, def.orig[0]);\n                        if (in_order) def.safe_ids = undefined;\n                        return true;\n                    }\n                    return !safe.assign || safe.assign === tw.safe_ids;\n                }\n                return def.fixed instanceof AST_LambdaDefinition;\n            }\n\n            function safe_to_assign(tw, def, declare) {\n                if (!declare) {\n                    if (is_funarg(def) && def.scope.uses_arguments && !tw.has_directive(\"use strict\")) return false;\n                    if (!all(def.orig, function(sym) {\n                        return !(sym instanceof AST_SymbolConst);\n                    })) return false;\n                }\n                if (def.fixed === undefined) return declare || all(def.orig, function(sym) {\n                    return !(sym instanceof AST_SymbolLet);\n                });\n                if (def.fixed === false || def.fixed === 0) return false;\n                var safe = tw.safe_ids[def.id];\n                if (def.safe_ids) {\n                    def.safe_ids[def.id] = false;\n                    def.safe_ids = undefined;\n                    return def.fixed === null || HOP(tw.safe_ids, def.id) && !safe.read;\n                }\n                if (!HOP(tw.safe_ids, def.id)) {\n                    if (!safe) return false;\n                    if (safe.read || tw.in_loop) {\n                        var scope = tw.find_parent(AST_BlockScope);\n                        if (scope instanceof AST_Class) return false;\n                        if (def.scope.resolve() !== scope.resolve()) return false;\n                    }\n                    safe.assign = safe.assign && safe.assign !== tw.safe_ids ? true : tw.safe_ids;\n                }\n                if (def.fixed != null && safe.read) {\n                    if (safe.read !== tw.safe_ids.seq) return false;\n                    if (tw.loop_ids[def.id] !== tw.in_loop) return false;\n                }\n                return safe_to_read(tw, def) && all(def.orig, function(sym) {\n                    return !(sym instanceof AST_SymbolLambda);\n                });\n            }\n\n            function ref_once(compressor, def) {\n                return compressor.option(\"unused\")\n                    && !def.scope.pinned()\n                    && def.single_use !== false\n                    && def.references.length - def.recursive_refs == 1\n                    && !(is_funarg(def) && def.scope.uses_arguments);\n            }\n\n            function is_immutable(value) {\n                if (!value) return false;\n                if (value instanceof AST_Assign) {\n                    var op = value.operator;\n                    return op == \"=\" ? is_immutable(value.right) : !lazy_op[op.slice(0, -1)];\n                }\n                if (value instanceof AST_Sequence) return is_immutable(value.tail_node());\n                return value.is_constant() || is_lambda(value) || value instanceof AST_ObjectIdentity;\n            }\n\n            function value_in_use(node, parent) {\n                if (parent instanceof AST_Array) return true;\n                if (parent instanceof AST_Binary) return lazy_op[parent.operator];\n                if (parent instanceof AST_Conditional) return parent.condition !== node;\n                if (parent instanceof AST_Sequence) return parent.tail_node() === node;\n                if (parent instanceof AST_Spread) return true;\n            }\n\n            function mark_escaped(tw, d, scope, node, value, level, depth) {\n                var parent = tw.parent(level);\n                if (value && value.is_constant()) return;\n                if (has_escaped(d, scope, node, parent)) {\n                    d.escaped.push(parent);\n                    if (depth > 1 && !(value && value.is_constant_expression(scope))) depth = 1;\n                    if (!d.escaped.depth || d.escaped.depth > depth) d.escaped.depth = depth;\n                    if (d.scope.resolve() !== scope.resolve()) d.escaped.cross_scope = true;\n                    if (d.fixed) d.fixed.escaped = d.escaped;\n                    return;\n                } else if (value_in_use(node, parent)) {\n                    mark_escaped(tw, d, scope, parent, parent, level + 1, depth);\n                } else if (parent instanceof AST_ObjectKeyVal && parent.value === node) {\n                    var obj = tw.parent(level + 1);\n                    mark_escaped(tw, d, scope, obj, obj, level + 2, depth);\n                } else if (parent instanceof AST_PropAccess && parent.expression === node) {\n                    value = read_property(value, parent);\n                    mark_escaped(tw, d, scope, parent, value, level + 1, depth + 1);\n                    if (value) return;\n                }\n                if (level > 0) return;\n                if (parent instanceof AST_Call && parent.expression === node) return;\n                if (parent instanceof AST_Sequence && parent.tail_node() !== node) return;\n                if (parent instanceof AST_SimpleStatement) return;\n                if (parent instanceof AST_Unary && !unary_side_effects[parent.operator]) return;\n                d.direct_access = true;\n                if (d.fixed) d.fixed.direct_access = true;\n            }\n\n            function mark_assignment_to_arguments(node) {\n                if (!(node instanceof AST_Sub)) return;\n                var expr = node.expression;\n                if (!(expr instanceof AST_SymbolRef)) return;\n                var def = expr.definition();\n                if (!is_arguments(def)) return;\n                var key = node.property;\n                if (key.is_constant()) key = key.value;\n                if (!(key instanceof AST_Node) && !RE_POSITIVE_INTEGER.test(key)) return;\n                def.reassigned++;\n                (key instanceof AST_Node ? def.scope.argnames : [ def.scope.argnames[key] ]).forEach(function(argname) {\n                    if (argname instanceof AST_SymbolFunarg) argname.definition().fixed = false;\n                });\n            }\n\n            function make_fixed(save, fn) {\n                var prev_save, prev_value;\n                return function() {\n                    var current = save();\n                    if (prev_save !== current) {\n                        prev_save = current;\n                        prev_value = fn(current);\n                    }\n                    return prev_value;\n                };\n            }\n\n            function make_fixed_default(compressor, node, save) {\n                var prev_save, prev_seq;\n                return function() {\n                    if (prev_seq === node) return node;\n                    var current = save();\n                    var ev = fuzzy_eval(compressor, current, true);\n                    if (ev instanceof AST_Node) {\n                        prev_seq = node;\n                    } else if (prev_save !== current) {\n                        prev_save = current;\n                        prev_seq = ev === undefined ? make_sequence(node, [ current, node.value ]) : current;\n                    }\n                    return prev_seq;\n                };\n            }\n\n            function scan_declaration(tw, compressor, lhs, fixed, visit) {\n                var scanner = new TreeWalker(function(node) {\n                    if (node instanceof AST_DefaultValue) {\n                        reset_flags(node);\n                        push(tw, true);\n                        node.value.walk(tw);\n                        pop(tw);\n                        var save = fixed;\n                        if (save) fixed = make_fixed_default(compressor, node, save);\n                        node.name.walk(scanner);\n                        fixed = save;\n                        return true;\n                    }\n                    if (node instanceof AST_DestructuredArray) {\n                        reset_flags(node);\n                        var save = fixed;\n                        node.elements.forEach(function(node, index) {\n                            if (node instanceof AST_Hole) return reset_flags(node);\n                            if (save) fixed = make_fixed(save, function(value) {\n                                return make_node(AST_Sub, node, {\n                                    expression: value,\n                                    property: make_node(AST_Number, node, { value: index }),\n                                });\n                            });\n                            node.walk(scanner);\n                        });\n                        if (node.rest) {\n                            var fixed_node;\n                            if (save) fixed = compressor.option(\"rests\") && make_fixed(save, function(value) {\n                                if (!(value instanceof AST_Array)) return node;\n                                for (var i = 0, len = node.elements.length; i < len; i++) {\n                                    if (value.elements[i] instanceof AST_Spread) return node;\n                                }\n                                if (!fixed_node) fixed_node = make_node(AST_Array, node, {});\n                                fixed_node.elements = value.elements.slice(len);\n                                return fixed_node;\n                            });\n                            node.rest.walk(scanner);\n                        }\n                        fixed = save;\n                        return true;\n                    }\n                    if (node instanceof AST_DestructuredObject) {\n                        reset_flags(node);\n                        var save = fixed;\n                        node.properties.forEach(function(node) {\n                            reset_flags(node);\n                            if (node.key instanceof AST_Node) {\n                                push(tw);\n                                node.key.walk(tw);\n                                pop(tw);\n                            }\n                            if (save) fixed = make_fixed(save, function(value) {\n                                var key = node.key;\n                                var type = AST_Sub;\n                                if (typeof key == \"string\") {\n                                    if (is_identifier_string(key)) {\n                                        type = AST_Dot;\n                                    } else {\n                                        key = make_node_from_constant(key, node);\n                                    }\n                                }\n                                return make_node(type, node, {\n                                    expression: value,\n                                    property: key,\n                                });\n                            });\n                            node.value.walk(scanner);\n                        });\n                        if (node.rest) {\n                            fixed = false;\n                            node.rest.walk(scanner);\n                        }\n                        fixed = save;\n                        return true;\n                    }\n                    visit(node, fixed, function() {\n                        var save_len = tw.stack.length;\n                        for (var i = 0, len = scanner.stack.length - 1; i < len; i++) {\n                            tw.stack.push(scanner.stack[i]);\n                        }\n                        node.walk(tw);\n                        tw.stack.length = save_len;\n                    });\n                    return true;\n                });\n                lhs.walk(scanner);\n            }\n\n            function reduce_iife(tw, descend, compressor) {\n                var fn = this;\n                fn.inlined = false;\n                var iife = tw.parent();\n                var sequential = !is_async(fn) && !is_generator(fn);\n                var hit = !sequential;\n                var aborts = false;\n                fn.walk(new TreeWalker(function(node) {\n                    if (hit) return aborts = true;\n                    if (node instanceof AST_Return) return hit = true;\n                    if (node instanceof AST_Scope && node !== fn) return true;\n                }));\n                if (aborts) push(tw, sequential);\n                reset_variables(tw, compressor, fn);\n                // Virtually turn IIFE parameters into variable definitions:\n                //   (function(a,b) {...})(c,d) ---> (function() {var a=c,b=d; ...})()\n                // So existing transformation rules can work on them.\n                var safe = !fn.uses_arguments || tw.has_directive(\"use strict\");\n                fn.argnames.forEach(function(argname, i) {\n                    var value = iife.args[i];\n                    scan_declaration(tw, compressor, argname, function() {\n                        var j = fn.argnames.indexOf(argname);\n                        var arg = j < 0 ? value : iife.args[j];\n                        if (arg instanceof AST_Sequence && arg.expressions.length < 2) arg = arg.expressions[0];\n                        return arg || make_node(AST_Undefined, iife);\n                    }, visit);\n                });\n                var rest = fn.rest, fixed_node;\n                if (rest) scan_declaration(tw, compressor, rest, compressor.option(\"rests\") && function() {\n                    if (fn.rest !== rest) return rest;\n                    if (!fixed_node) fixed_node = make_node(AST_Array, fn, {});\n                    fixed_node.elements = iife.args.slice(fn.argnames.length);\n                    return fixed_node;\n                }, visit);\n                walk_lambda(fn, tw);\n                var safe_ids = tw.safe_ids;\n                pop_scope(tw, fn);\n                if (!aborts) tw.safe_ids = safe_ids;\n                return true;\n\n                function visit(node, fixed) {\n                    var d = node.definition();\n                    if (fixed && safe && d.fixed === undefined) {\n                        mark(tw, d);\n                        tw.loop_ids[d.id] = tw.in_loop;\n                        d.fixed = fixed;\n                        d.fixed.assigns = [ node ];\n                    } else {\n                        d.fixed = false;\n                    }\n                }\n            }\n\n            def(AST_Assign, function(tw, descend, compressor) {\n                var node = this;\n                var left = node.left;\n                var right = node.right;\n                var ld = left instanceof AST_SymbolRef && left.definition();\n                var scan = ld || left instanceof AST_Destructured;\n                switch (node.operator) {\n                  case \"=\":\n                    if (left.equals(right) && !left.has_side_effects(compressor)) {\n                        right.walk(tw);\n                        walk_prop(left);\n                        node.redundant = true;\n                        return true;\n                    }\n                    if (ld && right instanceof AST_LambdaExpression) {\n                        walk_assign();\n                        right.parent_scope.resolve().fn_defs.push(right);\n                        right.safe_ids = null;\n                        if (!ld.fixed || !node.write_only) mark_fn_def(tw, ld, right);\n                        return true;\n                    }\n                    if (scan) {\n                        right.walk(tw);\n                        walk_assign();\n                        return true;\n                    }\n                    mark_assignment_to_arguments(left);\n                    return;\n                  case \"&&=\":\n                  case \"||=\":\n                  case \"??=\":\n                    var lazy = true;\n                  default:\n                    if (!scan) {\n                        mark_assignment_to_arguments(left);\n                        return walk_lazy();\n                    }\n                    ld.assignments++;\n                    var fixed = ld.fixed;\n                    if (is_modified(compressor, tw, node, node, 0)) {\n                        ld.fixed = false;\n                        return walk_lazy();\n                    }\n                    var safe = safe_to_read(tw, ld);\n                    if (lazy) push(tw, true);\n                    right.walk(tw);\n                    if (lazy) pop(tw);\n                    if (safe && !left.in_arg && safe_to_assign(tw, ld)) {\n                        push_ref(ld, left);\n                        mark(tw, ld);\n                        if (ld.single_use) ld.single_use = false;\n                        left.fixed = ld.fixed = function() {\n                            return make_node(AST_Binary, node, {\n                                operator: node.operator.slice(0, -1),\n                                left: make_ref(left, fixed),\n                                right: node.right,\n                            });\n                        };\n                        left.fixed.assigns = !fixed || !fixed.assigns ? [ ld.orig[0] ] : fixed.assigns.slice();\n                        left.fixed.assigns.push(node);\n                        left.fixed.to_binary = replace_ref(function(node) {\n                            return node.left;\n                        }, fixed);\n                    } else {\n                        left.walk(tw);\n                        ld.fixed = false;\n                    }\n                    return true;\n                }\n\n                function walk_prop(lhs) {\n                    reset_flags(lhs);\n                    if (lhs instanceof AST_Dot) {\n                        walk_prop(lhs.expression);\n                    } else if (lhs instanceof AST_Sub) {\n                        walk_prop(lhs.expression);\n                        lhs.property.walk(tw);\n                    } else if (lhs instanceof AST_SymbolRef) {\n                        var d = lhs.definition();\n                        push_ref(d, lhs);\n                        if (d.fixed) {\n                            lhs.fixed = d.fixed;\n                            if (lhs.fixed.assigns) {\n                                lhs.fixed.assigns.push(node);\n                            } else {\n                                lhs.fixed.assigns = [ node ];\n                            }\n                        }\n                    } else {\n                        lhs.walk(tw);\n                    }\n                }\n\n                function walk_assign() {\n                    var recursive = ld && recursive_ref(tw, ld);\n                    var modified = is_modified(compressor, tw, node, right, 0, is_immutable(right), recursive);\n                    scan_declaration(tw, compressor, left, function() {\n                        return node.right;\n                    }, function(sym, fixed, walk) {\n                        if (!(sym instanceof AST_SymbolRef)) {\n                            mark_assignment_to_arguments(sym);\n                            walk();\n                            return;\n                        }\n                        var d = sym.definition();\n                        d.assignments++;\n                        if (!fixed || sym.in_arg || !safe_to_assign(tw, d)) {\n                            walk();\n                            d.fixed = false;\n                        } else {\n                            push_ref(d, sym);\n                            mark(tw, d);\n                            if (left instanceof AST_Destructured\n                                || d.orig.length == 1 && d.orig[0] instanceof AST_SymbolDefun) {\n                                d.single_use = false;\n                            }\n                            tw.loop_ids[d.id] = tw.in_loop;\n                            d.fixed = modified ? 0 : fixed;\n                            sym.fixed = fixed;\n                            sym.fixed.assigns = [ node ];\n                            mark_escaped(tw, d, sym.scope, node, right, 0, 1);\n                        }\n                    });\n                }\n\n                function walk_lazy() {\n                    if (!lazy) return;\n                    left.walk(tw);\n                    push(tw, true);\n                    right.walk(tw);\n                    pop(tw);\n                    return true;\n                }\n            });\n            def(AST_Binary, function(tw) {\n                if (!lazy_op[this.operator]) return;\n                this.left.walk(tw);\n                push(tw, true);\n                this.right.walk(tw);\n                pop(tw);\n                return true;\n            });\n            def(AST_BlockScope, function(tw, descend, compressor) {\n                reset_block_variables(tw, compressor, this);\n            });\n            def(AST_Call, function(tw, descend) {\n                var node = this;\n                var exp = node.expression;\n                if (exp instanceof AST_LambdaExpression) {\n                    var iife = is_iife_single(node);\n                    node.args.forEach(function(arg) {\n                        arg.walk(tw);\n                        if (arg instanceof AST_Spread) iife = false;\n                    });\n                    if (iife) exp.reduce_vars = reduce_iife;\n                    exp.walk(tw);\n                    if (iife) delete exp.reduce_vars;\n                    return true;\n                }\n                if (node.TYPE == \"Call\") switch (tw.in_boolean_context()) {\n                  case \"d\":\n                    var drop = true;\n                  case true:\n                    mark_refs(exp, drop);\n                }\n                exp.walk(tw);\n                var optional = node.optional;\n                if (optional) push(tw, true);\n                node.args.forEach(function(arg) {\n                    arg.walk(tw);\n                });\n                if (optional) pop(tw);\n                var fixed = exp instanceof AST_SymbolRef && exp.fixed_value();\n                if (fixed instanceof AST_Lambda) {\n                    mark_fn_def(tw, exp.definition(), fixed);\n                } else {\n                    tw.find_parent(AST_Scope).may_call_this();\n                }\n                return true;\n\n                function mark_refs(node, drop) {\n                    if (node instanceof AST_Assign) {\n                        if (node.operator != \"=\") return;\n                        mark_refs(node.left, drop);\n                        mark_refs(node.right, drop);\n                    } else if (node instanceof AST_Binary) {\n                        if (!lazy_op[node.operator]) return;\n                        mark_refs(node.left, drop);\n                        mark_refs(node.right, drop);\n                    } else if (node instanceof AST_Conditional) {\n                        mark_refs(node.consequent, drop);\n                        mark_refs(node.alternative, drop);\n                    } else if (node instanceof AST_SymbolRef) {\n                        var def = node.definition();\n                        def.bool_return++;\n                        if (drop) def.drop_return++;\n                    }\n                }\n            });\n            def(AST_Class, function(tw, descend, compressor) {\n                var node = this;\n                reset_block_variables(tw, compressor, node);\n                if (node.extends) node.extends.walk(tw);\n                var props = node.properties.filter(function(prop) {\n                    reset_flags(prop);\n                    if (prop.key instanceof AST_Node) {\n                        tw.push(prop);\n                        prop.key.walk(tw);\n                        tw.pop();\n                    }\n                    return prop.value;\n                });\n                if (node.name) {\n                    var d = node.name.definition();\n                    var parent = tw.parent();\n                    if (parent instanceof AST_ExportDeclaration || parent instanceof AST_ExportDefault) d.single_use = false;\n                    if (safe_to_assign(tw, d, true)) {\n                        mark(tw, d);\n                        tw.loop_ids[d.id] = tw.in_loop;\n                        d.fixed = function() {\n                            return node;\n                        };\n                        d.fixed.assigns = [ node ];\n                        if (!is_safe_lexical(d)) d.single_use = false;\n                    } else {\n                        d.fixed = false;\n                    }\n                }\n                props.forEach(function(prop) {\n                    tw.push(prop);\n                    if (!prop.static || is_static_field_or_init(prop) && prop.value.contains_this()) {\n                        push(tw);\n                        prop.value.walk(tw);\n                        pop(tw);\n                    } else {\n                        prop.value.walk(tw);\n                    }\n                    tw.pop();\n                });\n                return true;\n            });\n            def(AST_ClassInitBlock, function(tw, descend, compressor) {\n                var node = this;\n                push(tw, true);\n                reset_variables(tw, compressor, node);\n                descend();\n                pop_scope(tw, node);\n                return true;\n            });\n            def(AST_Conditional, function(tw) {\n                this.condition.walk(tw);\n                push(tw, true);\n                this.consequent.walk(tw);\n                pop(tw);\n                push(tw, true);\n                this.alternative.walk(tw);\n                pop(tw);\n                return true;\n            });\n            def(AST_DefaultValue, function(tw) {\n                push(tw, true);\n                this.value.walk(tw);\n                pop(tw);\n                this.name.walk(tw);\n                return true;\n            });\n            def(AST_Do, function(tw) {\n                var save_loop = tw.in_loop;\n                tw.in_loop = this;\n                push(tw);\n                this.body.walk(tw);\n                if (has_loop_control(this, tw.parent())) {\n                    pop(tw);\n                    push(tw);\n                }\n                this.condition.walk(tw);\n                pop(tw);\n                tw.in_loop = save_loop;\n                return true;\n            });\n            def(AST_For, function(tw, descend, compressor) {\n                var node = this;\n                reset_block_variables(tw, compressor, node);\n                if (node.init) node.init.walk(tw);\n                var save_loop = tw.in_loop;\n                tw.in_loop = node;\n                push(tw);\n                if (node.condition) node.condition.walk(tw);\n                node.body.walk(tw);\n                if (node.step) {\n                    if (has_loop_control(node, tw.parent())) {\n                        pop(tw);\n                        push(tw);\n                    }\n                    node.step.walk(tw);\n                }\n                pop(tw);\n                tw.in_loop = save_loop;\n                return true;\n            });\n            def(AST_ForEnumeration, function(tw, descend, compressor) {\n                var node = this;\n                reset_block_variables(tw, compressor, node);\n                node.object.walk(tw);\n                var save_loop = tw.in_loop;\n                tw.in_loop = node;\n                push(tw);\n                var init = node.init;\n                if (init instanceof AST_Definitions) {\n                    init.definitions[0].name.mark_symbol(function(node) {\n                        if (node instanceof AST_SymbolDeclaration) {\n                            var def = node.definition();\n                            def.assignments++;\n                            def.fixed = false;\n                        }\n                    }, tw);\n                } else if (init instanceof AST_Destructured || init instanceof AST_SymbolRef) {\n                    init.mark_symbol(function(node) {\n                        if (node instanceof AST_SymbolRef) {\n                            var def = node.definition();\n                            push_ref(def, node);\n                            def.assignments++;\n                            if (!node.is_immutable()) def.fixed = false;\n                        }\n                    }, tw);\n                } else {\n                    init.walk(tw);\n                }\n                node.body.walk(tw);\n                pop(tw);\n                tw.in_loop = save_loop;\n                return true;\n            });\n            def(AST_If, function(tw) {\n                this.condition.walk(tw);\n                push(tw, true);\n                this.body.walk(tw);\n                pop(tw);\n                if (this.alternative) {\n                    push(tw, true);\n                    this.alternative.walk(tw);\n                    pop(tw);\n                }\n                return true;\n            });\n            def(AST_LabeledStatement, function(tw) {\n                push(tw, true);\n                this.body.walk(tw);\n                pop(tw);\n                return true;\n            });\n            def(AST_Lambda, function(tw, descend, compressor) {\n                var fn = this;\n                if (!safe_to_visit(tw, fn)) return true;\n                if (!push_uniq(tw.fn_visited, fn)) return true;\n                fn.inlined = false;\n                push(tw);\n                reset_variables(tw, compressor, fn);\n                descend();\n                pop_scope(tw, fn);\n                if (fn.name) mark_escaped(tw, fn.name.definition(), fn, fn.name, fn, 0, 1);\n                return true;\n            });\n            def(AST_LambdaDefinition, function(tw, descend, compressor) {\n                var fn = this;\n                var def = fn.name.definition();\n                var parent = tw.parent();\n                if (parent instanceof AST_ExportDeclaration || parent instanceof AST_ExportDefault) def.single_use = false;\n                if (!safe_to_visit(tw, fn)) return true;\n                if (!push_uniq(tw.fn_visited, fn)) return true;\n                fn.inlined = false;\n                push(tw);\n                reset_variables(tw, compressor, fn);\n                descend();\n                pop_scope(tw, fn);\n                return true;\n            });\n            def(AST_Sub, function(tw) {\n                if (!this.optional) return;\n                this.expression.walk(tw);\n                push(tw, true);\n                this.property.walk(tw);\n                pop(tw);\n                return true;\n            });\n            def(AST_Switch, function(tw, descend, compressor) {\n                var node = this;\n                reset_block_variables(tw, compressor, node);\n                node.expression.walk(tw);\n                var first = true;\n                node.body.forEach(function(branch) {\n                    if (branch instanceof AST_Default) return;\n                    branch.expression.walk(tw);\n                    if (first) {\n                        first = false;\n                        push(tw, true);\n                    }\n                })\n                if (!first) pop(tw);\n                walk_body(node, tw);\n                return true;\n            });\n            def(AST_SwitchBranch, function(tw) {\n                push(tw, true);\n                walk_body(this, tw);\n                pop(tw);\n                return true;\n            });\n            def(AST_SymbolCatch, function() {\n                this.definition().fixed = false;\n            });\n            def(AST_SymbolImport, function() {\n                this.definition().fixed = false;\n            });\n            def(AST_SymbolRef, function(tw, descend, compressor) {\n                var ref = this;\n                var d = ref.definition();\n                var fixed = d.fixed || d.last_ref && d.last_ref.fixed;\n                push_ref(d, ref);\n                if (d.references.length == 1 && !d.fixed && d.orig[0] instanceof AST_SymbolDefun) {\n                    tw.loop_ids[d.id] = tw.in_loop;\n                }\n                var recursive = recursive_ref(tw, d);\n                if (recursive) recursive.enclosed.forEach(function(def) {\n                    if (d === def) return;\n                    if (def.scope.resolve() === recursive) return;\n                    var assigns = def.fixed && def.fixed.assigns;\n                    if (!assigns) return;\n                    if (assigns[assigns.length - 1] instanceof AST_VarDef) return;\n                    var safe = tw.safe_ids[def.id];\n                    if (!safe) return;\n                    safe.assign = true;\n                });\n                if (d.single_use == \"m\" && d.fixed) {\n                    d.fixed = 0;\n                    d.single_use = false;\n                }\n                switch (d.fixed) {\n                  case 0:\n                    if (!safe_to_read(tw, d)) d.fixed = false;\n                  case false:\n                    var redef = d.redefined();\n                    if (redef && cross_scope(d.scope, ref.scope)) redef.single_use = false;\n                    break;\n                  case undefined:\n                    d.fixed = false;\n                    break;\n                  default:\n                    if (!safe_to_read(tw, d)) {\n                        d.fixed = false;\n                        break;\n                    }\n                    if (ref.in_arg && d.orig[0] instanceof AST_SymbolLambda) ref.fixed = d.scope;\n                    var value = ref.fixed_value();\n                    if (recursive) {\n                        d.recursive_refs++;\n                    } else if (value && ref_once(compressor, d)) {\n                        d.in_loop = tw.loop_ids[d.id] !== tw.in_loop;\n                        d.single_use = is_lambda(value)\n                                && !value.pinned()\n                                && (!d.in_loop || tw.parent() instanceof AST_Call)\n                            || !d.in_loop\n                                && d.scope === ref.scope.resolve()\n                                && value.is_constant_expression();\n                    } else {\n                        d.single_use = false;\n                    }\n                    if (is_modified(compressor, tw, ref, value, 0, is_immutable(value), recursive)) {\n                        if (d.single_use) {\n                            d.single_use = \"m\";\n                        } else {\n                            d.fixed = 0;\n                        }\n                    }\n                    if (d.fixed && tw.loop_ids[d.id] !== tw.in_loop) d.cross_loop = true;\n                    mark_escaped(tw, d, ref.scope, ref, value, 0, 1);\n                    break;\n                }\n                if (!ref.fixed) ref.fixed = d.fixed === 0 ? fixed : d.fixed;\n                var parent;\n                if (value instanceof AST_Lambda\n                    && !((parent = tw.parent()) instanceof AST_Call && parent.expression === ref)) {\n                    mark_fn_def(tw, d, value);\n                }\n            });\n            def(AST_Template, function(tw, descend) {\n                var node = this;\n                var tag = node.tag;\n                if (!tag) return;\n                if (tag instanceof AST_LambdaExpression) {\n                    node.expressions.forEach(function(exp) {\n                        exp.walk(tw);\n                    });\n                    tag.walk(tw);\n                    return true;\n                }\n                tag.walk(tw);\n                node.expressions.forEach(function(exp) {\n                    exp.walk(tw);\n                });\n                var fixed = tag instanceof AST_SymbolRef && tag.fixed_value();\n                if (fixed instanceof AST_Lambda) {\n                    mark_fn_def(tw, tag.definition(), fixed);\n                } else {\n                    tw.find_parent(AST_Scope).may_call_this();\n                }\n                return true;\n            });\n            def(AST_Toplevel, function(tw, descend, compressor) {\n                var node = this;\n                node.globals.each(function(def) {\n                    reset_def(tw, compressor, def);\n                });\n                push(tw, true);\n                reset_variables(tw, compressor, node);\n                descend();\n                pop_scope(tw, node);\n                return true;\n            });\n            def(AST_Try, function(tw, descend, compressor) {\n                var node = this;\n                reset_block_variables(tw, compressor, node);\n                push(tw, true);\n                walk_body(node, tw);\n                pop(tw);\n                if (node.bcatch) {\n                    push(tw, true);\n                    node.bcatch.walk(tw);\n                    pop(tw);\n                }\n                if (node.bfinally) node.bfinally.walk(tw);\n                return true;\n            });\n            def(AST_Unary, function(tw, descend) {\n                var node = this;\n                if (!UNARY_POSTFIX[node.operator]) return;\n                var exp = node.expression;\n                if (!(exp instanceof AST_SymbolRef)) {\n                    mark_assignment_to_arguments(exp);\n                    return;\n                }\n                var d = exp.definition();\n                d.assignments++;\n                var fixed = d.fixed;\n                if (safe_to_read(tw, d) && !exp.in_arg && safe_to_assign(tw, d)) {\n                    push_ref(d, exp);\n                    mark(tw, d);\n                    if (d.single_use) d.single_use = false;\n                    d.fixed = function() {\n                        return make_node(AST_Binary, node, {\n                            operator: node.operator.slice(0, -1),\n                            left: make_node(AST_UnaryPrefix, node, {\n                                operator: \"+\",\n                                expression: make_ref(exp, fixed),\n                            }),\n                            right: make_node(AST_Number, node, { value: 1 }),\n                        });\n                    };\n                    d.fixed.assigns = fixed && fixed.assigns ? fixed.assigns.slice() : [];\n                    d.fixed.assigns.push(node);\n                    if (node instanceof AST_UnaryPrefix) {\n                        exp.fixed = d.fixed;\n                    } else {\n                        exp.fixed = function() {\n                            return make_node(AST_UnaryPrefix, node, {\n                                operator: \"+\",\n                                expression: make_ref(exp, fixed),\n                            });\n                        };\n                        exp.fixed.assigns = fixed && fixed.assigns;\n                        exp.fixed.to_prefix = replace_ref(function(node) {\n                            return node.expression;\n                        }, d.fixed);\n                    }\n                } else {\n                    exp.walk(tw);\n                    d.fixed = false;\n                }\n                return true;\n            });\n            def(AST_VarDef, function(tw, descend, compressor) {\n                var node = this;\n                var value = node.value;\n                if (value instanceof AST_LambdaExpression && node.name instanceof AST_SymbolDeclaration) {\n                    walk_defn();\n                    value.parent_scope.resolve().fn_defs.push(value);\n                    value.safe_ids = null;\n                    var ld = node.name.definition();\n                    if (!ld.fixed) mark_fn_def(tw, ld, value);\n                } else if (value) {\n                    value.walk(tw);\n                    walk_defn();\n                } else if (tw.parent() instanceof AST_Let) {\n                    walk_defn();\n                }\n                return true;\n\n                function walk_defn() {\n                    scan_declaration(tw, compressor, node.name, function() {\n                        return node.value || make_node(AST_Undefined, node);\n                    }, function(name, fixed) {\n                        var d = name.definition();\n                        if (fixed && safe_to_assign(tw, d, true)) {\n                            mark(tw, d);\n                            tw.loop_ids[d.id] = tw.in_loop;\n                            d.fixed = fixed;\n                            d.fixed.assigns = [ node ];\n                            if (name instanceof AST_SymbolConst && d.redefined()\n                                || !(can_drop_symbol(name) || is_safe_lexical(d))) {\n                                d.single_use = false;\n                            }\n                        } else {\n                            d.fixed = false;\n                        }\n                    });\n                }\n            });\n            def(AST_While, function(tw, descend) {\n                var save_loop = tw.in_loop;\n                tw.in_loop = this;\n                push(tw);\n                descend();\n                pop(tw);\n                tw.in_loop = save_loop;\n                return true;\n            });\n        })(function(node, func) {\n            node.DEFMETHOD(\"reduce_vars\", func);\n        });\n\n        function reset_flags(node) {\n            node._squeezed = false;\n            node._optimized = false;\n            if (node instanceof AST_BlockScope) node._var_names = undefined;\n            if (node instanceof AST_SymbolRef) node.fixed = undefined;\n        }\n\n        AST_Toplevel.DEFMETHOD(\"reset_opt_flags\", function(compressor) {\n            var tw = new TreeWalker(compressor.option(\"reduce_vars\") ? function(node, descend) {\n                reset_flags(node);\n                return node.reduce_vars(tw, descend, compressor);\n            } : reset_flags);\n            // Flow control for visiting lambda definitions\n            tw.fn_scanning = null;\n            tw.fn_visited = [];\n            // Record the loop body in which `AST_SymbolDeclaration` is first encountered\n            tw.in_loop = null;\n            tw.loop_ids = Object.create(null);\n            // Stack of look-up tables to keep track of whether a `SymbolDef` has been\n            // properly assigned before use:\n            // - `push()` & `pop()` when visiting conditional branches\n            // - backup & restore via `save_ids` when visiting out-of-order sections\n            tw.safe_ids = Object.create(null);\n            tw.safe_ids.seq = {};\n            this.walk(tw);\n        });\n\n        AST_Symbol.DEFMETHOD(\"fixed_value\", function(ref_only) {\n            var def = this.definition();\n            var fixed = def.fixed;\n            if (fixed) {\n                if (this.fixed) fixed = this.fixed;\n                return (fixed instanceof AST_Node ? fixed : fixed()).tail_node();\n            }\n            fixed = fixed === 0 && this.fixed;\n            if (!fixed) return fixed;\n            var value = (fixed instanceof AST_Node ? fixed : fixed()).tail_node();\n            if (ref_only && def.escaped.depth != 1 && is_object(value, true)) return value;\n            if (value.is_constant()) return value;\n        });\n\n        AST_SymbolRef.DEFMETHOD(\"is_immutable\", function() {\n            var def = this.redef || this.definition();\n            if (!(def.orig[0] instanceof AST_SymbolLambda)) return false;\n            if (def.orig.length == 1) return true;\n            if (!this.in_arg) return false;\n            return !(def.orig[1] instanceof AST_SymbolFunarg);\n        });\n\n        AST_Node.DEFMETHOD(\"convert_symbol\", noop);\n        function convert_destructured(type, process) {\n            return this.transform(new TreeTransformer(function(node, descend) {\n                if (node instanceof AST_DefaultValue) {\n                    node = node.clone();\n                    node.name = node.name.transform(this);\n                    return node;\n                }\n                if (node instanceof AST_Destructured) {\n                    node = node.clone();\n                    descend(node, this);\n                    return node;\n                }\n                if (node instanceof AST_DestructuredKeyVal) {\n                    node = node.clone();\n                    node.value = node.value.transform(this);\n                    return node;\n                }\n                return node.convert_symbol(type, process);\n            }));\n        }\n        AST_DefaultValue.DEFMETHOD(\"convert_symbol\", convert_destructured);\n        AST_Destructured.DEFMETHOD(\"convert_symbol\", convert_destructured);\n        function convert_symbol(type, process) {\n            var node = make_node(type, this);\n            return process(node, this) || node;\n        }\n        AST_SymbolDeclaration.DEFMETHOD(\"convert_symbol\", convert_symbol);\n        AST_SymbolRef.DEFMETHOD(\"convert_symbol\", convert_symbol);\n\n        function process_to_assign(ref) {\n            var def = ref.definition();\n            def.assignments++;\n            def.references.push(ref);\n        }\n\n        function mark_destructured(process, tw) {\n            var marker = new TreeWalker(function(node) {\n                if (node instanceof AST_DefaultValue) {\n                    node.value.walk(tw);\n                    node.name.walk(marker);\n                    return true;\n                }\n                if (node instanceof AST_DestructuredKeyVal) {\n                    if (node.key instanceof AST_Node) node.key.walk(tw);\n                    node.value.walk(marker);\n                    return true;\n                }\n                return process(node);\n            });\n            this.walk(marker);\n        }\n        AST_DefaultValue.DEFMETHOD(\"mark_symbol\", mark_destructured);\n        AST_Destructured.DEFMETHOD(\"mark_symbol\", mark_destructured);\n        function mark_symbol(process) {\n            return process(this);\n        }\n        AST_SymbolDeclaration.DEFMETHOD(\"mark_symbol\", mark_symbol);\n        AST_SymbolRef.DEFMETHOD(\"mark_symbol\", mark_symbol);\n\n        AST_Node.DEFMETHOD(\"match_symbol\", function(predicate) {\n            return predicate(this);\n        });\n        function match_destructured(predicate, ignore_side_effects) {\n            var found = false;\n            var tw = new TreeWalker(function(node) {\n                if (found) return true;\n                if (node instanceof AST_DefaultValue) {\n                    if (!ignore_side_effects) return found = true;\n                    node.name.walk(tw);\n                    return true;\n                }\n                if (node instanceof AST_DestructuredKeyVal) {\n                    if (!ignore_side_effects && node.key instanceof AST_Node) return found = true;\n                    node.value.walk(tw);\n                    return true;\n                }\n                if (predicate(node)) return found = true;\n            });\n            this.walk(tw);\n            return found;\n        }\n        AST_DefaultValue.DEFMETHOD(\"match_symbol\", match_destructured);\n        AST_Destructured.DEFMETHOD(\"match_symbol\", match_destructured);\n\n        function in_async_generator(scope) {\n            return scope instanceof AST_AsyncGeneratorDefun || scope instanceof AST_AsyncGeneratorFunction;\n        }\n\n        function find_scope(compressor) {\n            var level = 0, node = compressor.self();\n            do {\n                if (node.variables) return node;\n            } while (node = compressor.parent(level++));\n        }\n\n        function find_try(compressor, level, node, scope, may_throw, sync) {\n            for (var parent; parent = compressor.parent(level++); node = parent) {\n                if (parent === scope) return false;\n                if (sync && parent instanceof AST_Lambda) {\n                    if (parent.name || is_async(parent) || is_generator(parent)) return true;\n                } else if (parent instanceof AST_Try) {\n                    if (parent.bfinally && parent.bfinally !== node) return true;\n                    if (may_throw && parent.bcatch && parent.bcatch !== node) return true;\n                }\n            }\n            return false;\n        }\n\n        var identifier_atom = makePredicate(\"Infinity NaN undefined\");\n        function is_lhs_read_only(lhs, compressor) {\n            if (lhs instanceof AST_Atom) return true;\n            if (lhs instanceof AST_ObjectIdentity) return true;\n            if (lhs instanceof AST_PropAccess) {\n                if (lhs.property === \"__proto__\") return true;\n                lhs = lhs.expression;\n                if (lhs instanceof AST_SymbolRef) {\n                    if (lhs.is_immutable()) return false;\n                    lhs = lhs.fixed_value();\n                }\n                if (!lhs) return true;\n                if (lhs.tail_node().is_constant()) return true;\n                return is_lhs_read_only(lhs, compressor);\n            }\n            if (lhs instanceof AST_SymbolRef) {\n                if (lhs.is_immutable()) return true;\n                var def = lhs.definition();\n                return compressor.exposed(def) && identifier_atom[def.name];\n            }\n            return false;\n        }\n\n        function make_node(ctor, orig, props) {\n            if (props) {\n                props.start = orig.start;\n                props.end = orig.end;\n            } else {\n                props = orig;\n            }\n            return new ctor(props);\n        }\n\n        function make_sequence(orig, expressions) {\n            if (expressions.length == 1) return expressions[0];\n            return make_node(AST_Sequence, orig, { expressions: expressions.reduce(merge_sequence, []) });\n        }\n\n        function make_node_from_constant(val, orig) {\n            switch (typeof val) {\n              case \"string\":\n                return make_node(AST_String, orig, { value: val });\n              case \"number\":\n                if (isNaN(val)) return make_node(AST_NaN, orig);\n                if (isFinite(val)) {\n                    return 1 / val < 0 ? make_node(AST_UnaryPrefix, orig, {\n                        operator: \"-\",\n                        expression: make_node(AST_Number, orig, { value: -val }),\n                    }) : make_node(AST_Number, orig, { value: val });\n                }\n                return val < 0 ? make_node(AST_UnaryPrefix, orig, {\n                    operator: \"-\",\n                    expression: make_node(AST_Infinity, orig),\n                }) : make_node(AST_Infinity, orig);\n              case \"boolean\":\n                return make_node(val ? AST_True : AST_False, orig);\n              case \"undefined\":\n                return make_node(AST_Undefined, orig);\n              default:\n                if (val === null) {\n                    return make_node(AST_Null, orig);\n                }\n                if (val instanceof RegExp) {\n                    return make_node(AST_RegExp, orig, { value: val });\n                }\n                throw new Error(string_template(\"Can't handle constant of type: {type}\", { type: typeof val }));\n            }\n        }\n\n        function needs_unbinding(val) {\n            return val instanceof AST_PropAccess\n                || is_undeclared_ref(val) && val.name == \"eval\";\n        }\n\n        // we shouldn't compress (1,func)(something) to\n        // func(something) because that changes the meaning of\n        // the func (becomes lexical instead of global).\n        function maintain_this_binding(parent, orig, val) {\n            var wrap = false;\n            if (parent.TYPE == \"Call\") {\n                wrap = parent.expression === orig && needs_unbinding(val);\n            } else if (parent instanceof AST_Template) {\n                wrap = parent.tag === orig && needs_unbinding(val);\n            } else if (parent instanceof AST_UnaryPrefix) {\n                wrap = parent.operator == \"delete\"\n                    || parent.operator == \"typeof\" && is_undeclared_ref(val);\n            }\n            return wrap ? make_sequence(orig, [ make_node(AST_Number, orig, { value: 0 }), val ]) : val;\n        }\n\n        function merge_expression(base, target) {\n            var fixed_by_id = new Dictionary();\n            base.walk(new TreeWalker(function(node) {\n                if (!(node instanceof AST_SymbolRef)) return;\n                var def = node.definition();\n                var fixed = node.fixed;\n                if (!fixed || !fixed_by_id.has(def.id)) {\n                    fixed_by_id.set(def.id, fixed);\n                } else if (fixed_by_id.get(def.id) !== fixed) {\n                    fixed_by_id.set(def.id, false);\n                }\n            }));\n            if (fixed_by_id.size() > 0) target.walk(new TreeWalker(function(node) {\n                if (!(node instanceof AST_SymbolRef)) return;\n                var def = node.definition();\n                var fixed = node.fixed;\n                if (!fixed || !fixed_by_id.has(def.id)) return;\n                if (fixed_by_id.get(def.id) !== fixed) node.fixed = false;\n            }));\n            return target;\n        }\n\n        function merge_sequence(array, node) {\n            if (node instanceof AST_Sequence) {\n                [].push.apply(array, node.expressions);\n            } else {\n                array.push(node);\n            }\n            return array;\n        }\n\n        function is_lexical_definition(stat) {\n            return stat instanceof AST_Const || stat instanceof AST_DefClass || stat instanceof AST_Let;\n        }\n\n        function safe_to_trim(stat) {\n            if (stat instanceof AST_LambdaDefinition) {\n                var def = stat.name.definition();\n                var scope = stat.name.scope;\n                return def.scope === scope || all(def.references, function(ref) {\n                    var s = ref.scope;\n                    do {\n                        if (s === scope) return true;\n                    } while (s = s.parent_scope);\n                });\n            }\n            return !is_lexical_definition(stat);\n        }\n\n        function as_statement_array(thing) {\n            if (thing === null) return [];\n            if (thing instanceof AST_BlockStatement) return all(thing.body, safe_to_trim) ? thing.body : [ thing ];\n            if (thing instanceof AST_EmptyStatement) return [];\n            if (is_statement(thing)) return [ thing ];\n            throw new Error(\"Can't convert thing to statement array\");\n        }\n\n        function is_empty(thing) {\n            if (thing === null) return true;\n            if (thing instanceof AST_EmptyStatement) return true;\n            if (thing instanceof AST_BlockStatement) return thing.body.length == 0;\n            return false;\n        }\n\n        function has_declarations_only(block) {\n            return all(block.body, function(stat) {\n                return is_empty(stat)\n                    || stat instanceof AST_Defun\n                    || stat instanceof AST_Var && declarations_only(stat);\n            });\n        }\n\n        function loop_body(x) {\n            if (x instanceof AST_IterationStatement) {\n                return x.body instanceof AST_BlockStatement ? x.body : x;\n            }\n            return x;\n        }\n\n        function is_iife_call(node) {\n            if (node.TYPE != \"Call\") return false;\n            do {\n                node = node.expression;\n            } while (node instanceof AST_PropAccess);\n            return node instanceof AST_LambdaExpression ? !is_arrow(node) : is_iife_call(node);\n        }\n\n        function is_iife_single(call) {\n            var exp = call.expression;\n            if (exp.name) return false;\n            if (!(call instanceof AST_New)) return true;\n            var found = false;\n            exp.walk(new TreeWalker(function(node) {\n                if (found) return true;\n                if (node instanceof AST_NewTarget) return found = true;\n                if (node instanceof AST_Scope && node !== exp) return true;\n            }));\n            return !found;\n        }\n\n        function is_undeclared_ref(node) {\n            return node instanceof AST_SymbolRef && node.definition().undeclared;\n        }\n\n        var global_names = makePredicate(\"Array Boolean clearInterval clearTimeout console Date decodeURI decodeURIComponent encodeURI encodeURIComponent Error escape eval EvalError Function isFinite isNaN JSON Map Math Number parseFloat parseInt RangeError ReferenceError RegExp Object Set setInterval setTimeout String SyntaxError TypeError unescape URIError WeakMap WeakSet\");\n        AST_SymbolRef.DEFMETHOD(\"is_declared\", function(compressor) {\n            return this.defined\n                || !this.definition().undeclared\n                || compressor.option(\"unsafe\") && global_names[this.name];\n        });\n\n        function is_static_field_or_init(prop) {\n            return prop.static && prop.value && (prop instanceof AST_ClassField || prop instanceof AST_ClassInit);\n        }\n\n        function declarations_only(node) {\n            return all(node.definitions, function(var_def) {\n                return !var_def.value;\n            });\n        }\n\n        function is_declaration(stat, lexical) {\n            if (stat instanceof AST_DefClass) return lexical && !stat.extends && all(stat.properties, function(prop) {\n                if (prop.key instanceof AST_Node) return false;\n                return !is_static_field_or_init(prop);\n            });\n            if (stat instanceof AST_Definitions) return (lexical || stat instanceof AST_Var) && declarations_only(stat);\n            if (stat instanceof AST_ExportDeclaration) return is_declaration(stat.body, lexical);\n            if (stat instanceof AST_ExportDefault) return is_declaration(stat.body, lexical);\n            return stat instanceof AST_LambdaDefinition;\n        }\n\n        function is_last_statement(body, stat) {\n            var index = body.lastIndexOf(stat);\n            if (index < 0) return false;\n            while (++index < body.length) {\n                if (!is_declaration(body[index], true)) return false;\n            }\n            return true;\n        }\n\n        // Certain combination of unused name + side effect leads to invalid AST:\n        //    https://github.com/mishoo/UglifyJS/issues/44\n        //    https://github.com/mishoo/UglifyJS/issues/1838\n        //    https://github.com/mishoo/UglifyJS/issues/3371\n        // We fix it at this stage by moving the `var` outside the `for`.\n        function patch_for_init(node, in_list) {\n            var block;\n            if (node.init instanceof AST_BlockStatement) {\n                block = node.init;\n                node.init = block.body.pop();\n                block.body.push(node);\n            }\n            if (node.init instanceof AST_Defun) {\n                if (!block) block = make_node(AST_BlockStatement, node, { body: [ node ] });\n                block.body.splice(-1, 0, node.init);\n                node.init = null;\n            } else if (node.init instanceof AST_SimpleStatement) {\n                node.init = node.init.body;\n            } else if (is_empty(node.init)) {\n                node.init = null;\n            }\n            if (!block) return;\n            return in_list ? List.splice(block.body) : block;\n        }\n\n        function tighten_body(statements, compressor) {\n            var in_lambda = last_of(compressor, function(node) {\n                return node instanceof AST_Lambda;\n            });\n            var block_scope, iife_in_try, in_iife_single, in_loop, in_try, scope;\n            find_loop_scope_try();\n            var changed, last_changed, max_iter = 10;\n            do {\n                last_changed = changed;\n                changed = 0;\n                if (eliminate_spurious_blocks(statements)) changed = 1;\n                if (!changed && last_changed == 1) break;\n                if (compressor.option(\"dead_code\")) {\n                    if (eliminate_dead_code(statements, compressor)) changed = 2;\n                    if (!changed && last_changed == 2) break;\n                }\n                if (compressor.option(\"if_return\")) {\n                    if (handle_if_return(statements, compressor)) changed = 3;\n                    if (!changed && last_changed == 3) break;\n                }\n                if (compressor.option(\"awaits\") && compressor.option(\"side_effects\")) {\n                    if (trim_awaits(statements, compressor)) changed = 4;\n                    if (!changed && last_changed == 4) break;\n                }\n                if (compressor.option(\"inline\") >= 4) {\n                    if (inline_iife(statements, compressor)) changed = 5;\n                    if (!changed && last_changed == 5) break;\n                }\n                if (compressor.sequences_limit > 0) {\n                    if (sequencesize(statements, compressor)) changed = 6;\n                    if (!changed && last_changed == 6) break;\n                    if (sequencesize_2(statements, compressor)) changed = 7;\n                    if (!changed && last_changed == 7) break;\n                }\n                if (compressor.option(\"join_vars\")) {\n                    if (join_consecutive_vars(statements)) changed = 8;\n                    if (!changed && last_changed == 8) break;\n                }\n                if (compressor.option(\"collapse_vars\")) {\n                    if (collapse(statements, compressor)) changed = 9;\n                }\n            } while (changed && max_iter-- > 0);\n            return statements;\n\n            function last_of(compressor, predicate) {\n                var block = compressor.self(), level = 0, stat;\n                do {\n                    if (block instanceof AST_Catch) {\n                        block = compressor.parent(level++);\n                    } else if (block instanceof AST_LabeledStatement) {\n                        block = block.body;\n                    } else if (block instanceof AST_SwitchBranch) {\n                        var branches = compressor.parent(level);\n                        if (branches.body[branches.body.length - 1] === block || has_break(block.body)) {\n                            level++;\n                            block = branches;\n                        }\n                    }\n                    do {\n                        stat = block;\n                        if (predicate(stat)) return stat;\n                        block = compressor.parent(level++);\n                    } while (block instanceof AST_If);\n                } while (stat\n                    && (block instanceof AST_BlockStatement\n                        || block instanceof AST_Catch\n                        || block instanceof AST_Scope\n                        || block instanceof AST_SwitchBranch\n                        || block instanceof AST_Try)\n                    && is_last_statement(block.body, stat));\n\n                function has_break(stats) {\n                    for (var i = stats.length; --i >= 0;) {\n                        if (stats[i] instanceof AST_Break) return true;\n                    }\n                    return false;\n                }\n            }\n\n            function find_loop_scope_try() {\n                var node = compressor.self(), level = 0;\n                do {\n                    if (!block_scope && node.variables) block_scope = node;\n                    if (node instanceof AST_Catch) {\n                        if (compressor.parent(level).bfinally) {\n                            if (!in_try) in_try = {};\n                            in_try.bfinally = true;\n                        }\n                        level++;\n                    } else if (node instanceof AST_Finally) {\n                        level++;\n                    } else if (node instanceof AST_IterationStatement) {\n                        in_loop = true;\n                    } else if (node instanceof AST_Scope) {\n                        scope = node;\n                        break;\n                    } else if (node instanceof AST_Try) {\n                        if (!in_try) in_try = {};\n                        if (node.bcatch) in_try.bcatch = true;\n                        if (node.bfinally) in_try.bfinally = true;\n                    }\n                } while (node = compressor.parent(level++));\n            }\n\n            // Search from right to left for assignment-like expressions:\n            // - `var a = x;`\n            // - `a = x;`\n            // - `++a`\n            // For each candidate, scan from left to right for first usage, then try\n            // to fold assignment into the site for compression.\n            // Will not attempt to collapse assignments into or past code blocks\n            // which are not sequentially executed, e.g. loops and conditionals.\n            function collapse(statements, compressor) {\n                if (scope.pinned()) return;\n                var args;\n                var assignments = new Dictionary();\n                var candidates = [];\n                var changed = false;\n                var declare_only = new Dictionary();\n                var force_single;\n                var stat_index = statements.length;\n                var scanner = new TreeTransformer(function(node, descend) {\n                    if (abort) return node;\n                    // Skip nodes before `candidate` as quickly as possible\n                    if (!hit) {\n                        if (node !== hit_stack[hit_index]) return node;\n                        hit_index++;\n                        if (hit_index < hit_stack.length) return handle_custom_scan_order(node, scanner);\n                        hit = true;\n                        stop_after = (value_def ? find_stop_value : find_stop)(node, 0);\n                        if (stop_after === node) abort = true;\n                        return node;\n                    }\n                    var parent = scanner.parent();\n                    // Stop only if candidate is found within conditional branches\n                    if (!stop_if_hit && in_conditional(node, parent)) {\n                        stop_if_hit = parent;\n                    }\n                    // Cascade compound assignments\n                    if (compound && scan_lhs && can_replace && !stop_if_hit\n                        && node instanceof AST_Assign && node.operator != \"=\" && node.left.equals(lhs)) {\n                        replaced++;\n                        changed = true;\n                        AST_Node.info(\"Cascading {this} [{start}]\", node);\n                        can_replace = false;\n                        lvalues = get_lvalues(lhs);\n                        node.right.transform(scanner);\n                        clear_write_only(candidate);\n                        var folded;\n                        if (abort) {\n                            folded = candidate;\n                        } else {\n                            abort = true;\n                            folded = make_node(AST_Binary, candidate, {\n                                operator: compound,\n                                left: lhs.fixed && lhs.definition().fixed ? lhs.fixed.to_binary(candidate) : lhs,\n                                right: rvalue,\n                            });\n                        }\n                        return make_node(AST_Assign, node, {\n                            operator: \"=\",\n                            left: node.left,\n                            right: make_node(AST_Binary, node, {\n                                operator: node.operator.slice(0, -1),\n                                left: folded,\n                                right: node.right,\n                            }),\n                        });\n                    }\n                    // Stop immediately if these node types are encountered\n                    if (should_stop(node, parent)) {\n                        abort = true;\n                        return node;\n                    }\n                    // Skip transient nodes caused by single-use variable replacement\n                    if (node.single_use) return node;\n                    // Replace variable with assignment when found\n                    var hit_rhs;\n                    if (!(node instanceof AST_SymbolDeclaration)\n                        && (scan_lhs && lhs.equals(node)\n                            || scan_rhs && (hit_rhs = scan_rhs(node, this)))) {\n                        if (!can_replace || stop_if_hit && (hit_rhs || !lhs_local || !replace_all)) {\n                            if (!hit_rhs && !value_def) abort = true;\n                            return node;\n                        }\n                        if (is_lhs(node, parent)) {\n                            if (value_def && !hit_rhs) assign_used = true;\n                            return node;\n                        }\n                        if (!hit_rhs && verify_ref && node.fixed !== lhs.fixed) {\n                            abort = true;\n                            return node;\n                        }\n                        if (value_def) {\n                            if (stop_if_hit && assign_pos == 0) assign_pos = remaining - replaced;\n                            if (!hit_rhs) replaced++;\n                            return node;\n                        }\n                        replaced++;\n                        changed = abort = true;\n                        AST_Node.info(\"Collapsing {this} [{start}]\", node);\n                        if (candidate.TYPE == \"Binary\") {\n                            update_symbols(candidate, node);\n                            return make_node(AST_Assign, candidate, {\n                                operator: \"=\",\n                                left: candidate.right.left,\n                                right: candidate.operator == \"&&\" ? make_node(AST_Conditional, candidate, {\n                                    condition: candidate.left,\n                                    consequent: candidate.right.right,\n                                    alternative: node,\n                                }) : make_node(AST_Conditional, candidate, {\n                                    condition: candidate.left,\n                                    consequent: node,\n                                    alternative: candidate.right.right,\n                                }),\n                            });\n                        }\n                        if (candidate instanceof AST_UnaryPostfix) return make_node(AST_UnaryPrefix, candidate, {\n                            operator: candidate.operator,\n                            expression: lhs.fixed && lhs.definition().fixed ? lhs.fixed.to_prefix(candidate) : lhs,\n                        });\n                        if (candidate instanceof AST_UnaryPrefix) {\n                            clear_write_only(candidate);\n                            return candidate;\n                        }\n                        update_symbols(rvalue, node);\n                        if (candidate instanceof AST_VarDef) {\n                            var def = candidate.name.definition();\n                            if (def.references.length - def.replaced == 1 && !compressor.exposed(def)) {\n                                def.replaced++;\n                                return maintain_this_binding(parent, node, rvalue);\n                            }\n                            return make_node(AST_Assign, candidate, {\n                                operator: \"=\",\n                                left: node,\n                                right: rvalue,\n                            });\n                        }\n                        clear_write_only(rvalue);\n                        var assign = candidate.clone();\n                        assign.right = rvalue;\n                        return assign;\n                    }\n                    // Stop signals related to AST_SymbolRef\n                    if (should_stop_ref(node, parent)) {\n                        abort = true;\n                        return node;\n                    }\n                    // These node types have child nodes that execute sequentially,\n                    // but are otherwise not safe to scan into or beyond them.\n                    if (is_last_node(node, parent) || may_throw(node)) {\n                        stop_after = node;\n                        if (node instanceof AST_Scope) abort = true;\n                    }\n                    // Scan but don't replace inside getter/setter\n                    if (node instanceof AST_Accessor) {\n                        var replace = can_replace;\n                        can_replace = false;\n                        descend(node, scanner);\n                        can_replace = replace;\n                        return signal_abort(node);\n                    }\n                    // Scan but don't replace inside destructuring expression\n                    if (node instanceof AST_Destructured) {\n                        var replace = can_replace;\n                        can_replace = false;\n                        descend(node, scanner);\n                        can_replace = replace;\n                        return signal_abort(node);\n                    }\n                    // Scan but don't replace inside default value\n                    if (node instanceof AST_DefaultValue) {\n                        node.name = node.name.transform(scanner);\n                        var replace = can_replace;\n                        can_replace = false;\n                        node.value = node.value.transform(scanner);\n                        can_replace = replace;\n                        return signal_abort(node);\n                    }\n                    // Scan but don't replace inside block scope with colliding variable\n                    if (node instanceof AST_BlockScope\n                        && !(node instanceof AST_Scope)\n                        && !(node.variables && node.variables.all(function(def) {\n                            return !enclosed.has(def.name) && !lvalues.has(def.name);\n                        }))) {\n                        var replace = can_replace;\n                        can_replace = false;\n                        if (!handle_custom_scan_order(node, scanner)) descend(node, scanner);\n                        can_replace = replace;\n                        return signal_abort(node);\n                    }\n                    if (handle_custom_scan_order(node, scanner)) return signal_abort(node);\n                }, signal_abort);\n                var multi_replacer = new TreeTransformer(function(node) {\n                    if (abort) return node;\n                    // Skip nodes before `candidate` as quickly as possible\n                    if (!hit) {\n                        if (node !== hit_stack[hit_index]) return node;\n                        hit_index++;\n                        switch (hit_stack.length - hit_index) {\n                          case 0:\n                            hit = true;\n                            if (assign_used) return node;\n                            if (node !== candidate) return node;\n                            if (node instanceof AST_VarDef) return node;\n                            def.replaced++;\n                            var parent = multi_replacer.parent();\n                            if (parent instanceof AST_Sequence && parent.tail_node() !== node) {\n                                value_def.replaced++;\n                                if (rvalue === rhs_value) return List.skip;\n                                return make_sequence(rhs_value, rhs_value.expressions.slice(0, -1));\n                            }\n                            return rvalue;\n                          case 1:\n                            if (!assign_used && node.body === candidate) {\n                                hit = true;\n                                def.replaced++;\n                                value_def.replaced++;\n                                return null;\n                            }\n                          default:\n                            return handle_custom_scan_order(node, multi_replacer);\n                        }\n                    }\n                    // Replace variable when found\n                    if (node instanceof AST_SymbolRef && node.definition() === def) {\n                        if (is_lhs(node, multi_replacer.parent())) return node;\n                        if (!--replaced) abort = true;\n                        AST_Node.info(\"Replacing {this} [{start}]\", node);\n                        var ref = rvalue.clone();\n                        ref.scope = node.scope;\n                        ref.reference();\n                        if (replaced == assign_pos) {\n                            abort = true;\n                            return make_node(AST_Assign, candidate, {\n                                operator: \"=\",\n                                left: node,\n                                right: ref,\n                            });\n                        }\n                        def.replaced++;\n                        return ref;\n                    }\n                    // Skip (non-executed) functions and (leading) default case in switch statements\n                    if (node instanceof AST_Default || node instanceof AST_Scope) return node;\n                }, function(node) {\n                    return patch_sequence(node, multi_replacer);\n                });\n                while (--stat_index >= 0) {\n                    // Treat parameters as collapsible in IIFE, i.e.\n                    //   function(a, b){ ... }(x());\n                    // would be translated into equivalent assignments:\n                    //   var a = x(), b = undefined;\n                    if (stat_index == 0 && compressor.option(\"unused\")) extract_args();\n                    // Find collapsible assignments\n                    var hit_stack = [];\n                    extract_candidates(statements[stat_index]);\n                    while (candidates.length > 0) {\n                        hit_stack = candidates.pop();\n                        var hit_index = 0;\n                        var candidate = hit_stack[hit_stack.length - 1];\n                        var assign_pos = -1;\n                        var assign_used = false;\n                        var verify_ref = false;\n                        var remaining;\n                        var value_def = null;\n                        var stop_after = null;\n                        var stop_if_hit = null;\n                        var lhs = get_lhs(candidate);\n                        var side_effects = lhs && lhs.has_side_effects(compressor);\n                        var scan_lhs = lhs && (!side_effects || lhs instanceof AST_SymbolRef)\n                                && !is_lhs_read_only(lhs, compressor);\n                        var scan_rhs = foldable(candidate);\n                        if (!scan_lhs && !scan_rhs) continue;\n                        var compound = candidate instanceof AST_Assign && candidate.operator.slice(0, -1);\n                        var funarg = candidate.name instanceof AST_SymbolFunarg;\n                        var may_throw = return_false;\n                        if (candidate.may_throw(compressor)) {\n                            if (funarg && is_async(scope)) continue;\n                            may_throw = in_try ? function(node) {\n                                return node.has_side_effects(compressor);\n                            } : side_effects_external;\n                        }\n                        var read_toplevel = false;\n                        var modify_toplevel = false;\n                        // Locate symbols which may execute code outside of scanning range\n                        var enclosed = new Dictionary();\n                        var well_defined = true;\n                        var lvalues = get_lvalues(candidate);\n                        var lhs_local = is_lhs_local(lhs);\n                        var rhs_value = get_rvalue(candidate);\n                        var rvalue = rhs_value;\n                        if (!side_effects) {\n                            if (!compound && rvalue instanceof AST_Sequence) rvalue = rvalue.tail_node();\n                            side_effects = value_has_side_effects();\n                        }\n                        var check_destructured = in_try || !lhs_local ? function(node) {\n                            return node instanceof AST_Destructured;\n                        } : return_false;\n                        var replace_all = replace_all_symbols(candidate);\n                        var hit = funarg;\n                        var abort = false;\n                        var replaced = 0;\n                        var can_replace = !args || !hit;\n                        if (!can_replace) {\n                            for (var j = candidate.arg_index + 1; !abort && j < args.length; j++) {\n                                if (args[j]) args[j].transform(scanner);\n                            }\n                            can_replace = true;\n                        }\n                        for (var i = stat_index; !abort && i < statements.length; i++) {\n                            statements[i].transform(scanner);\n                        }\n                        if (value_def) {\n                            if (!replaced || remaining > replaced + assign_used) {\n                                candidates.push(hit_stack);\n                                force_single = true;\n                                continue;\n                            }\n                            if (replaced == assign_pos) assign_used = true;\n                            var def = lhs.definition();\n                            abort = false;\n                            hit_index = 0;\n                            hit = funarg;\n                            for (var i = stat_index; !abort && i < statements.length; i++) {\n                                if (!statements[i].transform(multi_replacer)) statements.splice(i--, 1);\n                            }\n                            replaced = candidate instanceof AST_VarDef\n                                && candidate === hit_stack[hit_stack.length - 1]\n                                && def.references.length == def.replaced\n                                && !compressor.exposed(def);\n                            value_def.last_ref = false;\n                            value_def.single_use = false;\n                            changed = true;\n                        }\n                        if (replaced) remove_candidate(candidate);\n                    }\n                }\n                return changed;\n\n                function signal_abort(node) {\n                    if (abort) return node;\n                    if (stop_after === node) abort = true;\n                    if (stop_if_hit === node) stop_if_hit = null;\n                    return node;\n                }\n\n                function handle_custom_scan_order(node, tt) {\n                    if (!(node instanceof AST_BlockScope)) return;\n                    // Skip (non-executed) functions\n                    if (node instanceof AST_Scope) return node;\n                    // Scan computed keys, static fields & initializers in class\n                    if (node instanceof AST_Class) {\n                        if (node.name) node.name = node.name.transform(tt);\n                        if (!abort && node.extends) node.extends = node.extends.transform(tt);\n                        var fields = [], stats = [];\n                        for (var i = 0; !abort && i < node.properties.length; i++) {\n                            var prop = node.properties[i];\n                            if (prop.key instanceof AST_Node) prop.key = prop.key.transform(tt);\n                            if (!prop.static) continue;\n                            if (prop instanceof AST_ClassField) {\n                                if (prop.value) fields.push(prop);\n                            } else if (prop instanceof AST_ClassInit) {\n                                [].push.apply(stats, prop.value.body);\n                            }\n                        }\n                        for (var i = 0; !abort && i < stats.length; i++) {\n                            stats[i].transform(tt);\n                        }\n                        for (var i = 0; !abort && i < fields.length; i++) {\n                            var prop = fields[i];\n                            prop.value = prop.value.transform(tt);\n                        }\n                        return node;\n                    }\n                    // Scan object only in a for-in/of statement\n                    if (node instanceof AST_ForEnumeration) {\n                        node.object = node.object.transform(tt);\n                        abort = true;\n                        return node;\n                    }\n                    // Scan first case expression only in a switch statement\n                    if (node instanceof AST_Switch) {\n                        node.expression = node.expression.transform(tt);\n                        for (var i = 0; !abort && i < node.body.length; i++) {\n                            var branch = node.body[i];\n                            if (branch instanceof AST_Case) {\n                                if (!hit) {\n                                    if (branch !== hit_stack[hit_index]) continue;\n                                    hit_index++;\n                                }\n                                branch.expression = branch.expression.transform(tt);\n                                if (!replace_all) break;\n                                scan_rhs = false;\n                            }\n                        }\n                        abort = true;\n                        return node;\n                    }\n                }\n\n                function is_direct_assignment(node, parent) {\n                    if (parent instanceof AST_Assign) return parent.operator == \"=\" && parent.left === node;\n                    if (parent instanceof AST_DefaultValue) return parent.name === node;\n                    if (parent instanceof AST_DestructuredArray) return true;\n                    if (parent instanceof AST_DestructuredKeyVal) return parent.value === node;\n                }\n\n                function should_stop(node, parent) {\n                    if (node === rvalue) return true;\n                    if (parent instanceof AST_For) {\n                        if (node !== parent.init) return true;\n                    }\n                    if (node instanceof AST_Assign) {\n                        return node.operator != \"=\" && lhs.equals(node.left);\n                    }\n                    if (node instanceof AST_Call) {\n                        if (!(lhs instanceof AST_PropAccess)) return false;\n                        if (!lhs.equals(node.expression)) return false;\n                        return !(rvalue instanceof AST_LambdaExpression && !rvalue.contains_this());\n                    }\n                    if (node instanceof AST_Class) return !compressor.has_directive(\"use strict\");\n                    if (node instanceof AST_Debugger) return true;\n                    if (node instanceof AST_Defun) return funarg && lhs.name === node.name.name;\n                    if (node instanceof AST_DestructuredKeyVal) return node.key instanceof AST_Node;\n                    if (node instanceof AST_DWLoop) return true;\n                    if (node instanceof AST_LoopControl) return true;\n                    if (node instanceof AST_Try) return true;\n                    if (node instanceof AST_With) return true;\n                    return false;\n                }\n\n                function should_stop_ref(node, parent) {\n                    if (!(node instanceof AST_SymbolRef)) return false;\n                    if (node.is_declared(compressor)) {\n                        if (node.fixed_value()) return false;\n                        if (can_drop_symbol(node)) {\n                            return !(parent instanceof AST_PropAccess && parent.expression === node)\n                                && is_arguments(node.definition());\n                        }\n                    } else if (is_direct_assignment(node, parent)) {\n                        return false;\n                    }\n                    if (!replace_all) return true;\n                    scan_rhs = false;\n                    return false;\n                }\n\n                function in_conditional(node, parent) {\n                    if (parent instanceof AST_Assign) return parent.left !== node && lazy_op[parent.operator.slice(0, -1)];\n                    if (parent instanceof AST_Binary) return parent.left !== node && lazy_op[parent.operator];\n                    if (parent instanceof AST_Call) return parent.optional && parent.expression !== node;\n                    if (parent instanceof AST_Case) return parent.expression !== node;\n                    if (parent instanceof AST_Conditional) return parent.condition !== node;\n                    if (parent instanceof AST_If) return parent.condition !== node;\n                    if (parent instanceof AST_Sub) return parent.optional && parent.expression !== node;\n                }\n\n                function is_last_node(node, parent) {\n                    if (node instanceof AST_Await) return true;\n                    if (node.TYPE == \"Binary\") return !can_drop_op(node.operator, node.right, compressor);\n                    if (node instanceof AST_Call) {\n                        var def, fn = node.expression;\n                        if (fn instanceof AST_SymbolRef) {\n                            def = fn.definition();\n                            fn = fn.fixed_value();\n                        }\n                        if (!(fn instanceof AST_Lambda)) return !node.is_expr_pure(compressor);\n                        if (def && recursive_ref(compressor, def, fn)) return true;\n                        if (fn.collapse_scanning) return false;\n                        fn.collapse_scanning = true;\n                        var replace = can_replace;\n                        can_replace = false;\n                        var after = stop_after;\n                        var if_hit = stop_if_hit;\n                        for (var i = 0; !abort && i < fn.argnames.length; i++) {\n                            if (arg_may_throw(reject, fn.argnames[i], node.args[i])) abort = true;\n                        }\n                        if (!abort) {\n                            if (fn.rest && arg_may_throw(reject, fn.rest, make_node(AST_Array, node, {\n                                elements: node.args.slice(i),\n                            }))) {\n                                abort = true;\n                            } else if (is_arrow(fn) && fn.value) {\n                                fn.value.transform(scanner);\n                            } else for (var i = 0; !abort && i < fn.body.length; i++) {\n                                var stat = fn.body[i];\n                                if (stat instanceof AST_Return) {\n                                    if (stat.value) stat.value.transform(scanner);\n                                    break;\n                                }\n                                stat.transform(scanner);\n                            }\n                        }\n                        stop_if_hit = if_hit;\n                        stop_after = after;\n                        can_replace = replace;\n                        fn.collapse_scanning = false;\n                        if (!abort) return false;\n                        abort = false;\n                        return true;\n                    }\n                    if (node instanceof AST_Class) {\n                        if (!in_try) return false;\n                        var base = node.extends;\n                        if (!base) return false;\n                        if (base instanceof AST_SymbolRef) base = base.fixed_value();\n                        return !safe_for_extends(base);\n                    }\n                    if (node instanceof AST_Exit) {\n                        if (in_try) {\n                            if (in_try.bfinally) return true;\n                            if (in_try.bcatch && node instanceof AST_Throw) return true;\n                        }\n                        return side_effects || lhs instanceof AST_PropAccess || may_modify(lhs);\n                    }\n                    if (node instanceof AST_Function) {\n                        return compressor.option(\"ie\") && node.name && lvalues.has(node.name.name);\n                    }\n                    if (node instanceof AST_ObjectIdentity) return symbol_in_lvalues(node, parent);\n                    if (node instanceof AST_PropAccess) {\n                        if (side_effects) return true;\n                        var exp = node.expression;\n                        if (exp instanceof AST_SymbolRef && is_arguments(exp.definition())) return true;\n                        if (compressor.option(\"unsafe\")) {\n                            if (is_undeclared_ref(exp) && global_names[exp.name]) return false;\n                            if (is_static_fn(exp)) return false;\n                        }\n                        if (!well_defined) return true;\n                        if (value_def) return false;\n                        if (!in_try && lhs_local) return false;\n                        if (node.optional) return false;\n                        return exp.may_throw_on_access(compressor);\n                    }\n                    if (node instanceof AST_Spread) return true;\n                    if (node instanceof AST_SymbolRef) {\n                        if (symbol_in_lvalues(node, parent)) return !is_direct_assignment(node, parent);\n                        if (side_effects && may_modify(node)) return true;\n                        var def = node.definition();\n                        return (in_try || def.scope.resolve() !== scope) && !can_drop_symbol(node);\n                    }\n                    if (node instanceof AST_Template) return !node.is_expr_pure(compressor);\n                    if (node instanceof AST_VarDef) {\n                        if (check_destructured(node.name)) return true;\n                        return (node.value || parent instanceof AST_Let) && node.name.match_symbol(function(node) {\n                            return node instanceof AST_SymbolDeclaration\n                                && (lvalues.has(node.name) || side_effects && may_modify(node));\n                        }, true);\n                    }\n                    if (node instanceof AST_Yield) return true;\n                    var sym = is_lhs(node.left, node);\n                    if (!sym) return false;\n                    if (sym instanceof AST_PropAccess) return true;\n                    if (check_destructured(sym)) return true;\n                    return sym.match_symbol(function(node) {\n                        return node instanceof AST_SymbolRef\n                            && (lvalues.has(node.name) || read_toplevel && compressor.exposed(node.definition()));\n                    }, true);\n\n                    function reject(node) {\n                        node.transform(scanner);\n                        return abort;\n                    }\n                }\n\n                function arg_may_throw(reject, node, value) {\n                    if (node instanceof AST_DefaultValue) {\n                        return reject(node.value)\n                            || arg_may_throw(reject, node.name, node.value)\n                            || !is_undefined(value) && arg_may_throw(reject, node.name, value);\n                    }\n                    if (!value) return !(node instanceof AST_Symbol);\n                    if (node instanceof AST_Destructured) {\n                        if (node.rest && arg_may_throw(reject, node.rest)) return true;\n                        if (node instanceof AST_DestructuredArray) {\n                            if (value instanceof AST_Array) return !all(node.elements, function(element, index) {\n                                return !arg_may_throw(reject, element, value[index]);\n                            });\n                            if (!value.is_string(compressor)) return true;\n                            return !all(node.elements, function(element) {\n                                return !arg_may_throw(reject, element);\n                            });\n                        }\n                        if (node instanceof AST_DestructuredObject) {\n                            if (value.may_throw_on_access(compressor)) return true;\n                            return !all(node.properties, function(prop) {\n                                if (prop.key instanceof AST_Node && reject(prop.key)) return false;\n                                return !arg_may_throw(reject, prop.value);\n                            });\n                        }\n                    }\n                }\n\n                function extract_args() {\n                    if (in_iife_single === false) return;\n                    var iife = compressor.parent(), fn = compressor.self();\n                    if (in_iife_single === undefined) {\n                        if (!(fn instanceof AST_LambdaExpression)\n                            || is_generator(fn)\n                            || fn.uses_arguments\n                            || fn.pinned()\n                            || !(iife instanceof AST_Call)\n                            || iife.expression !== fn\n                            || !all(iife.args, function(arg) {\n                                return !(arg instanceof AST_Spread);\n                            })) {\n                            in_iife_single = false;\n                            return;\n                        }\n                        if (!is_iife_single(iife)) return;\n                        in_iife_single = true;\n                    }\n                    var fn_strict = fn.in_strict_mode(compressor)\n                        && !fn.parent_scope.resolve(true).in_strict_mode(compressor);\n                    var has_await;\n                    if (is_async(fn)) {\n                        has_await = function(node) {\n                            return node instanceof AST_Symbol && node.name == \"await\";\n                        };\n                        iife_in_try = true;\n                    } else {\n                        has_await = function(node) {\n                            return node instanceof AST_Await && !tw.find_parent(AST_Scope);\n                        };\n                        if (iife_in_try === undefined) iife_in_try = find_try(compressor, 1, iife, null, true, true);\n                    }\n                    var arg_scope = null;\n                    var tw = new TreeWalker(function(node, descend) {\n                        if (!arg) return true;\n                        if (has_await(node) || node instanceof AST_Yield) {\n                            arg = null;\n                            return true;\n                        }\n                        if (node instanceof AST_ObjectIdentity) {\n                            if (fn_strict || !arg_scope) arg = null;\n                            return true;\n                        }\n                        if (node instanceof AST_SymbolRef) {\n                            var def;\n                            if (node.in_arg && !is_safe_lexical(node.definition())\n                                || (def = fn.variables.get(node.name)) && def !== node.definition()) {\n                                arg = null;\n                            }\n                            return true;\n                        }\n                        if (node instanceof AST_Scope && !is_arrow(node)) {\n                            var save_scope = arg_scope;\n                            arg_scope = node;\n                            descend();\n                            arg_scope = save_scope;\n                            return true;\n                        }\n                    });\n                    args = iife.args.slice();\n                    var len = args.length;\n                    var names = new Dictionary();\n                    for (var i = fn.argnames.length; --i >= 0;) {\n                        var sym = fn.argnames[i];\n                        var arg = args[i];\n                        var value = null;\n                        if (sym instanceof AST_DefaultValue) {\n                            value = sym.value;\n                            sym = sym.name;\n                            args[len + i] = value;\n                        }\n                        if (sym instanceof AST_Destructured) {\n                            if (iife_in_try && arg_may_throw(function(node) {\n                                return node.has_side_effects(compressor);\n                            }, sym, arg)) {\n                                candidates.length = 0;\n                                break;\n                            }\n                            args[len + i] = fn.argnames[i];\n                            continue;\n                        }\n                        if (names.has(sym.name)) continue;\n                        names.set(sym.name, true);\n                        if (value) arg = is_undefined(arg) ? value : null;\n                        if (!arg && !value) {\n                            arg = make_node(AST_Undefined, sym).transform(compressor);\n                        } else if (arg instanceof AST_Lambda && arg.pinned()) {\n                            arg = null;\n                        } else if (arg) {\n                            arg.walk(tw);\n                        }\n                        if (!arg) continue;\n                        var candidate = make_node(AST_VarDef, sym, {\n                            name: sym,\n                            value: arg,\n                        });\n                        candidate.name_index = i;\n                        candidate.arg_index = value ? len + i : i;\n                        candidates.unshift([ candidate ]);\n                    }\n                    if (fn.rest) args.push(fn.rest);\n                }\n\n                function extract_candidates(expr, unused) {\n                    hit_stack.push(expr);\n                    if (expr instanceof AST_Array) {\n                        expr.elements.forEach(function(node) {\n                            extract_candidates(node, unused);\n                        });\n                    } else if (expr instanceof AST_Assign) {\n                        var lhs = expr.left;\n                        if (!(lhs instanceof AST_Destructured)) candidates.push(hit_stack.slice());\n                        extract_candidates(lhs);\n                        extract_candidates(expr.right);\n                        if (lhs instanceof AST_SymbolRef && expr.operator == \"=\") {\n                            assignments.set(lhs.name, (assignments.get(lhs.name) || 0) + 1);\n                        }\n                    } else if (expr instanceof AST_Await) {\n                        extract_candidates(expr.expression, unused);\n                    } else if (expr instanceof AST_Binary) {\n                        var lazy = lazy_op[expr.operator];\n                        if (unused\n                            && lazy\n                            && expr.operator != \"??\"\n                            && expr.right instanceof AST_Assign\n                            && expr.right.operator == \"=\"\n                            && !(expr.right.left instanceof AST_Destructured)) {\n                            candidates.push(hit_stack.slice());\n                        }\n                        extract_candidates(expr.left, !lazy && unused);\n                        extract_candidates(expr.right, unused);\n                    } else if (expr instanceof AST_Call) {\n                        extract_candidates(expr.expression);\n                        expr.args.forEach(extract_candidates);\n                    } else if (expr instanceof AST_Case) {\n                        extract_candidates(expr.expression);\n                    } else if (expr instanceof AST_Conditional) {\n                        extract_candidates(expr.condition);\n                        extract_candidates(expr.consequent, unused);\n                        extract_candidates(expr.alternative, unused);\n                    } else if (expr instanceof AST_Definitions) {\n                        expr.definitions.forEach(extract_candidates);\n                    } else if (expr instanceof AST_Dot) {\n                        extract_candidates(expr.expression);\n                    } else if (expr instanceof AST_DWLoop) {\n                        extract_candidates(expr.condition);\n                        if (!(expr.body instanceof AST_Block)) {\n                            extract_candidates(expr.body);\n                        }\n                    } else if (expr instanceof AST_Exit) {\n                        if (expr.value) extract_candidates(expr.value);\n                    } else if (expr instanceof AST_For) {\n                        if (expr.init) extract_candidates(expr.init, true);\n                        if (expr.condition) extract_candidates(expr.condition);\n                        if (expr.step) extract_candidates(expr.step, true);\n                        if (!(expr.body instanceof AST_Block)) {\n                            extract_candidates(expr.body);\n                        }\n                    } else if (expr instanceof AST_ForEnumeration) {\n                        extract_candidates(expr.object);\n                        if (!(expr.body instanceof AST_Block)) {\n                            extract_candidates(expr.body);\n                        }\n                    } else if (expr instanceof AST_If) {\n                        extract_candidates(expr.condition);\n                        if (!(expr.body instanceof AST_Block)) {\n                            extract_candidates(expr.body);\n                        }\n                        if (expr.alternative && !(expr.alternative instanceof AST_Block)) {\n                            extract_candidates(expr.alternative);\n                        }\n                    } else if (expr instanceof AST_Object) {\n                        expr.properties.forEach(function(prop) {\n                            hit_stack.push(prop);\n                            if (prop.key instanceof AST_Node) extract_candidates(prop.key);\n                            if (prop instanceof AST_ObjectKeyVal) extract_candidates(prop.value, unused);\n                            hit_stack.pop();\n                        });\n                    } else if (expr instanceof AST_Sequence) {\n                        var end = expr.expressions.length - (unused ? 0 : 1);\n                        expr.expressions.forEach(function(node, index) {\n                            extract_candidates(node, index < end);\n                        });\n                    } else if (expr instanceof AST_SimpleStatement) {\n                        extract_candidates(expr.body, true);\n                    } else if (expr instanceof AST_Spread) {\n                        extract_candidates(expr.expression);\n                    } else if (expr instanceof AST_Sub) {\n                        extract_candidates(expr.expression);\n                        extract_candidates(expr.property);\n                    } else if (expr instanceof AST_Switch) {\n                        extract_candidates(expr.expression);\n                        expr.body.forEach(extract_candidates);\n                    } else if (expr instanceof AST_Unary) {\n                        if (UNARY_POSTFIX[expr.operator]) {\n                            candidates.push(hit_stack.slice());\n                        } else {\n                            extract_candidates(expr.expression);\n                        }\n                    } else if (expr instanceof AST_VarDef) {\n                        if (expr.name instanceof AST_SymbolVar) {\n                            if (expr.value) {\n                                var def = expr.name.definition();\n                                if (def.references.length > def.replaced) {\n                                    candidates.push(hit_stack.slice());\n                                }\n                            } else {\n                                declare_only.set(expr.name.name, (declare_only.get(expr.name.name) || 0) + 1);\n                            }\n                        }\n                        if (expr.value) extract_candidates(expr.value);\n                    } else if (expr instanceof AST_Yield) {\n                        if (expr.expression) extract_candidates(expr.expression);\n                    }\n                    hit_stack.pop();\n                }\n\n                function find_stop(node, level) {\n                    var parent = scanner.parent(level);\n                    if (parent instanceof AST_Array) return node;\n                    if (parent instanceof AST_Assign) return node;\n                    if (parent instanceof AST_Await) return node;\n                    if (parent instanceof AST_Binary) return node;\n                    if (parent instanceof AST_Call) return node;\n                    if (parent instanceof AST_Case) return node;\n                    if (parent instanceof AST_Conditional) return node;\n                    if (parent instanceof AST_Definitions) return find_stop_unused(parent, level + 1);\n                    if (parent instanceof AST_Exit) return node;\n                    if (parent instanceof AST_If) return node;\n                    if (parent instanceof AST_IterationStatement) return node;\n                    if (parent instanceof AST_ObjectProperty) return node;\n                    if (parent instanceof AST_PropAccess) return node;\n                    if (parent instanceof AST_Sequence) {\n                        return (parent.tail_node() === node ? find_stop : find_stop_unused)(parent, level + 1);\n                    }\n                    if (parent instanceof AST_SimpleStatement) return find_stop_unused(parent, level + 1);\n                    if (parent instanceof AST_Spread) return node;\n                    if (parent instanceof AST_Switch) return node;\n                    if (parent instanceof AST_Unary) return node;\n                    if (parent instanceof AST_VarDef) return node;\n                    if (parent instanceof AST_Yield) return node;\n                    return null;\n                }\n\n                function find_stop_logical(parent, op, level) {\n                    var node;\n                    do {\n                        node = parent;\n                        parent = scanner.parent(++level);\n                    } while (parent instanceof AST_Assign && parent.operator.slice(0, -1) == op\n                        || parent instanceof AST_Binary && parent.operator == op);\n                    return node;\n                }\n\n                function find_stop_expr(expr, cont, node, parent, level) {\n                    var replace = can_replace;\n                    can_replace = false;\n                    var after = stop_after;\n                    var if_hit = stop_if_hit;\n                    var stack = scanner.stack;\n                    scanner.stack = [ parent ];\n                    expr.transform(scanner);\n                    scanner.stack = stack;\n                    stop_if_hit = if_hit;\n                    stop_after = after;\n                    can_replace = replace;\n                    if (abort) {\n                        abort = false;\n                        return node;\n                    }\n                    return cont(parent, level + 1);\n                }\n\n                function find_stop_value(node, level) {\n                    var parent = scanner.parent(level);\n                    if (parent instanceof AST_Array) return find_stop_value(parent, level + 1);\n                    if (parent instanceof AST_Assign) {\n                        if (may_throw(parent)) return node;\n                        if (parent.left.match_symbol(function(ref) {\n                            return ref instanceof AST_SymbolRef && (lhs.name == ref.name || value_def.name == ref.name);\n                        })) return node;\n                        var op;\n                        if (parent.left === node || !lazy_op[op = parent.operator.slice(0, -1)]) {\n                            return find_stop_value(parent, level + 1);\n                        }\n                        return find_stop_logical(parent, op, level);\n                    }\n                    if (parent instanceof AST_Await) return find_stop_value(parent, level + 1);\n                    if (parent instanceof AST_Binary) {\n                        var op;\n                        if (parent.left === node || !lazy_op[op = parent.operator]) {\n                            return find_stop_value(parent, level + 1);\n                        }\n                        return find_stop_logical(parent, op, level);\n                    }\n                    if (parent instanceof AST_Call) return parent;\n                    if (parent instanceof AST_Case) {\n                        if (parent.expression !== node) return node;\n                        return find_stop_value(parent, level + 1);\n                    }\n                    if (parent instanceof AST_Conditional) {\n                        if (parent.condition !== node) return node;\n                        return find_stop_value(parent, level + 1);\n                    }\n                    if (parent instanceof AST_Definitions) return find_stop_unused(parent, level + 1);\n                    if (parent instanceof AST_Do) return node;\n                    if (parent instanceof AST_Exit) return find_stop_unused(parent, level + 1);\n                    if (parent instanceof AST_For) {\n                        if (parent.init !== node && parent.condition !== node) return node;\n                        return find_stop_value(parent, level + 1);\n                    }\n                    if (parent instanceof AST_ForEnumeration) {\n                        if (parent.init !== node) return node;\n                        return find_stop_value(parent, level + 1);\n                    }\n                    if (parent instanceof AST_If) {\n                        if (parent.condition !== node) return node;\n                        return find_stop_value(parent, level + 1);\n                    }\n                    if (parent instanceof AST_ObjectProperty) {\n                        var obj = scanner.parent(level + 1);\n                        return all(obj.properties, function(prop) {\n                            return prop instanceof AST_ObjectKeyVal;\n                        }) ? find_stop_value(obj, level + 2) : obj;\n                    }\n                    if (parent instanceof AST_PropAccess) {\n                        var exp = parent.expression;\n                        return exp === node ? find_stop_value(parent, level + 1) : node;\n                    }\n                    if (parent instanceof AST_Sequence) {\n                        return (parent.tail_node() === node ? find_stop_value : find_stop_unused)(parent, level + 1);\n                    }\n                    if (parent instanceof AST_SimpleStatement) return find_stop_unused(parent, level + 1);\n                    if (parent instanceof AST_Spread) return find_stop_value(parent, level + 1);\n                    if (parent instanceof AST_Switch) {\n                        if (parent.expression !== node) return node;\n                        return find_stop_value(parent, level + 1);\n                    }\n                    if (parent instanceof AST_Unary) {\n                        if (parent.operator == \"delete\") return node;\n                        return find_stop_value(parent, level + 1);\n                    }\n                    if (parent instanceof AST_VarDef) return parent.name.match_symbol(function(sym) {\n                        return sym instanceof AST_SymbolDeclaration && (lhs.name == sym.name || value_def.name == sym.name);\n                    }) ? node : find_stop_value(parent, level + 1);\n                    if (parent instanceof AST_While) {\n                        if (parent.condition !== node) return node;\n                        return find_stop_value(parent, level + 1);\n                    }\n                    if (parent instanceof AST_Yield) return find_stop_value(parent, level + 1);\n                    return null;\n                }\n\n                function find_stop_unused(node, level) {\n                    var parent = scanner.parent(level);\n                    if (is_last_node(node, parent)) return node;\n                    if (in_conditional(node, parent)) return node;\n                    if (parent instanceof AST_Array) return find_stop_unused(parent, level + 1);\n                    if (parent instanceof AST_Assign) return check_assignment(parent.left);\n                    if (parent instanceof AST_Await) return node;\n                    if (parent instanceof AST_Binary) return find_stop_unused(parent, level + 1);\n                    if (parent instanceof AST_Call) return find_stop_unused(parent, level + 1);\n                    if (parent instanceof AST_Case) return find_stop_unused(parent, level + 1);\n                    if (parent instanceof AST_Conditional) return find_stop_unused(parent, level + 1);\n                    if (parent instanceof AST_Definitions) return find_stop_unused(parent, level + 1);\n                    if (parent instanceof AST_Exit) return find_stop_unused(parent, level + 1);\n                    if (parent instanceof AST_If) return find_stop_unused(parent, level + 1);\n                    if (parent instanceof AST_IterationStatement) return node;\n                    if (parent instanceof AST_ObjectProperty) {\n                        var obj = scanner.parent(level + 1);\n                        return all(obj.properties, function(prop) {\n                            return prop instanceof AST_ObjectKeyVal;\n                        }) ? find_stop_unused(obj, level + 2) : obj;\n                    }\n                    if (parent instanceof AST_PropAccess) {\n                        var exp = parent.expression;\n                        if (exp === node) return find_stop_unused(parent, level + 1);\n                        return find_stop_expr(exp, find_stop_unused, node, parent, level);\n                    }\n                    if (parent instanceof AST_Sequence) return find_stop_unused(parent, level + 1);\n                    if (parent instanceof AST_SimpleStatement) return find_stop_unused(parent, level + 1);\n                    if (parent instanceof AST_Spread) return node;\n                    if (parent instanceof AST_Switch) return find_stop_unused(parent, level + 1);\n                    if (parent instanceof AST_Unary) return find_stop_unused(parent, level + 1);\n                    if (parent instanceof AST_VarDef) return check_assignment(parent.name);\n                    if (parent instanceof AST_Yield) return node;\n                    return null;\n\n                    function check_assignment(lhs) {\n                        if (may_throw(parent)) return node;\n                        if (lhs !== node && lhs instanceof AST_Destructured) {\n                            return find_stop_expr(lhs, find_stop_unused, node, parent, level);\n                        }\n                        return find_stop_unused(parent, level + 1);\n                    }\n                }\n\n                function mangleable_var(rhs) {\n                    if (force_single) {\n                        force_single = false;\n                        return;\n                    }\n                    if (remaining < 1) return;\n                    rhs = rhs.tail_node();\n                    var value = rhs instanceof AST_Assign && rhs.operator == \"=\" ? rhs.left : rhs;\n                    if (!(value instanceof AST_SymbolRef)) return;\n                    var def = value.definition();\n                    if (def.undeclared) return;\n                    if (is_arguments(def)) return;\n                    if (value !== rhs) {\n                        if (is_lhs_read_only(value, compressor)) return;\n                        var referenced = def.references.length - def.replaced;\n                        if (referenced < 2) return;\n                        var expr = candidate.clone();\n                        expr[expr instanceof AST_Assign ? \"right\" : \"value\"] = value;\n                        if (candidate.name_index >= 0) {\n                            expr.name_index = candidate.name_index;\n                            expr.arg_index = candidate.arg_index;\n                        }\n                        candidate = expr;\n                    }\n                    return value_def = def;\n                }\n\n                function remaining_refs(def) {\n                    return def.references.length - def.replaced - (assignments.get(def.name) || 0);\n                }\n\n                function get_lhs(expr) {\n                    if (expr instanceof AST_Assign) {\n                        var lhs = expr.left;\n                        if (!(lhs instanceof AST_SymbolRef)) return lhs;\n                        var def = lhs.definition();\n                        if (scope.uses_arguments && is_funarg(def)) return lhs;\n                        if (compressor.exposed(def)) return lhs;\n                        remaining = remaining_refs(def);\n                        if (def.fixed && lhs.fixed) {\n                            var matches = def.references.filter(function(ref) {\n                                return ref.fixed === lhs.fixed;\n                            }).length - 1;\n                            if (matches < remaining) {\n                                remaining = matches;\n                                assign_pos = 0;\n                                verify_ref = true;\n                            }\n                        }\n                        if (expr.operator == \"=\") mangleable_var(expr.right);\n                        return lhs;\n                    }\n                    if (expr instanceof AST_Binary) return expr.right.left;\n                    if (expr instanceof AST_Unary) return expr.expression;\n                    if (expr instanceof AST_VarDef) {\n                        var lhs = expr.name;\n                        var def = lhs.definition();\n                        if (def.const_redefs) return;\n                        if (!member(lhs, def.orig)) return;\n                        if (scope.uses_arguments && is_funarg(def)) return;\n                        var declared = def.orig.length - def.eliminated - (declare_only.get(def.name) || 0);\n                        remaining = remaining_refs(def);\n                        if (def.fixed) remaining = Math.min(remaining, def.references.filter(function(ref) {\n                            if (!ref.fixed) return true;\n                            if (!ref.fixed.assigns) return true;\n                            var assign = ref.fixed.assigns[0];\n                            return assign === lhs || get_rvalue(assign) === expr.value;\n                        }).length);\n                        if (declared > 1 && !(lhs instanceof AST_SymbolFunarg)) {\n                            mangleable_var(expr.value);\n                            return make_node(AST_SymbolRef, lhs);\n                        }\n                        if (mangleable_var(expr.value) || remaining == 1 && !compressor.exposed(def)) {\n                            return make_node(AST_SymbolRef, lhs);\n                        }\n                        return;\n                    }\n                }\n\n                function get_rvalue(expr) {\n                    if (expr instanceof AST_Assign) return expr.right;\n                    if (expr instanceof AST_Binary) {\n                        var node = expr.clone();\n                        node.right = expr.right.right;\n                        return node;\n                    }\n                    if (expr instanceof AST_VarDef) return expr.value;\n                }\n\n                function invariant(expr) {\n                    if (expr instanceof AST_Array) return false;\n                    if (expr instanceof AST_Binary && lazy_op[expr.operator]) {\n                        return invariant(expr.left) && invariant(expr.right);\n                    }\n                    if (expr instanceof AST_Call) return false;\n                    if (expr instanceof AST_Conditional) {\n                        return invariant(expr.consequent) && invariant(expr.alternative);\n                    }\n                    if (expr instanceof AST_Object) return false;\n                    return !expr.has_side_effects(compressor);\n                }\n\n                function foldable(expr) {\n                    if (expr instanceof AST_Assign && expr.right.single_use) return;\n                    var lhs_ids = Object.create(null);\n                    var marker = new TreeWalker(function(node) {\n                        if (node instanceof AST_SymbolRef) lhs_ids[node.definition().id] = true;\n                    });\n                    while (expr instanceof AST_Assign && expr.operator == \"=\") {\n                        expr.left.walk(marker);\n                        expr = expr.right;\n                    }\n                    if (expr instanceof AST_ObjectIdentity) return rhs_exact_match;\n                    if (expr instanceof AST_SymbolRef) {\n                        var value = expr.evaluate(compressor);\n                        if (value === expr) return rhs_exact_match;\n                        return rhs_fuzzy_match(value, rhs_exact_match);\n                    }\n                    if (expr.is_truthy()) return rhs_fuzzy_match(true, return_false);\n                    if (expr.is_constant()) {\n                        var ev = expr.evaluate(compressor);\n                        if (!(ev instanceof AST_Node)) return rhs_fuzzy_match(ev, rhs_exact_match);\n                    }\n                    if (!(lhs instanceof AST_SymbolRef)) return false;\n                    if (!invariant(expr)) return false;\n                    var circular;\n                    expr.walk(new TreeWalker(function(node) {\n                        if (circular) return true;\n                        if (node instanceof AST_SymbolRef && lhs_ids[node.definition().id]) circular = true;\n                    }));\n                    return !circular && rhs_exact_match;\n\n                    function rhs_exact_match(node) {\n                        return expr.equals(node);\n                    }\n                }\n\n                function rhs_fuzzy_match(value, fallback) {\n                    return function(node, tw) {\n                        if (tw.in_boolean_context()) {\n                            if (value && node.is_truthy() && !node.has_side_effects(compressor)) {\n                                return true;\n                            }\n                            if (node.is_constant()) {\n                                var ev = node.evaluate(compressor);\n                                if (!(ev instanceof AST_Node)) return !ev == !value;\n                            }\n                        }\n                        return fallback(node);\n                    };\n                }\n\n                function clear_write_only(assign) {\n                    while (assign.write_only) {\n                        assign.write_only = false;\n                        if (!(assign instanceof AST_Assign)) break;\n                        assign = assign.right;\n                    }\n                }\n\n                function update_symbols(value, node) {\n                    var scope = node.scope || find_scope(scanner) || block_scope;\n                    value.walk(new TreeWalker(function(node) {\n                        if (node instanceof AST_BlockScope) return true;\n                        if (node instanceof AST_Symbol) node.scope = scope;\n                    }));\n                }\n\n                function may_be_global(node) {\n                    if (node instanceof AST_SymbolRef) {\n                        node = node.fixed_value();\n                        if (!node) return true;\n                    }\n                    if (node instanceof AST_Assign) return node.operator == \"=\" && may_be_global(node.right);\n                    return node instanceof AST_PropAccess || node instanceof AST_ObjectIdentity;\n                }\n\n                function get_lvalues(expr) {\n                    var lvalues = new Dictionary();\n                    if (expr instanceof AST_VarDef) {\n                        if (!expr.name.definition().fixed) well_defined = false;\n                        lvalues.add(expr.name.name, lhs);\n                    }\n                    var find_arguments = scope.uses_arguments && !compressor.has_directive(\"use strict\");\n                    var scan_toplevel = scope instanceof AST_Toplevel;\n                    var tw = new TreeWalker(function(node) {\n                        var value;\n                        if (node instanceof AST_SymbolRef) {\n                            value = node.fixed_value();\n                            if (!value) {\n                                value = node;\n                                var def = node.definition();\n                                var escaped = node.fixed && node.fixed.escaped || def.escaped;\n                                if (!def.undeclared\n                                    && (def.assignments || !escaped || escaped.cross_scope)\n                                    && (has_escaped(def, node.scope, node, tw.parent()) || !same_scope(def))) {\n                                    well_defined = false;\n                                }\n                            }\n                        } else if (node instanceof AST_ObjectIdentity) {\n                            value = node;\n                        }\n                        if (value) {\n                            lvalues.add(node.name, is_modified(compressor, tw, node, value, 0));\n                        } else if (node instanceof AST_Lambda) {\n                            for (var level = 0, parent, child = node; parent = tw.parent(level++); child = parent) {\n                                if (parent instanceof AST_Assign) {\n                                    if (parent.left === child) break;\n                                    if (parent.operator == \"=\") continue;\n                                    if (lazy_op[parent.operator.slice(0, -1)]) continue;\n                                    break;\n                                }\n                                if (parent instanceof AST_Binary) {\n                                    if (lazy_op[parent.operator]) continue;\n                                    break;\n                                }\n                                if (parent instanceof AST_Call) return;\n                                if (parent instanceof AST_Scope) return;\n                                if (parent instanceof AST_Sequence) {\n                                    if (parent.tail_node() === child) continue;\n                                    break;\n                                }\n                                if (parent instanceof AST_Template) {\n                                    if (parent.tag) return;\n                                    break;\n                                }\n                            }\n                            node.enclosed.forEach(function(def) {\n                                if (def.scope !== node) enclosed.set(def.name, true);\n                            });\n                            return true;\n                        } else if (find_arguments && node instanceof AST_Sub) {\n                            scope.each_argname(function(argname) {\n                                if (!compressor.option(\"reduce_vars\") || argname.definition().assignments) {\n                                    if (!argname.definition().fixed) well_defined = false;\n                                    lvalues.add(argname.name, true);\n                                }\n                            });\n                            find_arguments = false;\n                        }\n                        if (!scan_toplevel) return;\n                        if (node.TYPE == \"Call\") {\n                            if (modify_toplevel) return;\n                            var exp = node.expression;\n                            if (exp instanceof AST_PropAccess) return;\n                            if (exp instanceof AST_LambdaExpression && !exp.contains_this()) return;\n                            modify_toplevel = true;\n                        } else if (node instanceof AST_PropAccess && may_be_global(node.expression)) {\n                            if (node === lhs && !(expr instanceof AST_Unary)) {\n                                modify_toplevel = true;\n                            } else {\n                                read_toplevel = true;\n                            }\n                        }\n                    });\n                    expr.walk(tw);\n                    return lvalues;\n                }\n\n                function remove_candidate(expr) {\n                    var value = rvalue === rhs_value ? null : make_sequence(rhs_value, rhs_value.expressions.slice(0, -1));\n                    var index = expr.name_index;\n                    if (index >= 0) {\n                        var args, argname = scope.argnames[index];\n                        if (argname instanceof AST_DefaultValue) {\n                            scope.argnames[index] = argname = argname.clone();\n                            argname.value = value || make_node(AST_Number, argname, { value: 0 });\n                        } else if ((args = compressor.parent().args)[index]) {\n                            scope.argnames[index] = argname.clone();\n                            args[index] = value || make_node(AST_Number, args[index], { value: 0 });\n                        }\n                        return;\n                    }\n                    var end = hit_stack.length - 1;\n                    var last = hit_stack[end];\n                    if (last instanceof AST_VarDef || hit_stack[end - 1].body === last) end--;\n                    var tt = new TreeTransformer(function(node, descend, in_list) {\n                        if (hit) return node;\n                        if (node !== hit_stack[hit_index]) return node;\n                        hit_index++;\n                        if (hit_index <= end) return handle_custom_scan_order(node, tt);\n                        hit = true;\n                        if (node instanceof AST_Definitions) {\n                            declare_only.set(last.name.name, (declare_only.get(last.name.name) || 0) + 1);\n                            if (value_def) value_def.replaced++;\n                            var defns = node.definitions;\n                            var index = defns.indexOf(last);\n                            var defn = last.clone();\n                            defn.value = null;\n                            if (!value) {\n                                node.definitions[index] = defn;\n                                return node;\n                            }\n                            var body = [ make_node(AST_SimpleStatement, value, { body: value }) ];\n                            if (index > 0) {\n                                var head = node.clone();\n                                head.definitions = defns.slice(0, index);\n                                body.unshift(head);\n                                node = node.clone();\n                                node.definitions = defns.slice(index);\n                            }\n                            body.push(node);\n                            node.definitions[0] = defn;\n                            return in_list ? List.splice(body) : make_node(AST_BlockStatement, node, { body: body });\n                        }\n                        if (!value) return in_list ? List.skip : null;\n                        return is_statement(node) ? make_node(AST_SimpleStatement, value, { body: value }) : value;\n                    }, function(node, in_list) {\n                        if (node instanceof AST_For) return patch_for_init(node, in_list);\n                        return patch_sequence(node, tt);\n                    });\n                    abort = false;\n                    hit = false;\n                    hit_index = 0;\n                    if (!(statements[stat_index] = statements[stat_index].transform(tt))) statements.splice(stat_index, 1);\n                }\n\n                function patch_sequence(node, tt) {\n                    if (node instanceof AST_Sequence) switch (node.expressions.length) {\n                      case 0: return null;\n                      case 1: return maintain_this_binding(tt.parent(), node, node.expressions[0]);\n                    }\n                }\n\n                function is_lhs_local(lhs) {\n                    var sym = root_expr(lhs);\n                    if (!(sym instanceof AST_SymbolRef)) return false;\n                    if (sym.definition().scope.resolve() !== scope) return false;\n                    if (!in_loop) return true;\n                    if (compound) return false;\n                    if (candidate instanceof AST_Unary) return false;\n                    var lvalue = lvalues.get(sym.name);\n                    return !lvalue || lvalue[0] === lhs;\n                }\n\n                function value_has_side_effects() {\n                    if (candidate instanceof AST_Unary) return false;\n                    return rvalue.has_side_effects(compressor);\n                }\n\n                function replace_all_symbols(expr) {\n                    if (expr instanceof AST_Unary) return false;\n                    if (side_effects) return false;\n                    if (value_def) return true;\n                    if (!(lhs instanceof AST_SymbolRef)) return false;\n                    var referenced;\n                    if (expr instanceof AST_VarDef) {\n                        referenced = 1;\n                    } else if (expr.operator == \"=\") {\n                        referenced = 2;\n                    } else {\n                        return false;\n                    }\n                    var def = lhs.definition();\n                    if (def.references.length - def.replaced == referenced) return true;\n                    if (!def.fixed) return false;\n                    if (!lhs.fixed) return false;\n                    var assigns = lhs.fixed.assigns;\n                    var matched = 0;\n                    if (!all(def.references, function(ref, index) {\n                        var fixed = ref.fixed;\n                        if (!fixed) return false;\n                        if (fixed.to_binary || fixed.to_prefix) return false;\n                        if (fixed === lhs.fixed) {\n                            matched++;\n                            return true;\n                        }\n                        return assigns && fixed.assigns && assigns[0] !== fixed.assigns[0];\n                    })) return false;\n                    if (matched != referenced) return false;\n                    verify_ref = true;\n                    return true;\n                }\n\n                function symbol_in_lvalues(sym, parent) {\n                    var lvalue = lvalues.get(sym.name);\n                    if (!lvalue || all(lvalue, function(lhs) {\n                        return !lhs;\n                    })) return;\n                    if (lvalue[0] !== lhs) return true;\n                    scan_rhs = false;\n                }\n\n                function may_modify(sym) {\n                    var def = sym.definition();\n                    if (def.orig.length == 1 && def.orig[0] instanceof AST_SymbolDefun) return false;\n                    if (def.scope.resolve() !== scope) return true;\n                    if (modify_toplevel && compressor.exposed(def)) return true;\n                    return !all(def.references, function(ref) {\n                        return ref.scope.resolve(true) === scope;\n                    });\n                }\n\n                function side_effects_external(node, lhs) {\n                    if (node instanceof AST_Assign) return side_effects_external(node.left, true);\n                    if (node instanceof AST_Unary) return side_effects_external(node.expression, true);\n                    if (node instanceof AST_VarDef) return node.value && side_effects_external(node.value);\n                    if (lhs) {\n                        if (node instanceof AST_Dot) return side_effects_external(node.expression, true);\n                        if (node instanceof AST_Sub) return side_effects_external(node.expression, true);\n                        if (node instanceof AST_SymbolRef) return node.definition().scope.resolve() !== scope;\n                    }\n                    return false;\n                }\n            }\n\n            function eliminate_spurious_blocks(statements) {\n                var changed = false, seen_dirs = [];\n                for (var i = 0; i < statements.length;) {\n                    var stat = statements[i];\n                    if (stat instanceof AST_BlockStatement) {\n                        if (all(stat.body, safe_to_trim)) {\n                            changed = true;\n                            eliminate_spurious_blocks(stat.body);\n                            [].splice.apply(statements, [i, 1].concat(stat.body));\n                            i += stat.body.length;\n                            continue;\n                        }\n                    }\n                    if (stat instanceof AST_Directive) {\n                        if (member(stat.value, seen_dirs)) {\n                            changed = true;\n                            statements.splice(i, 1);\n                            continue;\n                        }\n                        seen_dirs.push(stat.value);\n                    }\n                    if (stat instanceof AST_EmptyStatement) {\n                        changed = true;\n                        statements.splice(i, 1);\n                        continue;\n                    }\n                    i++;\n                }\n                return changed;\n            }\n\n            function handle_if_return(statements, compressor) {\n                var changed = false;\n                var parent = compressor.parent();\n                var self = compressor.self();\n                var declare_only, jump, merge_jump;\n                var in_iife = in_lambda && parent && parent.TYPE == \"Call\" && parent.expression === self;\n                var chain_if_returns = in_lambda && compressor.option(\"conditionals\") && compressor.option(\"sequences\");\n                var drop_return_void = !(in_try && in_try.bfinally && in_async_generator(scope));\n                var multiple_if_returns = has_multiple_if_returns(statements);\n                for (var i = statements.length; --i >= 0;) {\n                    var stat = statements[i];\n                    var j = next_index(i);\n                    var next = statements[j];\n\n                    if (in_lambda && declare_only && !next && stat instanceof AST_Return\n                        && drop_return_void && !(self instanceof AST_SwitchBranch)) {\n                        var body = stat.value;\n                        if (!body) {\n                            changed = true;\n                            statements.splice(i, 1);\n                            continue;\n                        }\n                        var tail = body.tail_node();\n                        if (is_undefined(tail)) {\n                            changed = true;\n                            if (body instanceof AST_UnaryPrefix) {\n                                body = body.expression;\n                            } else if (tail instanceof AST_UnaryPrefix) {\n                                body = body.clone();\n                                body.expressions[body.expressions.length - 1] = tail.expression;\n                            }\n                            statements[i] = make_node(AST_SimpleStatement, stat, { body: body });\n                            continue;\n                        }\n                    }\n\n                    if (stat instanceof AST_If) {\n                        var ab = aborts(stat.body);\n                        // if (foo()) { bar(); return; } else baz(); moo(); ---> if (foo()) bar(); else { baz(); moo(); }\n                        if (can_merge_flow(ab)) {\n                            if (ab.label) remove(ab.label.thedef.references, ab);\n                            changed = true;\n                            stat = stat.clone();\n                            stat.body = make_node(AST_BlockStatement, stat, {\n                                body: as_statement_array_with_return(stat.body, ab),\n                            });\n                            stat.alternative = make_node(AST_BlockStatement, stat, {\n                                body: as_statement_array(stat.alternative).concat(extract_functions(merge_jump, jump)),\n                            });\n                            adjust_refs(ab.value, merge_jump);\n                            statements[i] = stat;\n                            statements[i] = stat.transform(compressor);\n                            continue;\n                        }\n                        // if (foo()) { bar(); return x; } return y; ---> if (!foo()) return y; bar(); return x;\n                        if (ab && !stat.alternative && next instanceof AST_Jump) {\n                            var cond = stat.condition;\n                            var preference = i + 1 == j && stat.body instanceof AST_BlockStatement;\n                            cond = best_of_expression(cond, cond.negate(compressor), preference);\n                            if (cond !== stat.condition) {\n                                changed = true;\n                                stat = stat.clone();\n                                stat.condition = cond;\n                                var body = stat.body;\n                                stat.body = make_node(AST_BlockStatement, next, {\n                                    body: extract_functions(true, null, j + 1),\n                                });\n                                statements.splice(i, 1, stat, body);\n                                // proceed further only if `TreeWalker.stack` is in a consistent state\n                                //    https://github.com/mishoo/UglifyJS/issues/5595\n                                //    https://github.com/mishoo/UglifyJS/issues/5597\n                                if (!in_lambda || self instanceof AST_Block && self.body === statements) {\n                                    statements[i] = stat.transform(compressor);\n                                }\n                                continue;\n                            }\n                        }\n                        var alt = aborts(stat.alternative);\n                        // if (foo()) bar(); else { baz(); return; } moo(); ---> if (foo()) { bar(); moo(); } else baz();\n                        if (can_merge_flow(alt)) {\n                            if (alt.label) remove(alt.label.thedef.references, alt);\n                            changed = true;\n                            stat = stat.clone();\n                            stat.body = make_node(AST_BlockStatement, stat.body, {\n                                body: as_statement_array(stat.body).concat(extract_functions(merge_jump, jump)),\n                            });\n                            stat.alternative = make_node(AST_BlockStatement, stat.alternative, {\n                                body: as_statement_array_with_return(stat.alternative, alt),\n                            });\n                            adjust_refs(alt.value, merge_jump);\n                            statements[i] = stat;\n                            statements[i] = stat.transform(compressor);\n                            continue;\n                        }\n                        if (compressor.option(\"typeofs\")) {\n                            if (ab && !alt) {\n                                var stats = make_node(AST_BlockStatement, self, { body: statements.slice(i + 1) });\n                                mark_locally_defined(stat.condition, null, stats);\n                            }\n                            if (!ab && alt) {\n                                var stats = make_node(AST_BlockStatement, self, { body: statements.slice(i + 1) });\n                                mark_locally_defined(stat.condition, stats);\n                            }\n                        }\n                    }\n\n                    if (stat instanceof AST_If && stat.body instanceof AST_Return) {\n                        var value = stat.body.value;\n                        var in_bool = stat.body.in_bool || next instanceof AST_Return && next.in_bool;\n                        // if (foo()) return x; return y; ---> return foo() ? x : y;\n                        if (!stat.alternative && next instanceof AST_Return\n                            && (drop_return_void || !value == !next.value)) {\n                            changed = true;\n                            stat = stat.clone();\n                            stat.alternative = make_node(AST_BlockStatement, next, {\n                                body: extract_functions(true, null, j + 1),\n                            });\n                            statements[i] = stat;\n                            statements[i] = stat.transform(compressor);\n                            continue;\n                        }\n                        // if (foo()) return x; [ return ; ] ---> return foo() ? x : undefined;\n                        // if (foo()) return bar() ? x : void 0; ---> return foo() && bar() ? x : void 0;\n                        // if (foo()) return bar() ? void 0 : x; ---> return !foo() || bar() ? void 0 : x;\n                        if (in_lambda && declare_only && !next && !stat.alternative && (in_bool\n                            || value && multiple_if_returns\n                            || value instanceof AST_Conditional && (is_undefined(value.consequent, compressor)\n                                || is_undefined(value.alternative, compressor)))) {\n                            changed = true;\n                            stat = stat.clone();\n                            stat.alternative = make_node(AST_Return, stat, { value: null });\n                            statements[i] = stat;\n                            statements[i] = stat.transform(compressor);\n                            continue;\n                        }\n                        // if (a) return b; if (c) return d; e; ---> return a ? b : c ? d : void e;\n                        //\n                        // if sequences is not enabled, this can lead to an endless loop (issue #866).\n                        // however, with sequences on this helps producing slightly better output for\n                        // the example code.\n                        var prev, prev_stat;\n                        if (chain_if_returns && !stat.alternative\n                            && (!(prev_stat = statements[prev = prev_index(i)]) && in_iife\n                                || prev_stat instanceof AST_If && prev_stat.body instanceof AST_Return)\n                            && (!next ? !declare_only\n                                : next instanceof AST_SimpleStatement && next_index(j) == statements.length)) {\n                            changed = true;\n                            var exprs = [];\n                            stat = stat.clone();\n                            exprs.push(stat.condition);\n                            stat.condition = make_sequence(stat, exprs);\n                            stat.alternative = make_node(AST_BlockStatement, self, {\n                                body: extract_functions().concat(make_node(AST_Return, self, { value: null })),\n                            });\n                            statements[i] = stat.transform(compressor);\n                            i = prev + 1;\n                            continue;\n                        }\n                    }\n\n                    if (stat instanceof AST_Break || stat instanceof AST_Exit) {\n                        jump = stat;\n                        continue;\n                    }\n\n                    if (declare_only && jump && jump === next) eliminate_returns(stat);\n                }\n                return changed;\n\n                function has_multiple_if_returns(statements) {\n                    var n = 0;\n                    for (var i = statements.length; --i >= 0;) {\n                        var stat = statements[i];\n                        if (stat instanceof AST_If && stat.body instanceof AST_Return) {\n                            if (++n > 1) return true;\n                        }\n                    }\n                    return false;\n                }\n\n                function match_target(target) {\n                    return last_of(compressor, function(node) {\n                        return node === target;\n                    });\n                }\n\n                function match_return(ab, exact) {\n                    if (!jump) return false;\n                    if (jump.TYPE != ab.TYPE) return false;\n                    var value = ab.value;\n                    if (!value) return false;\n                    var equals = jump.equals(ab);\n                    if (!equals && value instanceof AST_Sequence) {\n                        value = value.tail_node();\n                        if (jump.value && jump.value.equals(value)) equals = 2;\n                    }\n                    if (!equals && !exact && jump.value instanceof AST_Sequence) {\n                        if (jump.value.tail_node().equals(value)) equals = 3;\n                    }\n                    return equals;\n                }\n\n                function can_drop_abort(ab) {\n                    if (ab instanceof AST_Exit) {\n                        if (merge_jump = match_return(ab)) return true;\n                        if (!in_lambda) return false;\n                        if (!(ab instanceof AST_Return)) return false;\n                        var value = ab.value;\n                        if (value && !is_undefined(value.tail_node())) return false;\n                        if (!(self instanceof AST_SwitchBranch)) return true;\n                        if (!jump) return false;\n                        if (jump instanceof AST_Exit && jump.value) return false;\n                        merge_jump = 4;\n                        return true;\n                    }\n                    if (!(ab instanceof AST_LoopControl)) return false;\n                    if (self instanceof AST_SwitchBranch) {\n                        if (jump instanceof AST_Exit) {\n                            if (!in_lambda) return false;\n                            if (jump.value) return false;\n                            merge_jump = true;\n                        } else if (jump) {\n                            if (compressor.loopcontrol_target(jump) !== parent) return false;\n                            merge_jump = true;\n                        } else if (jump === false) {\n                            return false;\n                        }\n                    }\n                    var lct = compressor.loopcontrol_target(ab);\n                    if (ab instanceof AST_Continue) return match_target(loop_body(lct));\n                    if (lct instanceof AST_IterationStatement) return false;\n                    return match_target(lct);\n                }\n\n                function can_merge_flow(ab) {\n                    merge_jump = false;\n                    if (!can_drop_abort(ab)) return false;\n                    for (var j = statements.length; --j > i;) {\n                        var stat = statements[j];\n                        if (stat instanceof AST_DefClass) {\n                            if (stat.name.definition().preinit) return false;\n                        } else if (stat instanceof AST_Const || stat instanceof AST_Let) {\n                            if (!all(stat.definitions, function(defn) {\n                                return !defn.name.match_symbol(function(node) {\n                                    return node instanceof AST_SymbolDeclaration && node.definition().preinit;\n                                });\n                            })) return false;\n                        }\n                    }\n                    return true;\n                }\n\n                function extract_functions(mode, stop, end) {\n                    var defuns = [];\n                    var lexical = false;\n                    var start = i + 1;\n                    if (!mode) {\n                        end = statements.length;\n                        jump = null;\n                    } else if (stop) {\n                        end = statements.lastIndexOf(stop);\n                    } else {\n                        stop = statements[end];\n                        if (stop !== jump) jump = false;\n                    }\n                    var tail = statements.splice(start, end - start).filter(function(stat) {\n                        if (stat instanceof AST_LambdaDefinition) {\n                            defuns.push(stat);\n                            return false;\n                        }\n                        if (is_lexical_definition(stat)) lexical = true;\n                        return true;\n                    });\n                    if (mode === 3) {\n                        tail.push(make_node(AST_SimpleStatement, stop.value, {\n                            body: make_sequence(stop.value, stop.value.expressions.slice(0, -1)),\n                        }));\n                        stop.value = stop.value.tail_node();\n                    }\n                    [].push.apply(lexical ? tail : statements, defuns);\n                    return tail;\n                }\n\n                function trim_return(value, mode) {\n                    if (value) switch (mode) {\n                      case 4:\n                        return value;\n                      case 3:\n                        if (!(value instanceof AST_Sequence)) break;\n                      case 2:\n                        return make_sequence(value, value.expressions.slice(0, -1));\n                    }\n                }\n\n                function as_statement_array_with_return(node, ab) {\n                    var body = as_statement_array(node);\n                    var block = body, last;\n                    while ((last = block[block.length - 1]) !== ab) {\n                        block = last.body;\n                    }\n                    block.pop();\n                    var value = ab.value;\n                    if (merge_jump) value = trim_return(value, merge_jump);\n                    if (value) block.push(make_node(AST_SimpleStatement, value, { body: value }));\n                    return body;\n                }\n\n                function adjust_refs(value, mode) {\n                    if (!mode) return;\n                    if (!value) return;\n                    switch (mode) {\n                      case 4:\n                        return;\n                      case 3:\n                      case 2:\n                        value = value.tail_node();\n                    }\n                    merge_expression(value, jump.value);\n                }\n\n                function next_index(i) {\n                    declare_only = true;\n                    for (var j = i; ++j < statements.length;) {\n                        var stat = statements[j];\n                        if (is_declaration(stat)) continue;\n                        if (stat instanceof AST_Var) {\n                            declare_only = false;\n                            continue;\n                        }\n                        break;\n                    }\n                    return j;\n                }\n\n                function prev_index(i) {\n                    for (var j = i; --j >= 0;) {\n                        var stat = statements[j];\n                        if (stat instanceof AST_Var) continue;\n                        if (is_declaration(stat)) continue;\n                        break;\n                    }\n                    return j;\n                }\n\n                function eliminate_returns(stat, keep_throws, in_block) {\n                    if (stat instanceof AST_Exit) {\n                        var mode = !(keep_throws && stat instanceof AST_Throw) && match_return(stat, true);\n                        if (mode) {\n                            changed = true;\n                            var value = trim_return(stat.value, mode);\n                            if (value) return make_node(AST_SimpleStatement, value, { body: value });\n                            return in_block ? null : make_node(AST_EmptyStatement, stat);\n                        }\n                    } else if (stat instanceof AST_If) {\n                        stat.body = eliminate_returns(stat.body, keep_throws);\n                        if (stat.alternative) stat.alternative = eliminate_returns(stat.alternative, keep_throws);\n                    } else if (stat instanceof AST_LabeledStatement) {\n                        stat.body = eliminate_returns(stat.body, keep_throws);\n                    } else if (stat instanceof AST_Try) {\n                        if (!stat.bfinally || !jump.value || jump.value.is_constant()) {\n                            if (stat.bcatch) eliminate_returns(stat.bcatch, keep_throws);\n                            var trimmed = eliminate_returns(stat.body.pop(), true, true);\n                            if (trimmed) stat.body.push(trimmed);\n                        }\n                    } else if (stat instanceof AST_Block && !(stat instanceof AST_Scope || stat instanceof AST_Switch)) {\n                        var trimmed = eliminate_returns(stat.body.pop(), keep_throws, true);\n                        if (trimmed) stat.body.push(trimmed);\n                    }\n                    return stat;\n                }\n            }\n\n            function eliminate_dead_code(statements, compressor) {\n                var has_quit;\n                var self = compressor.self();\n                if (self instanceof AST_Catch) {\n                    self = compressor.parent();\n                } else if (self instanceof AST_LabeledStatement) {\n                    self = self.body;\n                }\n                for (var i = 0, n = 0, len = statements.length; i < len; i++) {\n                    var stat = statements[i];\n                    if (stat instanceof AST_LoopControl) {\n                        var lct = compressor.loopcontrol_target(stat);\n                        if (loop_body(lct) !== self\n                            || stat instanceof AST_Break && lct instanceof AST_IterationStatement) {\n                            statements[n++] = stat;\n                        } else if (stat.label) {\n                            remove(stat.label.thedef.references, stat);\n                        }\n                    } else {\n                        statements[n++] = stat;\n                    }\n                    if (aborts(stat)) {\n                        has_quit = statements.slice(i + 1);\n                        break;\n                    }\n                }\n                statements.length = n;\n                if (has_quit) has_quit.forEach(function(stat) {\n                    extract_declarations_from_unreachable_code(compressor, stat, statements);\n                });\n                return statements.length != len;\n            }\n\n            function trim_awaits(statements, compressor) {\n                if (!in_lambda || in_try && in_try.bfinally) return;\n                var changed = false;\n                for (var index = statements.length; --index >= 0;) {\n                    var stat = statements[index];\n                    if (!(stat instanceof AST_SimpleStatement)) break;\n                    var node = stat.body;\n                    if (!(node instanceof AST_Await)) break;\n                    var exp = node.expression;\n                    if (!needs_enqueuing(compressor, exp)) break;\n                    changed = true;\n                    exp = exp.drop_side_effect_free(compressor, true);\n                    if (exp) {\n                        stat.body = exp;\n                        break;\n                    }\n                }\n                statements.length = index + 1;\n                return changed;\n            }\n\n            function inline_iife(statements, compressor) {\n                var changed = false;\n                var index = statements.length - 1;\n                if (in_lambda && index >= 0) {\n                    var no_return = in_try && in_try.bfinally && in_async_generator(scope);\n                    var inlined = statements[index].try_inline(compressor, block_scope, no_return);\n                    if (inlined) {\n                        statements[index--] = inlined;\n                        changed = true;\n                    }\n                }\n                var loop = in_loop && in_try && in_try.bfinally ? \"try\" : in_loop;\n                for (; index >= 0; index--) {\n                    var inlined = statements[index].try_inline(compressor, block_scope, true, loop);\n                    if (!inlined) continue;\n                    statements[index] = inlined;\n                    changed = true;\n                }\n                return changed;\n            }\n\n            function sequencesize(statements, compressor) {\n                if (statements.length < 2) return;\n                var seq = [], n = 0;\n                function push_seq() {\n                    if (!seq.length) return;\n                    var body = make_sequence(seq[0], seq);\n                    statements[n++] = make_node(AST_SimpleStatement, body, { body: body });\n                    seq = [];\n                }\n                for (var i = 0, len = statements.length; i < len; i++) {\n                    var stat = statements[i];\n                    if (stat instanceof AST_SimpleStatement) {\n                        if (seq.length >= compressor.sequences_limit) push_seq();\n                        merge_sequence(seq, stat.body);\n                    } else if (is_declaration(stat)) {\n                        statements[n++] = stat;\n                    } else {\n                        push_seq();\n                        statements[n++] = stat;\n                    }\n                }\n                push_seq();\n                statements.length = n;\n                return n != len;\n            }\n\n            function to_simple_statement(block, decls) {\n                if (!(block instanceof AST_BlockStatement)) return block;\n                var stat = null;\n                for (var i = 0; i < block.body.length; i++) {\n                    var line = block.body[i];\n                    if (line instanceof AST_Var && declarations_only(line)) {\n                        decls.push(line);\n                    } else if (stat || is_lexical_definition(line)) {\n                        return false;\n                    } else {\n                        stat = line;\n                    }\n                }\n                return stat;\n            }\n\n            function sequencesize_2(statements, compressor) {\n                var changed = false, n = 0, prev;\n                for (var i = 0; i < statements.length; i++) {\n                    var stat = statements[i];\n                    if (prev) {\n                        if (stat instanceof AST_Exit) {\n                            if (stat.value || !in_async_generator(scope)) {\n                                stat.value = cons_seq(stat.value || make_node(AST_Undefined, stat)).optimize(compressor);\n                            }\n                        } else if (stat instanceof AST_For) {\n                            if (!(stat.init instanceof AST_Definitions)) {\n                                var abort = false;\n                                prev.body.walk(new TreeWalker(function(node) {\n                                    if (abort || node instanceof AST_Scope) return true;\n                                    if (node instanceof AST_Binary && node.operator == \"in\") {\n                                        abort = true;\n                                        return true;\n                                    }\n                                }));\n                                if (!abort) {\n                                    if (stat.init) stat.init = cons_seq(stat.init);\n                                    else {\n                                        stat.init = prev.body;\n                                        n--;\n                                        changed = true;\n                                    }\n                                }\n                            }\n                        } else if (stat instanceof AST_ForIn) {\n                            if (!is_lexical_definition(stat.init)) stat.object = cons_seq(stat.object);\n                        } else if (stat instanceof AST_If) {\n                            stat.condition = cons_seq(stat.condition);\n                        } else if (stat instanceof AST_Switch) {\n                            stat.expression = cons_seq(stat.expression);\n                        } else if (stat instanceof AST_With) {\n                            stat.expression = cons_seq(stat.expression);\n                        }\n                    }\n                    if (compressor.option(\"conditionals\") && stat instanceof AST_If) {\n                        var decls = [];\n                        var body = to_simple_statement(stat.body, decls);\n                        var alt = to_simple_statement(stat.alternative, decls);\n                        if (body !== false && alt !== false && decls.length > 0) {\n                            var len = decls.length;\n                            decls.push(make_node(AST_If, stat, {\n                                condition: stat.condition,\n                                body: body || make_node(AST_EmptyStatement, stat.body),\n                                alternative: alt,\n                            }));\n                            decls.unshift(n, 1);\n                            [].splice.apply(statements, decls);\n                            i += len;\n                            n += len + 1;\n                            prev = null;\n                            changed = true;\n                            continue;\n                        }\n                    }\n                    statements[n++] = stat;\n                    prev = stat instanceof AST_SimpleStatement ? stat : null;\n                }\n                statements.length = n;\n                return changed;\n\n                function cons_seq(right) {\n                    n--;\n                    changed = true;\n                    var left = prev.body;\n                    return make_sequence(left, [ left, right ]);\n                }\n            }\n\n            function extract_exprs(body) {\n                if (body instanceof AST_Assign) return [ body ];\n                if (body instanceof AST_Sequence) return body.expressions.slice();\n            }\n\n            function join_assigns(defn, body, keep) {\n                var exprs = extract_exprs(body);\n                if (!exprs) return;\n                keep = keep || 0;\n                var trimmed = false;\n                for (var i = exprs.length - keep; --i >= 0;) {\n                    var expr = exprs[i];\n                    if (!can_trim(expr)) continue;\n                    var tail;\n                    if (expr.left instanceof AST_SymbolRef) {\n                        tail = exprs.slice(i + 1);\n                    } else if (expr.left instanceof AST_PropAccess && can_trim(expr.left.expression)) {\n                        tail = exprs.slice(i + 1);\n                        var flattened = expr.clone();\n                        expr = expr.left.expression;\n                        flattened.left = flattened.left.clone();\n                        flattened.left.expression = expr.left.clone();\n                        tail.unshift(flattened);\n                    } else {\n                        continue;\n                    }\n                    if (tail.length == 0) continue;\n                    if (!trim_assigns(expr.left, expr.right, tail)) continue;\n                    trimmed = true;\n                    exprs = exprs.slice(0, i).concat(expr, tail);\n                }\n                if (defn instanceof AST_Definitions) {\n                    for (var i = defn.definitions.length; --i >= 0;) {\n                        var def = defn.definitions[i];\n                        if (!def.value) continue;\n                        if (trim_assigns(def.name, def.value, exprs)) trimmed = true;\n                        if (merge_conditional_assignments(def, exprs, keep)) trimmed = true;\n                        break;\n                    }\n                    if (defn instanceof AST_Var && join_var_assign(defn.definitions, exprs, keep)) trimmed = true;\n                }\n                return trimmed && exprs;\n\n                function can_trim(node) {\n                    return node instanceof AST_Assign && node.operator == \"=\";\n                }\n            }\n\n            function merge_assigns(prev, defn) {\n                if (!(prev instanceof AST_SimpleStatement)) return;\n                if (declarations_only(defn)) return;\n                var exprs = extract_exprs(prev.body);\n                if (!exprs) return;\n                var definitions = [];\n                if (!join_var_assign(definitions, exprs.reverse(), 0)) return;\n                defn.definitions = definitions.reverse().concat(defn.definitions);\n                return exprs.reverse();\n            }\n\n            function merge_conditional_assignments(var_def, exprs, keep) {\n                if (!compressor.option(\"conditionals\")) return;\n                if (var_def.name instanceof AST_Destructured) return;\n                var trimmed = false;\n                var def = var_def.name.definition();\n                while (exprs.length > keep) {\n                    var cond = to_conditional_assignment(compressor, def, var_def.value, exprs[0]);\n                    if (!cond) break;\n                    var_def.value = cond;\n                    exprs.shift();\n                    trimmed = true;\n                }\n                return trimmed;\n            }\n\n            function join_var_assign(definitions, exprs, keep) {\n                var trimmed = false;\n                while (exprs.length > keep) {\n                    var expr = exprs[0];\n                    if (!(expr instanceof AST_Assign)) break;\n                    if (expr.operator != \"=\") break;\n                    var lhs = expr.left;\n                    if (!(lhs instanceof AST_SymbolRef)) break;\n                    if (is_undeclared_ref(lhs)) break;\n                    if (lhs.scope.resolve() !== scope) break;\n                    var def = lhs.definition();\n                    if (def.scope !== scope) break;\n                    if (def.orig.length > def.eliminated + 1) break;\n                    if (def.orig[0].TYPE != \"SymbolVar\") break;\n                    var name = make_node(AST_SymbolVar, lhs);\n                    definitions.push(make_node(AST_VarDef, expr, {\n                        name: name,\n                        value: expr.right,\n                    }));\n                    def.orig.push(name);\n                    def.replaced++;\n                    exprs.shift();\n                    trimmed = true;\n                }\n                return trimmed;\n            }\n\n            function trim_assigns(name, value, exprs) {\n                var names = new Dictionary();\n                names.set(name.name, true);\n                while (value instanceof AST_Assign && value.operator == \"=\") {\n                    if (value.left instanceof AST_SymbolRef) names.set(value.left.name, true);\n                    value = value.right;\n                }\n                if (!(value instanceof AST_Object)) return;\n                var trimmed = false;\n                do {\n                    if (!try_join(exprs[0])) break;\n                    exprs.shift();\n                    trimmed = true;\n                } while (exprs.length);\n                return trimmed;\n\n                function try_join(node) {\n                    if (!(node instanceof AST_Assign)) return;\n                    if (node.operator != \"=\") return;\n                    if (!(node.left instanceof AST_PropAccess)) return;\n                    var sym = node.left.expression;\n                    if (!(sym instanceof AST_SymbolRef)) return;\n                    if (!names.has(sym.name)) return;\n                    if (!node.right.is_constant_expression(scope)) return;\n                    var prop = node.left.property;\n                    if (prop instanceof AST_Node) {\n                        if (try_join(prop)) prop = node.left.property = prop.right.clone();\n                        prop = prop.evaluate(compressor);\n                    }\n                    if (prop instanceof AST_Node) return;\n                    prop = \"\" + prop;\n                    var diff = prop == \"__proto__\" || compressor.has_directive(\"use strict\") ? function(node) {\n                        var key = node.key;\n                        return typeof key == \"string\" && key != prop && key != \"__proto__\";\n                    } : function(node) {\n                        var key = node.key;\n                        if (node instanceof AST_ObjectGetter || node instanceof AST_ObjectSetter) {\n                            return typeof key == \"string\" && key != prop;\n                        }\n                        return key !== \"__proto__\";\n                    };\n                    if (!all(value.properties, diff)) return;\n                    value.properties.push(make_node(AST_ObjectKeyVal, node, {\n                        key: prop,\n                        value: node.right,\n                    }));\n                    return true;\n                }\n            }\n\n            function join_consecutive_vars(statements) {\n                var changed = false, defs;\n                for (var i = 0, j = -1; i < statements.length; i++) {\n                    var stat = statements[i];\n                    var prev = statements[j];\n                    if (stat instanceof AST_Definitions) {\n                        if (prev && prev.TYPE == stat.TYPE) {\n                            prev.definitions = prev.definitions.concat(stat.definitions);\n                            changed = true;\n                        } else if (defs && defs.TYPE == stat.TYPE && declarations_only(stat)) {\n                            defs.definitions = defs.definitions.concat(stat.definitions);\n                            changed = true;\n                        } else if (stat instanceof AST_Var) {\n                            var exprs = merge_assigns(prev, stat);\n                            if (exprs) {\n                                if (exprs.length) {\n                                    prev.body = make_sequence(prev, exprs);\n                                    j++;\n                                }\n                                changed = true;\n                            } else {\n                                j++;\n                            }\n                            statements[j] = defs = stat;\n                        } else {\n                            statements[++j] = stat;\n                        }\n                        continue;\n                    } else if (stat instanceof AST_Exit) {\n                        stat.value = join_assigns_expr(stat.value);\n                    } else if (stat instanceof AST_For) {\n                        var exprs = join_assigns(prev, stat.init);\n                        if (exprs) {\n                            changed = true;\n                            stat.init = exprs.length ? make_sequence(stat.init, exprs) : null;\n                        } else if (prev instanceof AST_Var && (!stat.init || stat.init.TYPE == prev.TYPE)) {\n                            if (stat.init) {\n                                prev.definitions = prev.definitions.concat(stat.init.definitions);\n                            }\n                            stat = stat.clone();\n                            defs = stat.init = prev;\n                            statements[j] = merge_defns(stat);\n                            changed = true;\n                            continue;\n                        } else if (defs && stat.init && defs.TYPE == stat.init.TYPE && declarations_only(stat.init)) {\n                            defs.definitions = defs.definitions.concat(stat.init.definitions);\n                            stat.init = null;\n                            changed = true;\n                        } else if (stat.init instanceof AST_Var) {\n                            defs = stat.init;\n                            exprs = merge_assigns(prev, stat.init);\n                            if (exprs) {\n                                changed = true;\n                                if (exprs.length == 0) {\n                                    statements[j] = merge_defns(stat);\n                                    continue;\n                                }\n                                prev.body = make_sequence(prev, exprs);\n                            }\n                        }\n                    } else if (stat instanceof AST_ForEnumeration) {\n                        if (defs && defs.TYPE == stat.init.TYPE) {\n                            var defns = defs.definitions.slice();\n                            stat.init = stat.init.definitions[0].name.convert_symbol(AST_SymbolRef, function(ref, name) {\n                                defns.push(make_node(AST_VarDef, name, {\n                                    name: name,\n                                    value: null,\n                                }));\n                                name.definition().references.push(ref);\n                            });\n                            defs.definitions = defns;\n                            changed = true;\n                        }\n                        stat.object = join_assigns_expr(stat.object);\n                    } else if (stat instanceof AST_If) {\n                        stat.condition = join_assigns_expr(stat.condition);\n                    } else if (stat instanceof AST_SimpleStatement) {\n                        var exprs = join_assigns(prev, stat.body), next;\n                        if (exprs) {\n                            changed = true;\n                            if (!exprs.length) continue;\n                            stat.body = make_sequence(stat.body, exprs);\n                        } else if (prev instanceof AST_Definitions\n                            && (next = statements[i + 1])\n                            && prev.TYPE == next.TYPE\n                            && (next = next.definitions[0]).value) {\n                            changed = true;\n                            next.value = make_sequence(stat, [ stat.body, next.value ]);\n                            continue;\n                        }\n                    } else if (stat instanceof AST_Switch) {\n                        stat.expression = join_assigns_expr(stat.expression);\n                    } else if (stat instanceof AST_With) {\n                        stat.expression = join_assigns_expr(stat.expression);\n                    }\n                    statements[++j] = defs ? merge_defns(stat) : stat;\n                }\n                statements.length = j + 1;\n                return changed;\n\n                function join_assigns_expr(value) {\n                    var exprs = join_assigns(prev, value, 1);\n                    if (!exprs) return value;\n                    changed = true;\n                    var tail = value.tail_node();\n                    if (exprs[exprs.length - 1] !== tail) exprs.push(tail.left);\n                    return make_sequence(value, exprs);\n                }\n\n                function merge_defns(stat) {\n                    return stat.transform(new TreeTransformer(function(node, descend, in_list) {\n                        if (node instanceof AST_Definitions) {\n                            if (defs === node) return node;\n                            if (defs.TYPE != node.TYPE) return node;\n                            var parent = this.parent();\n                            if (parent instanceof AST_ForEnumeration && parent.init === node) return node;\n                            if (!declarations_only(node)) return node;\n                            defs.definitions = defs.definitions.concat(node.definitions);\n                            changed = true;\n                            if (parent instanceof AST_For && parent.init === node) return null;\n                            return in_list ? List.skip : make_node(AST_EmptyStatement, node);\n                        }\n                        if (node instanceof AST_ExportDeclaration) return node;\n                        if (node instanceof AST_Scope) return node;\n                        if (!is_statement(node)) return node;\n                    }));\n                }\n            }\n        }\n\n        function extract_declarations_from_unreachable_code(compressor, stat, target) {\n            var block;\n            var dropped = false;\n            stat.walk(new TreeWalker(function(node, descend) {\n                if (node instanceof AST_DefClass) {\n                    node.extends = null;\n                    node.properties = [];\n                    push(node);\n                    return true;\n                }\n                if (node instanceof AST_Definitions) {\n                    var defns = [];\n                    if (node.remove_initializers(compressor, defns)) {\n                        AST_Node.warn(\"Dropping initialization in unreachable code [{start}]\", node);\n                    }\n                    if (defns.length > 0) {\n                        node.definitions = defns;\n                        push(node);\n                    }\n                    return true;\n                }\n                if (node instanceof AST_LambdaDefinition) {\n                    push(node);\n                    return true;\n                }\n                if (node instanceof AST_Scope) return true;\n                if (node instanceof AST_BlockScope) {\n                    var save = block;\n                    block = [];\n                    descend();\n                    if (block.required) {\n                        target.push(make_node(AST_BlockStatement, stat, { body: block }));\n                    } else if (block.length) {\n                        [].push.apply(target, block);\n                    }\n                    block = save;\n                    return true;\n                }\n                if (!(node instanceof AST_LoopControl)) dropped = true;\n            }));\n            if (dropped) AST_Node.warn(\"Dropping unreachable code [{start}]\", stat);\n\n            function push(node) {\n                if (block) {\n                    block.push(node);\n                    if (!safe_to_trim(node)) block.required = true;\n                } else {\n                    target.push(node);\n                }\n            }\n        }\n\n        function is_undefined(node, compressor) {\n            return node == null\n                || node.is_undefined\n                || node instanceof AST_Undefined\n                || node instanceof AST_UnaryPrefix\n                    && node.operator == \"void\"\n                    && !(compressor && node.expression.has_side_effects(compressor));\n        }\n\n        // in_strict_mode()\n        // return true if scope executes in Strict Mode\n        (function(def) {\n            def(AST_Class, return_true);\n            def(AST_Scope, function(compressor) {\n                var body = this.body;\n                for (var i = 0; i < body.length; i++) {\n                    var stat = body[i];\n                    if (!(stat instanceof AST_Directive)) break;\n                    if (stat.value == \"use strict\") return true;\n                }\n                var parent = this.parent_scope;\n                if (!parent) return compressor.option(\"module\");\n                return parent.resolve(true).in_strict_mode(compressor);\n            });\n        })(function(node, func) {\n            node.DEFMETHOD(\"in_strict_mode\", func);\n        });\n\n        // is_truthy()\n        // return true if `!!node === true`\n        (function(def) {\n            def(AST_Node, return_false);\n            def(AST_Array, return_true);\n            def(AST_Assign, function() {\n                return this.operator == \"=\" && this.right.is_truthy();\n            });\n            def(AST_Lambda, return_true);\n            def(AST_Object, return_true);\n            def(AST_RegExp, return_true);\n            def(AST_Sequence, function() {\n                return this.tail_node().is_truthy();\n            });\n            def(AST_SymbolRef, function() {\n                var fixed = this.fixed_value();\n                if (!fixed) return false;\n                this.is_truthy = return_false;\n                var result = fixed.is_truthy();\n                delete this.is_truthy;\n                return result;\n            });\n        })(function(node, func) {\n            node.DEFMETHOD(\"is_truthy\", func);\n        });\n\n        // is_negative_zero()\n        // return true if the node may represent -0\n        (function(def) {\n            def(AST_Node, return_true);\n            def(AST_Array, return_false);\n            function binary(op, left, right) {\n                switch (op) {\n                  case \"-\":\n                    return left.is_negative_zero()\n                        && (!(right instanceof AST_Constant) || right.value == 0);\n                  case \"&&\":\n                  case \"||\":\n                    return left.is_negative_zero() || right.is_negative_zero();\n                  case \"*\":\n                  case \"/\":\n                  case \"%\":\n                  case \"**\":\n                    return true;\n                  default:\n                    return false;\n                }\n            }\n            def(AST_Assign, function() {\n                var op = this.operator;\n                if (op == \"=\") return this.right.is_negative_zero();\n                return binary(op.slice(0, -1), this.left, this.right);\n            });\n            def(AST_Binary, function() {\n                return binary(this.operator, this.left, this.right);\n            });\n            def(AST_Constant, function() {\n                return this.value == 0 && 1 / this.value < 0;\n            });\n            def(AST_Lambda, return_false);\n            def(AST_Object, return_false);\n            def(AST_RegExp, return_false);\n            def(AST_Sequence, function() {\n                return this.tail_node().is_negative_zero();\n            });\n            def(AST_SymbolRef, function() {\n                var fixed = this.fixed_value();\n                if (!fixed) return true;\n                this.is_negative_zero = return_true;\n                var result = fixed.is_negative_zero();\n                delete this.is_negative_zero;\n                return result;\n            });\n            def(AST_UnaryPrefix, function() {\n                return this.operator == \"+\" && this.expression.is_negative_zero()\n                    || this.operator == \"-\";\n            });\n        })(function(node, func) {\n            node.DEFMETHOD(\"is_negative_zero\", func);\n        });\n\n        // may_throw_on_access()\n        // returns true if this node may be null, undefined or contain `AST_Accessor`\n        (function(def) {\n            AST_Node.DEFMETHOD(\"may_throw_on_access\", function(compressor, force) {\n                return !compressor.option(\"pure_getters\") || this._dot_throw(compressor, force);\n            });\n            function is_strict(compressor, force) {\n                return force || /strict/.test(compressor.option(\"pure_getters\"));\n            }\n            def(AST_Node, is_strict);\n            def(AST_Array, return_false);\n            def(AST_Assign, function(compressor) {\n                var op = this.operator;\n                var sym = this.left;\n                var rhs = this.right;\n                if (op != \"=\") {\n                    return lazy_op[op.slice(0, -1)] && (sym._dot_throw(compressor) || rhs._dot_throw(compressor));\n                }\n                if (!rhs._dot_throw(compressor)) return false;\n                if (!(sym instanceof AST_SymbolRef)) return true;\n                if (rhs instanceof AST_Binary && rhs.operator == \"||\" && sym.name == rhs.left.name) {\n                    return rhs.right._dot_throw(compressor);\n                }\n                return true;\n            });\n            def(AST_Binary, function(compressor) {\n                return lazy_op[this.operator] && (this.left._dot_throw(compressor) || this.right._dot_throw(compressor));\n            });\n            def(AST_Class, function(compressor, force) {\n                return is_strict(compressor, force) && !all(this.properties, function(prop) {\n                    if (prop.private) return true;\n                    if (!prop.static) return true;\n                    return !(prop instanceof AST_ClassGetter || prop instanceof AST_ClassSetter);\n                });\n            });\n            def(AST_Conditional, function(compressor) {\n                return this.consequent._dot_throw(compressor) || this.alternative._dot_throw(compressor);\n            });\n            def(AST_Constant, return_false);\n            def(AST_Dot, function(compressor, force) {\n                if (!is_strict(compressor, force)) return false;\n                var exp = this.expression;\n                if (exp instanceof AST_SymbolRef) exp = exp.fixed_value();\n                return !(this.property == \"prototype\" && is_lambda(exp));\n            });\n            def(AST_Lambda, return_false);\n            def(AST_Null, return_true);\n            def(AST_Object, function(compressor, force) {\n                return is_strict(compressor, force) && !all(this.properties, function(prop) {\n                    if (prop instanceof AST_ObjectGetter || prop instanceof AST_ObjectSetter) return false;\n                    return !(prop.key === \"__proto__\" && prop.value._dot_throw(compressor, force));\n                });\n            });\n            def(AST_ObjectIdentity, function(compressor, force) {\n                return is_strict(compressor, force) && !this.scope.resolve().new;\n            });\n            def(AST_Sequence, function(compressor) {\n                return this.tail_node()._dot_throw(compressor);\n            });\n            def(AST_SymbolRef, function(compressor, force) {\n                if (this.is_undefined) return true;\n                if (!is_strict(compressor, force)) return false;\n                if (is_undeclared_ref(this) && this.is_declared(compressor)) return false;\n                if (this.is_immutable()) return false;\n                var def = this.definition();\n                if (is_arguments(def) && !def.scope.rest && all(def.scope.argnames, function(argname) {\n                    return argname instanceof AST_SymbolFunarg;\n                })) return def.scope.uses_arguments > 2;\n                var fixed = this.fixed_value(true);\n                if (!fixed) return true;\n                this._dot_throw = return_true;\n                if (fixed._dot_throw(compressor)) {\n                    delete this._dot_throw;\n                    return true;\n                }\n                this._dot_throw = return_false;\n                return false;\n            });\n            def(AST_UnaryPrefix, function() {\n                return this.operator == \"void\";\n            });\n            def(AST_UnaryPostfix, return_false);\n            def(AST_Undefined, return_true);\n        })(function(node, func) {\n            node.DEFMETHOD(\"_dot_throw\", func);\n        });\n\n        (function(def) {\n            def(AST_Node, return_false);\n            def(AST_Array, return_true);\n            function is_binary_defined(compressor, op, node) {\n                switch (op) {\n                  case \"&&\":\n                    return node.left.is_defined(compressor) && node.right.is_defined(compressor);\n                  case \"||\":\n                    return node.left.is_truthy() || node.right.is_defined(compressor);\n                  case \"??\":\n                    return node.left.is_defined(compressor) || node.right.is_defined(compressor);\n                  default:\n                    return true;\n                }\n            }\n            def(AST_Assign, function(compressor) {\n                var op = this.operator;\n                if (op == \"=\") return this.right.is_defined(compressor);\n                return is_binary_defined(compressor, op.slice(0, -1), this);\n            });\n            def(AST_Binary, function(compressor) {\n                return is_binary_defined(compressor, this.operator, this);\n            });\n            def(AST_Conditional, function(compressor) {\n                return this.consequent.is_defined(compressor) && this.alternative.is_defined(compressor);\n            });\n            def(AST_Constant, return_true);\n            def(AST_Hole, return_false);\n            def(AST_Lambda, return_true);\n            def(AST_Object, return_true);\n            def(AST_Sequence, function(compressor) {\n                return this.tail_node().is_defined(compressor);\n            });\n            def(AST_SymbolRef, function(compressor) {\n                if (this.is_undefined) return false;\n                if (is_undeclared_ref(this) && this.is_declared(compressor)) return true;\n                if (this.is_immutable()) return true;\n                var fixed = this.fixed_value();\n                if (!fixed) return false;\n                this.is_defined = return_false;\n                var result = fixed.is_defined(compressor);\n                delete this.is_defined;\n                return result;\n            });\n            def(AST_UnaryPrefix, function() {\n                return this.operator != \"void\";\n            });\n            def(AST_UnaryPostfix, return_true);\n            def(AST_Undefined, return_false);\n        })(function(node, func) {\n            node.DEFMETHOD(\"is_defined\", func);\n        });\n\n        /* -----[ boolean/negation helpers ]----- */\n\n        // methods to determine whether an expression has a boolean result type\n        (function(def) {\n            def(AST_Node, return_false);\n            def(AST_Assign, function(compressor) {\n                return this.operator == \"=\" && this.right.is_boolean(compressor);\n            });\n            var binary = makePredicate(\"in instanceof == != === !== < <= >= >\");\n            def(AST_Binary, function(compressor) {\n                return binary[this.operator] || lazy_op[this.operator]\n                    && this.left.is_boolean(compressor)\n                    && this.right.is_boolean(compressor);\n            });\n            def(AST_Boolean, return_true);\n            var fn = makePredicate(\"every hasOwnProperty isPrototypeOf propertyIsEnumerable some\");\n            def(AST_Call, function(compressor) {\n                if (!compressor.option(\"unsafe\")) return false;\n                var exp = this.expression;\n                return exp instanceof AST_Dot && (fn[exp.property]\n                    || exp.property == \"test\" && exp.expression instanceof AST_RegExp);\n            });\n            def(AST_Conditional, function(compressor) {\n                return this.consequent.is_boolean(compressor) && this.alternative.is_boolean(compressor);\n            });\n            def(AST_New, return_false);\n            def(AST_Sequence, function(compressor) {\n                return this.tail_node().is_boolean(compressor);\n            });\n            def(AST_SymbolRef, function(compressor) {\n                var fixed = this.fixed_value();\n                if (!fixed) return false;\n                this.is_boolean = return_false;\n                var result = fixed.is_boolean(compressor);\n                delete this.is_boolean;\n                return result;\n            });\n            var unary = makePredicate(\"! delete\");\n            def(AST_UnaryPrefix, function() {\n                return unary[this.operator];\n            });\n        })(function(node, func) {\n            node.DEFMETHOD(\"is_boolean\", func);\n        });\n\n        // methods to determine if an expression has a numeric result type\n        (function(def) {\n            def(AST_Node, return_false);\n            var binary = makePredicate(\"- * / % ** & | ^ << >> >>>\");\n            def(AST_Assign, function(compressor) {\n                return binary[this.operator.slice(0, -1)]\n                    || this.operator == \"=\" && this.right.is_number(compressor);\n            });\n            def(AST_Binary, function(compressor) {\n                if (binary[this.operator]) return true;\n                if (this.operator != \"+\") return false;\n                return (this.left.is_boolean(compressor) || this.left.is_number(compressor))\n                    && (this.right.is_boolean(compressor) || this.right.is_number(compressor));\n            });\n            var fn = makePredicate([\n                \"charCodeAt\",\n                \"getDate\",\n                \"getDay\",\n                \"getFullYear\",\n                \"getHours\",\n                \"getMilliseconds\",\n                \"getMinutes\",\n                \"getMonth\",\n                \"getSeconds\",\n                \"getTime\",\n                \"getTimezoneOffset\",\n                \"getUTCDate\",\n                \"getUTCDay\",\n                \"getUTCFullYear\",\n                \"getUTCHours\",\n                \"getUTCMilliseconds\",\n                \"getUTCMinutes\",\n                \"getUTCMonth\",\n                \"getUTCSeconds\",\n                \"getYear\",\n                \"indexOf\",\n                \"lastIndexOf\",\n                \"localeCompare\",\n                \"push\",\n                \"search\",\n                \"setDate\",\n                \"setFullYear\",\n                \"setHours\",\n                \"setMilliseconds\",\n                \"setMinutes\",\n                \"setMonth\",\n                \"setSeconds\",\n                \"setTime\",\n                \"setUTCDate\",\n                \"setUTCFullYear\",\n                \"setUTCHours\",\n                \"setUTCMilliseconds\",\n                \"setUTCMinutes\",\n                \"setUTCMonth\",\n                \"setUTCSeconds\",\n                \"setYear\",\n            ]);\n            def(AST_Call, function(compressor) {\n                if (!compressor.option(\"unsafe\")) return false;\n                var exp = this.expression;\n                return exp instanceof AST_Dot && (fn[exp.property]\n                    || is_undeclared_ref(exp.expression) && exp.expression.name == \"Math\");\n            });\n            def(AST_Conditional, function(compressor) {\n                return this.consequent.is_number(compressor) && this.alternative.is_number(compressor);\n            });\n            def(AST_New, return_false);\n            def(AST_Number, return_true);\n            def(AST_Sequence, function(compressor) {\n                return this.tail_node().is_number(compressor);\n            });\n            def(AST_SymbolRef, function(compressor, keep_unary) {\n                var fixed = this.fixed_value();\n                if (!fixed) return false;\n                if (keep_unary\n                    && fixed instanceof AST_UnaryPrefix\n                    && fixed.operator == \"+\"\n                    && fixed.expression.equals(this)) {\n                    return false;\n                }\n                this.is_number = return_false;\n                var result = fixed.is_number(compressor);\n                delete this.is_number;\n                return result;\n            });\n            var unary = makePredicate(\"+ - ~ ++ --\");\n            def(AST_Unary, function() {\n                return unary[this.operator];\n            });\n        })(function(node, func) {\n            node.DEFMETHOD(\"is_number\", func);\n        });\n\n        // methods to determine if an expression has a string result type\n        (function(def) {\n            def(AST_Node, return_false);\n            def(AST_Assign, function(compressor) {\n                switch (this.operator) {\n                  case \"+=\":\n                    if (this.left.is_string(compressor)) return true;\n                  case \"=\":\n                    return this.right.is_string(compressor);\n                }\n            });\n            def(AST_Binary, function(compressor) {\n                return this.operator == \"+\" &&\n                    (this.left.is_string(compressor) || this.right.is_string(compressor));\n            });\n            var fn = makePredicate([\n                \"charAt\",\n                \"substr\",\n                \"substring\",\n                \"toExponential\",\n                \"toFixed\",\n                \"toLowerCase\",\n                \"toPrecision\",\n                \"toString\",\n                \"toUpperCase\",\n                \"trim\",\n            ]);\n            def(AST_Call, function(compressor) {\n                if (!compressor.option(\"unsafe\")) return false;\n                var exp = this.expression;\n                return exp instanceof AST_Dot && fn[exp.property];\n            });\n            def(AST_Conditional, function(compressor) {\n                return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);\n            });\n            def(AST_Sequence, function(compressor) {\n                return this.tail_node().is_string(compressor);\n            });\n            def(AST_String, return_true);\n            def(AST_SymbolRef, function(compressor) {\n                var fixed = this.fixed_value();\n                if (!fixed) return false;\n                this.is_string = return_false;\n                var result = fixed.is_string(compressor);\n                delete this.is_string;\n                return result;\n            });\n            def(AST_Template, function(compressor) {\n                return !this.tag || is_raw_tag(compressor, this.tag);\n            });\n            def(AST_UnaryPrefix, function() {\n                return this.operator == \"typeof\";\n            });\n        })(function(node, func) {\n            node.DEFMETHOD(\"is_string\", func);\n        });\n\n        var lazy_op = makePredicate(\"&& || ??\");\n\n        (function(def) {\n            function to_node(value, orig) {\n                if (value instanceof AST_Node) return value.clone(true);\n                if (Array.isArray(value)) return make_node(AST_Array, orig, {\n                    elements: value.map(function(value) {\n                        return to_node(value, orig);\n                    })\n                });\n                if (value && typeof value == \"object\") {\n                    var props = [];\n                    for (var key in value) if (HOP(value, key)) {\n                        props.push(make_node(AST_ObjectKeyVal, orig, {\n                            key: key,\n                            value: to_node(value[key], orig),\n                        }));\n                    }\n                    return make_node(AST_Object, orig, { properties: props });\n                }\n                return make_node_from_constant(value, orig);\n            }\n\n            function warn(node) {\n                AST_Node.warn(\"global_defs {this} redefined [{start}]\", node);\n            }\n\n            AST_Toplevel.DEFMETHOD(\"resolve_defines\", function(compressor) {\n                if (!compressor.option(\"global_defs\")) return this;\n                this.figure_out_scope({ ie: compressor.option(\"ie\") });\n                return this.transform(new TreeTransformer(function(node) {\n                    var def = node._find_defs(compressor, \"\");\n                    if (!def) return;\n                    var level = 0, child = node, parent;\n                    while (parent = this.parent(level++)) {\n                        if (!(parent instanceof AST_PropAccess)) break;\n                        if (parent.expression !== child) break;\n                        child = parent;\n                    }\n                    if (is_lhs(child, parent)) {\n                        warn(node);\n                        return;\n                    }\n                    return def;\n                }));\n            });\n            def(AST_Node, noop);\n            def(AST_Dot, function(compressor, suffix) {\n                return this.expression._find_defs(compressor, \".\" + this.property + suffix);\n            });\n            def(AST_SymbolDeclaration, function(compressor) {\n                if (!this.definition().global) return;\n                if (HOP(compressor.option(\"global_defs\"), this.name)) warn(this);\n            });\n            def(AST_SymbolRef, function(compressor, suffix) {\n                if (!this.definition().global) return;\n                var defines = compressor.option(\"global_defs\");\n                var name = this.name + suffix;\n                if (HOP(defines, name)) return to_node(defines[name], this);\n            });\n        })(function(node, func) {\n            node.DEFMETHOD(\"_find_defs\", func);\n        });\n\n        function best_of_expression(ast1, ast2, threshold) {\n            var delta = ast2.print_to_string().length - ast1.print_to_string().length;\n            return delta < (threshold || 0) ? ast2 : ast1;\n        }\n\n        function best_of_statement(ast1, ast2, threshold) {\n            return best_of_expression(make_node(AST_SimpleStatement, ast1, {\n                body: ast1,\n            }), make_node(AST_SimpleStatement, ast2, {\n                body: ast2,\n            }), threshold).body;\n        }\n\n        function best_of(compressor, ast1, ast2, threshold) {\n            return (first_in_statement(compressor) ? best_of_statement : best_of_expression)(ast1, ast2, threshold);\n        }\n\n        function convert_to_predicate(obj) {\n            var map = Object.create(null);\n            Object.keys(obj).forEach(function(key) {\n                map[key] = makePredicate(obj[key]);\n            });\n            return map;\n        }\n\n        function skip_directives(body) {\n            for (var i = 0; i < body.length; i++) {\n                var stat = body[i];\n                if (!(stat instanceof AST_Directive)) return stat;\n            }\n        }\n\n        function arrow_first_statement() {\n            if (this.value) return make_node(AST_Return, this.value, { value: this.value });\n            return skip_directives(this.body);\n        }\n        AST_Arrow.DEFMETHOD(\"first_statement\", arrow_first_statement);\n        AST_AsyncArrow.DEFMETHOD(\"first_statement\", arrow_first_statement);\n        AST_Lambda.DEFMETHOD(\"first_statement\", function() {\n            return skip_directives(this.body);\n        });\n\n        AST_Lambda.DEFMETHOD(\"length\", function() {\n            var argnames = this.argnames;\n            for (var i = 0; i < argnames.length; i++) {\n                if (argnames[i] instanceof AST_DefaultValue) break;\n            }\n            return i;\n        });\n\n        function try_evaluate(compressor, node) {\n            var ev = node.evaluate(compressor);\n            if (ev === node) return node;\n            ev = make_node_from_constant(ev, node).optimize(compressor);\n            return best_of(compressor, node, ev, compressor.eval_threshold);\n        }\n\n        var object_fns = [\n            \"constructor\",\n            \"toString\",\n            \"valueOf\",\n        ];\n        var native_fns = convert_to_predicate({\n            Array: [\n                \"indexOf\",\n                \"join\",\n                \"lastIndexOf\",\n                \"slice\",\n            ].concat(object_fns),\n            Boolean: object_fns,\n            Function: object_fns,\n            Number: [\n                \"toExponential\",\n                \"toFixed\",\n                \"toPrecision\",\n            ].concat(object_fns),\n            Object: object_fns,\n            RegExp: [\n                \"exec\",\n                \"test\",\n            ].concat(object_fns),\n            String: [\n                \"charAt\",\n                \"charCodeAt\",\n                \"concat\",\n                \"indexOf\",\n                \"italics\",\n                \"lastIndexOf\",\n                \"match\",\n                \"replace\",\n                \"search\",\n                \"slice\",\n                \"split\",\n                \"substr\",\n                \"substring\",\n                \"toLowerCase\",\n                \"toUpperCase\",\n                \"trim\",\n            ].concat(object_fns),\n        });\n        var static_fns = convert_to_predicate({\n            Array: [\n                \"isArray\",\n            ],\n            Math: [\n                \"abs\",\n                \"acos\",\n                \"asin\",\n                \"atan\",\n                \"ceil\",\n                \"cos\",\n                \"exp\",\n                \"floor\",\n                \"log\",\n                \"round\",\n                \"sin\",\n                \"sqrt\",\n                \"tan\",\n                \"atan2\",\n                \"pow\",\n                \"max\",\n                \"min\",\n            ],\n            Number: [\n                \"isFinite\",\n                \"isNaN\",\n            ],\n            Object: [\n                \"create\",\n                \"getOwnPropertyDescriptor\",\n                \"getOwnPropertyNames\",\n                \"getPrototypeOf\",\n                \"isExtensible\",\n                \"isFrozen\",\n                \"isSealed\",\n                \"keys\",\n            ],\n            String: [\n                \"fromCharCode\",\n                \"raw\",\n            ],\n        });\n\n        function is_static_fn(node) {\n            if (!(node instanceof AST_Dot)) return false;\n            var expr = node.expression;\n            if (!is_undeclared_ref(expr)) return false;\n            var static_fn = static_fns[expr.name];\n            return static_fn && (static_fn[node.property] || expr.name == \"Math\" && node.property == \"random\");\n        }\n\n        // Accommodate when compress option evaluate=false\n        // as well as the common constant expressions !0 and -1\n        (function(def) {\n            def(AST_Node, return_false);\n            def(AST_Constant, return_true);\n            def(AST_RegExp, return_false);\n            var unaryPrefix = makePredicate(\"! ~ - + void\");\n            def(AST_UnaryPrefix, function() {\n                return unaryPrefix[this.operator] && this.expression instanceof AST_Constant;\n            });\n        })(function(node, func) {\n            node.DEFMETHOD(\"is_constant\", func);\n        });\n\n        // methods to evaluate a constant expression\n        (function(def) {\n            // If the node has been successfully reduced to a constant,\n            // then its value is returned; otherwise the element itself\n            // is returned.\n            //\n            // They can be distinguished as constant value is never a\n            // descendant of AST_Node.\n            //\n            // When `ignore_side_effects` is `true`, inspect the constant value\n            // produced without worrying about any side effects caused by said\n            // expression.\n            AST_Node.DEFMETHOD(\"evaluate\", function(compressor, ignore_side_effects) {\n                if (!compressor.option(\"evaluate\")) return this;\n                var cached = [];\n                var val = this._eval(compressor, ignore_side_effects, cached, 1);\n                cached.forEach(function(node) {\n                    delete node._eval;\n                });\n                if (ignore_side_effects) return val;\n                if (!val || val instanceof RegExp) return val;\n                if (typeof val == \"function\" || typeof val == \"object\") return this;\n                return val;\n            });\n            var scan_modified = new TreeWalker(function(node) {\n                if (node instanceof AST_Assign) modified(node.left);\n                if (node instanceof AST_ForEnumeration) modified(node.init);\n                if (node instanceof AST_Unary && UNARY_POSTFIX[node.operator]) modified(node.expression);\n            });\n            function modified(node) {\n                if (node instanceof AST_DestructuredArray) {\n                    node.elements.forEach(modified);\n                } else if (node instanceof AST_DestructuredObject) {\n                    node.properties.forEach(function(prop) {\n                        modified(prop.value);\n                    });\n                } else if (node instanceof AST_PropAccess) {\n                    modified(node.expression);\n                } else if (node instanceof AST_SymbolRef) {\n                    node.definition().references.forEach(function(ref) {\n                        delete ref._eval;\n                    });\n                }\n            }\n            def(AST_Statement, function() {\n                throw new Error(string_template(\"Cannot evaluate a statement [{start}]\", this));\n            });\n            def(AST_Accessor, return_this);\n            def(AST_BigInt, return_this);\n            def(AST_Class, return_this);\n            def(AST_Node, return_this);\n            def(AST_Constant, function() {\n                return this.value;\n            });\n            def(AST_Assign, function(compressor, ignore_side_effects, cached, depth) {\n                var lhs = this.left;\n                if (!ignore_side_effects) {\n                    if (!(lhs instanceof AST_SymbolRef)) return this;\n                    if (!HOP(lhs, \"_eval\")) {\n                        if (!lhs.fixed) return this;\n                        var def = lhs.definition();\n                        if (!def.fixed) return this;\n                        if (def.undeclared) return this;\n                        if (def.last_ref !== lhs) return this;\n                        if (def.single_use == \"m\") return this;\n                        if (this.right.has_side_effects(compressor)) return this;\n                    }\n                }\n                var op = this.operator;\n                var node;\n                if (!HOP(lhs, \"_eval\") && lhs instanceof AST_SymbolRef && lhs.fixed && lhs.definition().fixed) {\n                    node = lhs;\n                } else if (op == \"=\") {\n                    node = this.right;\n                } else {\n                    node = make_node(AST_Binary, this, {\n                        operator: op.slice(0, -1),\n                        left: lhs,\n                        right: this.right,\n                    });\n                }\n                lhs.walk(scan_modified);\n                var value = node._eval(compressor, ignore_side_effects, cached, depth);\n                if (typeof value == \"object\") return this;\n                modified(lhs);\n                return value;\n            });\n            def(AST_Sequence, function(compressor, ignore_side_effects, cached, depth) {\n                if (!ignore_side_effects) return this;\n                var exprs = this.expressions;\n                for (var i = 0, last = exprs.length - 1; i < last; i++) {\n                    exprs[i].walk(scan_modified);\n                }\n                var tail = exprs[last];\n                var value = tail._eval(compressor, ignore_side_effects, cached, depth);\n                return value === tail ? this : value;\n            });\n            def(AST_Lambda, function(compressor) {\n                if (compressor.option(\"unsafe\")) {\n                    var fn = function() {};\n                    fn.node = this;\n                    fn.toString = function() {\n                        return \"function(){}\";\n                    };\n                    return fn;\n                }\n                return this;\n            });\n            def(AST_Array, function(compressor, ignore_side_effects, cached, depth) {\n                if (compressor.option(\"unsafe\")) {\n                    var elements = [];\n                    for (var i = 0; i < this.elements.length; i++) {\n                        var element = this.elements[i];\n                        if (element instanceof AST_Hole) return this;\n                        var value = element._eval(compressor, ignore_side_effects, cached, depth);\n                        if (element === value) return this;\n                        elements.push(value);\n                    }\n                    return elements;\n                }\n                return this;\n            });\n            def(AST_Object, function(compressor, ignore_side_effects, cached, depth) {\n                if (compressor.option(\"unsafe\")) {\n                    var val = {};\n                    for (var i = 0; i < this.properties.length; i++) {\n                        var prop = this.properties[i];\n                        if (!(prop instanceof AST_ObjectKeyVal)) return this;\n                        var key = prop.key;\n                        if (key instanceof AST_Node) {\n                            key = key._eval(compressor, ignore_side_effects, cached, depth);\n                            if (key === prop.key) return this;\n                        }\n                        switch (key) {\n                          case \"__proto__\":\n                          case \"toString\":\n                          case \"valueOf\":\n                            return this;\n                        }\n                        val[key] = prop.value._eval(compressor, ignore_side_effects, cached, depth);\n                        if (val[key] === prop.value) return this;\n                    }\n                    return val;\n                }\n                return this;\n            });\n            var non_converting_unary = makePredicate(\"! typeof void\");\n            def(AST_UnaryPrefix, function(compressor, ignore_side_effects, cached, depth) {\n                var e = this.expression;\n                var op = this.operator;\n                // Function would be evaluated to an array and so typeof would\n                // incorrectly return \"object\". Hence making is a special case.\n                if (compressor.option(\"typeofs\")\n                    && op == \"typeof\"\n                    && (e instanceof AST_Lambda\n                        || e instanceof AST_SymbolRef\n                            && e.fixed_value() instanceof AST_Lambda)) {\n                    return typeof function(){};\n                }\n                var def = e instanceof AST_SymbolRef && e.definition();\n                if (!non_converting_unary[op] && !(def && def.fixed)) depth++;\n                e.walk(scan_modified);\n                var v = e._eval(compressor, ignore_side_effects, cached, depth);\n                if (v === e) {\n                    if (ignore_side_effects && op == \"void\") return;\n                    return this;\n                }\n                switch (op) {\n                  case \"!\": return !v;\n                  case \"typeof\":\n                    // typeof <RegExp> returns \"object\" or \"function\" on different platforms\n                    // so cannot evaluate reliably\n                    if (v instanceof RegExp) return this;\n                    return typeof v;\n                  case \"void\": return;\n                  case \"~\": return ~v;\n                  case \"-\": return -v;\n                  case \"+\": return +v;\n                  case \"++\":\n                  case \"--\":\n                    if (!def) return this;\n                    if (!ignore_side_effects) {\n                        if (def.undeclared) return this;\n                        if (def.last_ref !== e) return this;\n                    }\n                    if (HOP(e, \"_eval\")) v = +(op[0] + 1) + +v;\n                    modified(e);\n                    return v;\n                }\n                return this;\n            });\n            def(AST_UnaryPostfix, function(compressor, ignore_side_effects, cached, depth) {\n                var e = this.expression;\n                if (!(e instanceof AST_SymbolRef)) {\n                    if (!ignore_side_effects) return this;\n                } else if (!HOP(e, \"_eval\")) {\n                    if (!e.fixed) return this;\n                    if (!ignore_side_effects) {\n                        var def = e.definition();\n                        if (!def.fixed) return this;\n                        if (def.undeclared) return this;\n                        if (def.last_ref !== e) return this;\n                    }\n                }\n                if (!(e instanceof AST_SymbolRef && e.definition().fixed)) depth++;\n                e.walk(scan_modified);\n                var v = e._eval(compressor, ignore_side_effects, cached, depth);\n                if (v === e) return this;\n                modified(e);\n                return +v;\n            });\n            var non_converting_binary = makePredicate(\"&& || === !==\");\n            def(AST_Binary, function(compressor, ignore_side_effects, cached, depth) {\n                if (!non_converting_binary[this.operator]) depth++;\n                var left = this.left._eval(compressor, ignore_side_effects, cached, depth);\n                if (left === this.left) return this;\n                if (this.operator == (left ? \"||\" : \"&&\")) return left;\n                var rhs_ignore_side_effects = ignore_side_effects && !(left && typeof left == \"object\");\n                var right = this.right._eval(compressor, rhs_ignore_side_effects, cached, depth);\n                if (right === this.right) return this;\n                var result;\n                switch (this.operator) {\n                  case \"&&\" : result = left &&  right; break;\n                  case \"||\" : result = left ||  right; break;\n                  case \"??\" :\n                    result = left == null ? right : left;\n                    break;\n                  case \"|\"  : result = left |   right; break;\n                  case \"&\"  : result = left &   right; break;\n                  case \"^\"  : result = left ^   right; break;\n                  case \"+\"  : result = left +   right; break;\n                  case \"-\"  : result = left -   right; break;\n                  case \"*\"  : result = left *   right; break;\n                  case \"/\"  : result = left /   right; break;\n                  case \"%\"  : result = left %   right; break;\n                  case \"<<\" : result = left <<  right; break;\n                  case \">>\" : result = left >>  right; break;\n                  case \">>>\": result = left >>> right; break;\n                  case \"==\" : result = left ==  right; break;\n                  case \"===\": result = left === right; break;\n                  case \"!=\" : result = left !=  right; break;\n                  case \"!==\": result = left !== right; break;\n                  case \"<\"  : result = left <   right; break;\n                  case \"<=\" : result = left <=  right; break;\n                  case \">\"  : result = left >   right; break;\n                  case \">=\" : result = left >=  right; break;\n                  case \"**\":\n                    result = Math.pow(left, right);\n                    break;\n                  case \"in\":\n                    if (right && typeof right == \"object\" && HOP(right, left)) {\n                        result = true;\n                        break;\n                    }\n                  default:\n                    return this;\n                }\n                if (isNaN(result)) return compressor.find_parent(AST_With) ? this : result;\n                if (compressor.option(\"unsafe_math\")\n                    && !ignore_side_effects\n                    && result\n                    && typeof result == \"number\"\n                    && (this.operator == \"+\" || this.operator == \"-\")) {\n                    var digits = Math.max(0, decimals(left), decimals(right));\n                    // 53-bit significand ---> 15.95 decimal places\n                    if (digits < 16) return +result.toFixed(digits);\n                }\n                return result;\n\n                function decimals(operand) {\n                    var match = /(\\.[0-9]*)?(e[^e]+)?$/.exec(+operand);\n                    return (match[1] || \".\").length - 1 - (match[2] || \"\").slice(1);\n                }\n            });\n            def(AST_Conditional, function(compressor, ignore_side_effects, cached, depth) {\n                var condition = this.condition._eval(compressor, ignore_side_effects, cached, depth);\n                if (condition === this.condition) return this;\n                var node = condition ? this.consequent : this.alternative;\n                var value = node._eval(compressor, ignore_side_effects, cached, depth);\n                return value === node ? this : value;\n            });\n            function verify_escaped(ref, depth) {\n                var escaped = ref.definition().escaped;\n                switch (escaped.length) {\n                  case 0:\n                    return true;\n                  case 1:\n                    var found = false;\n                    escaped[0].walk(new TreeWalker(function(node) {\n                        if (found) return true;\n                        if (node === ref) return found = true;\n                        if (node instanceof AST_Scope) return true;\n                    }));\n                    return found;\n                  default:\n                    return depth <= escaped.depth;\n                }\n            }\n            def(AST_SymbolRef, function(compressor, ignore_side_effects, cached, depth) {\n                var fixed = this.fixed_value();\n                if (!fixed) return this;\n                var value;\n                if (HOP(fixed, \"_eval\")) {\n                    value = fixed._eval();\n                } else {\n                    this._eval = return_this;\n                    value = fixed._eval(compressor, ignore_side_effects, cached, depth);\n                    delete this._eval;\n                    if (value === fixed) return this;\n                    fixed._eval = function() {\n                        return value;\n                    };\n                    cached.push(fixed);\n                }\n                return value && typeof value == \"object\" && !verify_escaped(this, depth) ? this : value;\n            });\n            var global_objs = {\n                Array: Array,\n                Math: Math,\n                Number: Number,\n                Object: Object,\n                String: String,\n            };\n            var static_values = convert_to_predicate({\n                Math: [\n                    \"E\",\n                    \"LN10\",\n                    \"LN2\",\n                    \"LOG2E\",\n                    \"LOG10E\",\n                    \"PI\",\n                    \"SQRT1_2\",\n                    \"SQRT2\",\n                ],\n                Number: [\n                    \"MAX_VALUE\",\n                    \"MIN_VALUE\",\n                    \"NaN\",\n                    \"NEGATIVE_INFINITY\",\n                    \"POSITIVE_INFINITY\",\n                ],\n            });\n            var regexp_props = makePredicate(\"global ignoreCase multiline source\");\n            def(AST_PropAccess, function(compressor, ignore_side_effects, cached, depth) {\n                if (compressor.option(\"unsafe\")) {\n                    var val;\n                    var exp = this.expression;\n                    if (!is_undeclared_ref(exp)) {\n                        val = exp._eval(compressor, ignore_side_effects, cached, depth + 1);\n                        if (val == null || val === exp) return this;\n                    }\n                    var key = this.property;\n                    if (key instanceof AST_Node) {\n                        key = key._eval(compressor, ignore_side_effects, cached, depth);\n                        if (key === this.property) return this;\n                    }\n                    if (val === undefined) {\n                        var static_value = static_values[exp.name];\n                        if (!static_value || !static_value[key]) return this;\n                        val = global_objs[exp.name];\n                    } else if (val instanceof RegExp) {\n                        if (!regexp_props[key]) return this;\n                    } else if (typeof val == \"object\") {\n                        if (!HOP(val, key)) return this;\n                    } else if (typeof val == \"function\") switch (key) {\n                      case \"name\":\n                        return val.node.name ? val.node.name.name : \"\";\n                      case \"length\":\n                        return val.node.length();\n                      default:\n                        return this;\n                    }\n                    return val[key];\n                }\n                return this;\n            });\n            function eval_all(nodes, compressor, ignore_side_effects, cached, depth) {\n                var values = [];\n                for (var i = 0; i < nodes.length; i++) {\n                    var node = nodes[i];\n                    var value = node._eval(compressor, ignore_side_effects, cached, depth);\n                    if (node === value) return;\n                    values.push(value);\n                }\n                return values;\n            }\n            def(AST_Call, function(compressor, ignore_side_effects, cached, depth) {\n                var exp = this.expression;\n                var fn = exp instanceof AST_SymbolRef ? exp.fixed_value() : exp;\n                if (fn instanceof AST_Arrow || fn instanceof AST_Defun || fn instanceof AST_Function) {\n                    if (fn.evaluating) return this;\n                    if (fn.name && fn.name.definition().recursive_refs > 0) return this;\n                    if (this.is_expr_pure(compressor)) return this;\n                    var args = eval_all(this.args, compressor, ignore_side_effects, cached, depth);\n                    if (!all(fn.argnames, function(sym, index) {\n                        if (sym instanceof AST_DefaultValue) {\n                            if (!args) return false;\n                            if (args[index] === undefined) {\n                                var value = sym.value._eval(compressor, ignore_side_effects, cached, depth);\n                                if (value === sym.value) return false;\n                                args[index] = value;\n                            }\n                            sym = sym.name;\n                        }\n                        return !(sym instanceof AST_Destructured);\n                    })) return this;\n                    if (fn.rest instanceof AST_Destructured) return this;\n                    if (!args && !ignore_side_effects) return this;\n                    var stat = fn.first_statement();\n                    if (!(stat instanceof AST_Return)) {\n                        if (ignore_side_effects) {\n                            fn.walk(scan_modified);\n                            var found = false;\n                            fn.evaluating = true;\n                            walk_body(fn, new TreeWalker(function(node) {\n                                if (found) return true;\n                                if (node instanceof AST_Return) {\n                                    if (node.value && node.value._eval(compressor, true, cached, depth) !== undefined) {\n                                        found = true;\n                                    }\n                                    return true;\n                                }\n                                if (node instanceof AST_Scope && node !== fn) return true;\n                            }));\n                            fn.evaluating = false;\n                            if (!found) return;\n                        }\n                        return this;\n                    }\n                    var val = stat.value;\n                    if (!val) return;\n                    var cached_args = [];\n                    if (!args || all(fn.argnames, function(sym, i) {\n                        return assign(sym, args[i]);\n                    }) && !(fn.rest && !assign(fn.rest, args.slice(fn.argnames.length))) || ignore_side_effects) {\n                        if (ignore_side_effects) fn.argnames.forEach(function(sym) {\n                            if (sym instanceof AST_DefaultValue) sym.value.walk(scan_modified);\n                        });\n                        fn.evaluating = true;\n                        val = val._eval(compressor, ignore_side_effects, cached, depth);\n                        fn.evaluating = false;\n                    }\n                    cached_args.forEach(function(node) {\n                        delete node._eval;\n                    });\n                    return val === stat.value ? this : val;\n                } else if (compressor.option(\"unsafe\") && exp instanceof AST_PropAccess) {\n                    var key = exp.property;\n                    if (key instanceof AST_Node) {\n                        key = key._eval(compressor, ignore_side_effects, cached, depth);\n                        if (key === exp.property) return this;\n                    }\n                    var val;\n                    var e = exp.expression;\n                    if (is_undeclared_ref(e)) {\n                        var static_fn = static_fns[e.name];\n                        if (!static_fn || !static_fn[key]) return this;\n                        val = global_objs[e.name];\n                    } else {\n                        val = e._eval(compressor, ignore_side_effects, cached, depth + 1);\n                        if (val == null || val === e) return this;\n                        var native_fn = native_fns[val.constructor.name];\n                        if (!native_fn || !native_fn[key]) return this;\n                        if (val instanceof RegExp && val.global && !(e instanceof AST_RegExp)) return this;\n                    }\n                    var args = eval_all(this.args, compressor, ignore_side_effects, cached, depth);\n                    if (!args) return this;\n                    if (key == \"replace\" && typeof args[1] == \"function\") return this;\n                    try {\n                        return val[key].apply(val, args);\n                    } catch (ex) {\n                        AST_Node.warn(\"Error evaluating {this} [{start}]\", this);\n                    } finally {\n                        if (val instanceof RegExp) val.lastIndex = 0;\n                    }\n                }\n                return this;\n\n                function assign(sym, arg) {\n                    if (sym instanceof AST_DefaultValue) sym = sym.name;\n                    var def = sym.definition();\n                    if (def.orig[def.orig.length - 1] !== sym) return false;\n                    var value = arg;\n                    def.references.forEach(function(node) {\n                        node._eval = function() {\n                            return value;\n                        };\n                        cached_args.push(node);\n                    });\n                    return true;\n                }\n            });\n            def(AST_New, return_this);\n            def(AST_Template, function(compressor, ignore_side_effects, cached, depth) {\n                if (!compressor.option(\"templates\")) return this;\n                if (this.tag) {\n                    if (!is_raw_tag(compressor, this.tag)) return this;\n                    decode = function(str) {\n                        return str;\n                    };\n                }\n                var exprs = eval_all(this.expressions, compressor, ignore_side_effects, cached, depth);\n                if (!exprs) return this;\n                var malformed = false;\n                var ret = decode(this.strings[0]);\n                for (var i = 0; i < exprs.length; i++) {\n                    ret += exprs[i] + decode(this.strings[i + 1]);\n                }\n                if (!malformed) return ret;\n                this._eval = return_this;\n                return this;\n\n                function decode(str) {\n                    str = decode_template(str);\n                    if (typeof str != \"string\") malformed = true;\n                    return str;\n                }\n            });\n        })(function(node, func) {\n            node.DEFMETHOD(\"_eval\", func);\n        });\n\n        // method to negate an expression\n        (function(def) {\n            function basic_negation(exp) {\n                return make_node(AST_UnaryPrefix, exp, {\n                    operator: \"!\",\n                    expression: exp,\n                });\n            }\n            function best(orig, alt, first_in_statement) {\n                var negated = basic_negation(orig);\n                if (first_in_statement) return best_of_expression(negated, make_node(AST_SimpleStatement, alt, {\n                    body: alt,\n                })) === negated ? negated : alt;\n                return best_of_expression(negated, alt);\n            }\n            def(AST_Node, function() {\n                return basic_negation(this);\n            });\n            def(AST_Statement, function() {\n                throw new Error(\"Cannot negate a statement\");\n            });\n            def(AST_Binary, function(compressor, first_in_statement) {\n                var self = this.clone(), op = this.operator;\n                if (compressor.option(\"unsafe_comps\")) {\n                    switch (op) {\n                      case \"<=\" : self.operator = \">\"  ; return self;\n                      case \"<\"  : self.operator = \">=\" ; return self;\n                      case \">=\" : self.operator = \"<\"  ; return self;\n                      case \">\"  : self.operator = \"<=\" ; return self;\n                    }\n                }\n                switch (op) {\n                  case \"==\" : self.operator = \"!=\"; return self;\n                  case \"!=\" : self.operator = \"==\"; return self;\n                  case \"===\": self.operator = \"!==\"; return self;\n                  case \"!==\": self.operator = \"===\"; return self;\n                  case \"&&\":\n                    self.operator = \"||\";\n                    self.left = self.left.negate(compressor, first_in_statement);\n                    self.right = self.right.negate(compressor);\n                    return best(this, self, first_in_statement);\n                  case \"||\":\n                    self.operator = \"&&\";\n                    self.left = self.left.negate(compressor, first_in_statement);\n                    self.right = self.right.negate(compressor);\n                    return best(this, self, first_in_statement);\n                }\n                return basic_negation(this);\n            });\n            def(AST_ClassExpression, function() {\n                return basic_negation(this);\n            });\n            def(AST_Conditional, function(compressor, first_in_statement) {\n                var self = this.clone();\n                self.consequent = self.consequent.negate(compressor);\n                self.alternative = self.alternative.negate(compressor);\n                return best(this, self, first_in_statement);\n            });\n            def(AST_LambdaExpression, function() {\n                return basic_negation(this);\n            });\n            def(AST_Sequence, function(compressor) {\n                var expressions = this.expressions.slice();\n                expressions.push(expressions.pop().negate(compressor));\n                return make_sequence(this, expressions);\n            });\n            def(AST_UnaryPrefix, function() {\n                if (this.operator == \"!\")\n                    return this.expression;\n                return basic_negation(this);\n            });\n        })(function(node, func) {\n            node.DEFMETHOD(\"negate\", function(compressor, first_in_statement) {\n                return func.call(this, compressor, first_in_statement);\n            });\n        });\n\n        var global_pure_fns = makePredicate(\"Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parseFloat parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError\");\n        var global_pure_constructors = makePredicate(\"Map Set WeakMap WeakSet\");\n        AST_Call.DEFMETHOD(\"is_expr_pure\", function(compressor) {\n            if (compressor.option(\"unsafe\")) {\n                var expr = this.expression;\n                if (is_undeclared_ref(expr)) {\n                    if (global_pure_fns[expr.name]) return true;\n                    if (this instanceof AST_New && global_pure_constructors[expr.name]) return true;\n                }\n                if (is_static_fn(expr)) return true;\n            }\n            return compressor.option(\"annotations\") && this.pure || !compressor.pure_funcs(this);\n        });\n        AST_Template.DEFMETHOD(\"is_expr_pure\", function(compressor) {\n            var tag = this.tag;\n            if (!tag) return true;\n            if (compressor.option(\"unsafe\")) {\n                if (is_undeclared_ref(tag) && global_pure_fns[tag.name]) return true;\n                if (tag instanceof AST_Dot && is_undeclared_ref(tag.expression)) {\n                    var static_fn = static_fns[tag.expression.name];\n                    return static_fn && (static_fn[tag.property]\n                        || tag.expression.name == \"Math\" && tag.property == \"random\");\n                }\n            }\n            return !compressor.pure_funcs(this);\n        });\n        AST_Node.DEFMETHOD(\"is_call_pure\", return_false);\n        AST_Call.DEFMETHOD(\"is_call_pure\", function(compressor) {\n            if (!compressor.option(\"unsafe\")) return false;\n            var dot = this.expression;\n            if (!(dot instanceof AST_Dot)) return false;\n            var exp = dot.expression;\n            var map;\n            var prop = dot.property;\n            if (exp instanceof AST_Array) {\n                map = native_fns.Array;\n            } else if (exp.is_boolean(compressor)) {\n                map = native_fns.Boolean;\n            } else if (exp.is_number(compressor)) {\n                map = native_fns.Number;\n            } else if (exp instanceof AST_RegExp) {\n                map = native_fns.RegExp;\n            } else if (exp.is_string(compressor)) {\n                map = native_fns.String;\n                if (prop == \"replace\") {\n                    var arg = this.args[1];\n                    if (arg && !arg.is_string(compressor)) return false;\n                }\n            } else if (!dot.may_throw_on_access(compressor)) {\n                map = native_fns.Object;\n            }\n            return map && map[prop];\n        });\n\n        // determine if object spread syntax may cause runtime exception\n        (function(def) {\n            def(AST_Node, return_false);\n            def(AST_Array, return_true);\n            def(AST_Assign, function() {\n                switch (this.operator) {\n                  case \"=\":\n                    return this.right.safe_to_spread();\n                  case \"&&=\":\n                  case \"||=\":\n                  case \"??=\":\n                    return this.left.safe_to_spread() && this.right.safe_to_spread();\n                }\n                return true;\n            });\n            def(AST_Binary, function() {\n                return !lazy_op[this.operator] || this.left.safe_to_spread() && this.right.safe_to_spread();\n            });\n            def(AST_Constant, return_true);\n            def(AST_Lambda, return_true);\n            def(AST_Object, function() {\n                return all(this.properties, function(prop) {\n                    return !(prop instanceof AST_ObjectGetter || prop instanceof AST_Spread);\n                });\n            });\n            def(AST_Sequence, function() {\n                return this.tail_node().safe_to_spread();\n            });\n            def(AST_SymbolRef, function() {\n                var fixed = this.fixed_value();\n                return fixed && fixed.safe_to_spread();\n            });\n            def(AST_Unary, return_true);\n        })(function(node, func) {\n            node.DEFMETHOD(\"safe_to_spread\", func);\n        });\n\n        // determine if expression has side effects\n        (function(def) {\n            function any(list, compressor, spread) {\n                return !all(list, spread ? function(node) {\n                    return node instanceof AST_Spread ? !spread(node, compressor) : !node.has_side_effects(compressor);\n                } : function(node) {\n                    return !node.has_side_effects(compressor);\n                });\n            }\n            function array_spread(node, compressor) {\n                var exp = node.expression;\n                return !exp.is_string(compressor) || exp.has_side_effects(compressor);\n            }\n            def(AST_Node, return_true);\n            def(AST_Array, function(compressor) {\n                return any(this.elements, compressor, array_spread);\n            });\n            def(AST_Assign, function(compressor) {\n                var lhs = this.left;\n                if (!(lhs instanceof AST_PropAccess)) return true;\n                var node = lhs.expression;\n                return !(node instanceof AST_ObjectIdentity)\n                    || !node.scope.resolve().new\n                    || lhs instanceof AST_Sub && lhs.property.has_side_effects(compressor)\n                    || this.right.has_side_effects(compressor);\n            });\n            def(AST_Binary, function(compressor) {\n                return this.left.has_side_effects(compressor)\n                    || this.right.has_side_effects(compressor)\n                    || !can_drop_op(this.operator, this.right, compressor);\n            });\n            def(AST_Block, function(compressor) {\n                return any(this.body, compressor);\n            });\n            def(AST_Call, function(compressor) {\n                if (!this.is_expr_pure(compressor)\n                    && (!this.is_call_pure(compressor) || this.expression.has_side_effects(compressor))) {\n                    return true;\n                }\n                return any(this.args, compressor, array_spread);\n            });\n            def(AST_Case, function(compressor) {\n                return this.expression.has_side_effects(compressor)\n                    || any(this.body, compressor);\n            });\n            def(AST_Class, function(compressor) {\n                var base = this.extends;\n                if (base) {\n                    if (base instanceof AST_SymbolRef) base = base.fixed_value();\n                    if (!safe_for_extends(base)) return true;\n                }\n                return any(this.properties, compressor);\n            });\n            def(AST_ClassProperty, function(compressor) {\n                return this.key instanceof AST_Node && this.key.has_side_effects(compressor)\n                    || this.static && this.value && this.value.has_side_effects(compressor);\n            });\n            def(AST_Conditional, function(compressor) {\n                return this.condition.has_side_effects(compressor)\n                    || this.consequent.has_side_effects(compressor)\n                    || this.alternative.has_side_effects(compressor);\n            });\n            def(AST_Constant, return_false);\n            def(AST_Definitions, function(compressor) {\n                return any(this.definitions, compressor);\n            });\n            def(AST_DestructuredArray, function(compressor) {\n                return any(this.elements, compressor);\n            });\n            def(AST_DestructuredKeyVal, function(compressor) {\n                return this.key instanceof AST_Node && this.key.has_side_effects(compressor)\n                    || this.value.has_side_effects(compressor);\n            });\n            def(AST_DestructuredObject, function(compressor) {\n                return any(this.properties, compressor);\n            });\n            def(AST_Dot, function(compressor) {\n                return this.expression.may_throw_on_access(compressor)\n                    || this.expression.has_side_effects(compressor);\n            });\n            def(AST_EmptyStatement, return_false);\n            def(AST_If, function(compressor) {\n                return this.condition.has_side_effects(compressor)\n                    || this.body && this.body.has_side_effects(compressor)\n                    || this.alternative && this.alternative.has_side_effects(compressor);\n            });\n            def(AST_LabeledStatement, function(compressor) {\n                return this.body.has_side_effects(compressor);\n            });\n            def(AST_Lambda, return_false);\n            def(AST_Object, function(compressor) {\n                return any(this.properties, compressor, function(node, compressor) {\n                    var exp = node.expression;\n                    return !exp.safe_to_spread() || exp.has_side_effects(compressor);\n                });\n            });\n            def(AST_ObjectIdentity, return_false);\n            def(AST_ObjectProperty, function(compressor) {\n                return this.key instanceof AST_Node && this.key.has_side_effects(compressor)\n                    || this.value.has_side_effects(compressor);\n            });\n            def(AST_Sequence, function(compressor) {\n                return any(this.expressions, compressor);\n            });\n            def(AST_SimpleStatement, function(compressor) {\n                return this.body.has_side_effects(compressor);\n            });\n            def(AST_Sub, function(compressor) {\n                return this.expression.may_throw_on_access(compressor)\n                    || this.expression.has_side_effects(compressor)\n                    || this.property.has_side_effects(compressor);\n            });\n            def(AST_Switch, function(compressor) {\n                return this.expression.has_side_effects(compressor)\n                    || any(this.body, compressor);\n            });\n            def(AST_SymbolDeclaration, return_false);\n            def(AST_SymbolRef, function(compressor) {\n                return !this.is_declared(compressor) || !can_drop_symbol(this, compressor);\n            });\n            def(AST_Template, function(compressor) {\n                return !this.is_expr_pure(compressor) || any(this.expressions, compressor);\n            });\n            def(AST_Try, function(compressor) {\n                return any(this.body, compressor)\n                    || this.bcatch && this.bcatch.has_side_effects(compressor)\n                    || this.bfinally && this.bfinally.has_side_effects(compressor);\n            });\n            def(AST_Unary, function(compressor) {\n                return unary_side_effects[this.operator]\n                    || this.expression.has_side_effects(compressor);\n            });\n            def(AST_VarDef, function() {\n                return this.value;\n            });\n        })(function(node, func) {\n            node.DEFMETHOD(\"has_side_effects\", func);\n        });\n\n        // determine if expression may throw\n        (function(def) {\n            def(AST_Node, return_true);\n\n            def(AST_Constant, return_false);\n            def(AST_EmptyStatement, return_false);\n            def(AST_Lambda, return_false);\n            def(AST_ObjectIdentity, return_false);\n            def(AST_SymbolDeclaration, return_false);\n\n            function any(list, compressor) {\n                for (var i = list.length; --i >= 0;)\n                    if (list[i].may_throw(compressor))\n                        return true;\n                return false;\n            }\n\n            function call_may_throw(exp, compressor) {\n                if (exp.may_throw(compressor)) return true;\n                if (exp instanceof AST_SymbolRef) exp = exp.fixed_value();\n                if (!(exp instanceof AST_Lambda)) return true;\n                if (any(exp.argnames, compressor)) return true;\n                if (any(exp.body, compressor)) return true;\n                return is_arrow(exp) && exp.value && exp.value.may_throw(compressor);\n            }\n\n            def(AST_Array, function(compressor) {\n                return any(this.elements, compressor);\n            });\n            def(AST_Assign, function(compressor) {\n                if (this.right.may_throw(compressor)) return true;\n                if (!compressor.has_directive(\"use strict\")\n                    && this.operator == \"=\"\n                    && this.left instanceof AST_SymbolRef) {\n                    return false;\n                }\n                return this.left.may_throw(compressor);\n            });\n            def(AST_Await, function(compressor) {\n                return this.expression.may_throw(compressor);\n            });\n            def(AST_Binary, function(compressor) {\n                return this.left.may_throw(compressor)\n                    || this.right.may_throw(compressor)\n                    || !can_drop_op(this.operator, this.right, compressor);\n            });\n            def(AST_Block, function(compressor) {\n                return any(this.body, compressor);\n            });\n            def(AST_Call, function(compressor) {\n                if (any(this.args, compressor)) return true;\n                if (this.is_expr_pure(compressor)) return false;\n                this.may_throw = return_true;\n                var ret = call_may_throw(this.expression, compressor);\n                delete this.may_throw;\n                return ret;\n            });\n            def(AST_Case, function(compressor) {\n                return this.expression.may_throw(compressor)\n                    || any(this.body, compressor);\n            });\n            def(AST_Conditional, function(compressor) {\n                return this.condition.may_throw(compressor)\n                    || this.consequent.may_throw(compressor)\n                    || this.alternative.may_throw(compressor);\n            });\n            def(AST_DefaultValue, function(compressor) {\n                return this.name.may_throw(compressor)\n                    || this.value && this.value.may_throw(compressor);\n            });\n            def(AST_Definitions, function(compressor) {\n                return any(this.definitions, compressor);\n            });\n            def(AST_Dot, function(compressor) {\n                return !this.optional && this.expression.may_throw_on_access(compressor)\n                    || this.expression.may_throw(compressor);\n            });\n            def(AST_ForEnumeration, function(compressor) {\n                if (this.init.may_throw(compressor)) return true;\n                var obj = this.object;\n                if (obj.may_throw(compressor)) return true;\n                obj = obj.tail_node();\n                if (!(obj instanceof AST_Array || obj.is_string(compressor))) return true;\n                return this.body.may_throw(compressor);\n            });\n            def(AST_If, function(compressor) {\n                return this.condition.may_throw(compressor)\n                    || this.body && this.body.may_throw(compressor)\n                    || this.alternative && this.alternative.may_throw(compressor);\n            });\n            def(AST_LabeledStatement, function(compressor) {\n                return this.body.may_throw(compressor);\n            });\n            def(AST_Object, function(compressor) {\n                return any(this.properties, compressor);\n            });\n            def(AST_ObjectProperty, function(compressor) {\n                return this.value.may_throw(compressor)\n                    || this.key instanceof AST_Node && this.key.may_throw(compressor);\n            });\n            def(AST_Return, function(compressor) {\n                return this.value && this.value.may_throw(compressor);\n            });\n            def(AST_Sequence, function(compressor) {\n                return any(this.expressions, compressor);\n            });\n            def(AST_SimpleStatement, function(compressor) {\n                return this.body.may_throw(compressor);\n            });\n            def(AST_Sub, function(compressor) {\n                return !this.optional && this.expression.may_throw_on_access(compressor)\n                    || this.expression.may_throw(compressor)\n                    || this.property.may_throw(compressor);\n            });\n            def(AST_Switch, function(compressor) {\n                return this.expression.may_throw(compressor)\n                    || any(this.body, compressor);\n            });\n            def(AST_SymbolRef, function(compressor) {\n                return !this.is_declared(compressor) || !can_drop_symbol(this, compressor);\n            });\n            def(AST_Template, function(compressor) {\n                if (any(this.expressions, compressor)) return true;\n                if (this.is_expr_pure(compressor)) return false;\n                if (!this.tag) return false;\n                this.may_throw = return_true;\n                var ret = call_may_throw(this.tag, compressor);\n                delete this.may_throw;\n                return ret;\n            });\n            def(AST_Try, function(compressor) {\n                return (this.bcatch ? this.bcatch.may_throw(compressor) : any(this.body, compressor))\n                    || this.bfinally && this.bfinally.may_throw(compressor);\n            });\n            def(AST_Unary, function(compressor) {\n                return this.expression.may_throw(compressor)\n                    && !(this.operator == \"typeof\" && this.expression instanceof AST_SymbolRef);\n            });\n            def(AST_VarDef, function(compressor) {\n                return this.name.may_throw(compressor)\n                    || this.value && this.value.may_throw(compressor);\n            });\n        })(function(node, func) {\n            node.DEFMETHOD(\"may_throw\", func);\n        });\n\n        // determine if expression is constant\n        (function(def) {\n            function all_constant(list, scope) {\n                for (var i = list.length; --i >= 0;)\n                    if (!list[i].is_constant_expression(scope))\n                        return false;\n                return true;\n            }\n            def(AST_Node, return_false);\n            def(AST_Array, function(scope) {\n                return all_constant(this.elements, scope);\n            });\n            def(AST_Binary, function(scope) {\n                return this.left.is_constant_expression(scope)\n                    && this.right.is_constant_expression(scope)\n                    && can_drop_op(this.operator, this.right);\n            });\n            def(AST_Class, function(scope) {\n                var base = this.extends;\n                if (base && !safe_for_extends(base)) return false;\n                return all_constant(this.properties, scope);\n            });\n            def(AST_ClassProperty, function(scope) {\n                return typeof this.key == \"string\" && (!this.value || this.value.is_constant_expression(scope));\n            });\n            def(AST_Constant, return_true);\n            def(AST_Lambda, function(scope) {\n                var self = this;\n                var result = true;\n                var scopes = [];\n                self.walk(new TreeWalker(function(node, descend) {\n                    if (!result) return true;\n                    if (node instanceof AST_BlockScope) {\n                        if (node === self) return;\n                        scopes.push(node);\n                        descend();\n                        scopes.pop();\n                        return true;\n                    }\n                    if (node instanceof AST_SymbolRef) {\n                        if (self.inlined || node.redef || node.in_arg) {\n                            result = false;\n                            return true;\n                        }\n                        if (self.variables.has(node.name)) return true;\n                        var def = node.definition();\n                        if (member(def.scope, scopes)) return true;\n                        if (scope && !def.redefined()) {\n                            var scope_def = scope.find_variable(node.name);\n                            if (scope_def ? scope_def === def : def.undeclared) {\n                                result = \"f\";\n                                return true;\n                            }\n                        }\n                        result = false;\n                        return true;\n                    }\n                    if (node instanceof AST_ObjectIdentity) {\n                        if (is_arrow(self) && all(scopes, function(s) {\n                            return !(s instanceof AST_Scope) || is_arrow(s);\n                        })) result = false;\n                        return true;\n                    }\n                }));\n                return result;\n            });\n            def(AST_Object, function(scope) {\n                return all_constant(this.properties, scope);\n            });\n            def(AST_ObjectProperty, function(scope) {\n                return typeof this.key == \"string\" && this.value.is_constant_expression(scope);\n            });\n            def(AST_Unary, function(scope) {\n                return this.expression.is_constant_expression(scope);\n            });\n        })(function(node, func) {\n            node.DEFMETHOD(\"is_constant_expression\", func);\n        });\n\n        // tell me if a statement aborts\n        function aborts(thing) {\n            return thing && thing.aborts();\n        }\n        (function(def) {\n            def(AST_Statement, return_null);\n            def(AST_Jump, return_this);\n            function block_aborts() {\n                var n = this.body.length;\n                return n > 0 && aborts(this.body[n - 1]);\n            }\n            def(AST_BlockStatement, block_aborts);\n            def(AST_SwitchBranch, block_aborts);\n            def(AST_If, function() {\n                return this.alternative && aborts(this.body) && aborts(this.alternative) && this;\n            });\n        })(function(node, func) {\n            node.DEFMETHOD(\"aborts\", func);\n        });\n\n        /* -----[ optimizers ]----- */\n\n        var directives = makePredicate([\"use asm\", \"use strict\"]);\n        OPT(AST_Directive, function(self, compressor) {\n            if (compressor.option(\"directives\")\n                && (!directives[self.value] || compressor.has_directive(self.value) !== self)) {\n                return make_node(AST_EmptyStatement, self);\n            }\n            return self;\n        });\n\n        OPT(AST_Debugger, function(self, compressor) {\n            if (compressor.option(\"drop_debugger\"))\n                return make_node(AST_EmptyStatement, self);\n            return self;\n        });\n\n        OPT(AST_LabeledStatement, function(self, compressor) {\n            if (self.body instanceof AST_If || self.body instanceof AST_Break) {\n                var body = tighten_body([ self.body ], compressor);\n                switch (body.length) {\n                  case 0:\n                    self.body = make_node(AST_EmptyStatement, self);\n                    break;\n                  case 1:\n                    self.body = body[0];\n                    break;\n                  default:\n                    self.body = make_node(AST_BlockStatement, self, { body: body });\n                    break;\n                }\n            }\n            return compressor.option(\"unused\") && self.label.references.length == 0 ? self.body : self;\n        });\n\n        OPT(AST_LoopControl, function(self, compressor) {\n            if (!compressor.option(\"dead_code\")) return self;\n            var label = self.label;\n            if (label) {\n                var lct = compressor.loopcontrol_target(self);\n                self.label = null;\n                if (compressor.loopcontrol_target(self) === lct) {\n                    remove(label.thedef.references, self);\n                } else {\n                    self.label = label;\n                }\n            }\n            return self;\n        });\n\n        OPT(AST_Block, function(self, compressor) {\n            self.body = tighten_body(self.body, compressor);\n            return self;\n        });\n\n        function trim_block(node, parent, in_list) {\n            switch (node.body.length) {\n              case 0:\n                return in_list ? List.skip : make_node(AST_EmptyStatement, node);\n              case 1:\n                var stat = node.body[0];\n                if (!safe_to_trim(stat)) return node;\n                if (parent instanceof AST_IterationStatement && stat instanceof AST_LambdaDefinition) return node;\n                return stat;\n            }\n            return node;\n        }\n\n        OPT(AST_BlockStatement, function(self, compressor) {\n            self.body = tighten_body(self.body, compressor);\n            return trim_block(self, compressor.parent());\n        });\n\n        function drop_rest_farg(fn, compressor) {\n            if (!compressor.option(\"rests\")) return;\n            if (fn.uses_arguments) return;\n            if (!(fn.rest instanceof AST_DestructuredArray)) return;\n            if (!compressor.drop_fargs(fn, compressor.parent())) return;\n            fn.argnames = fn.argnames.concat(fn.rest.elements);\n            fn.rest = fn.rest.rest;\n        }\n\n        OPT(AST_Lambda, function(self, compressor) {\n            drop_rest_farg(self, compressor);\n            self.body = tighten_body(self.body, compressor);\n            return self;\n        });\n\n        function opt_arrow(self, compressor) {\n            if (!compressor.option(\"arrows\")) return self;\n            drop_rest_farg(self, compressor);\n            if (self.value) self.body = [ self.first_statement() ];\n            var body = tighten_body(self.body, compressor);\n            switch (body.length) {\n              case 1:\n                var stat = body[0];\n                if (stat instanceof AST_Return) {\n                    self.body.length = 0;\n                    self.value = stat.value;\n                    break;\n                }\n              default:\n                self.body = body;\n                self.value = null;\n                break;\n            }\n            return self;\n        }\n        OPT(AST_Arrow, opt_arrow);\n        OPT(AST_AsyncArrow, opt_arrow);\n\n        OPT(AST_Function, function(self, compressor) {\n            drop_rest_farg(self, compressor);\n            self.body = tighten_body(self.body, compressor);\n            var parent = compressor.parent();\n            if (compressor.option(\"inline\")) for (var i = 0; i < self.body.length; i++) {\n                var stat = self.body[i];\n                if (stat instanceof AST_Directive) continue;\n                if (stat instanceof AST_Return) {\n                    if (i != self.body.length - 1) break;\n                    var call = stat.value;\n                    if (!call || call.TYPE != \"Call\") break;\n                    if (call.is_expr_pure(compressor)) break;\n                    var exp = call.expression, fn;\n                    if (!(exp instanceof AST_SymbolRef)) {\n                        fn = exp;\n                    } else if (self.name && self.name.definition() === exp.definition()) {\n                        break;\n                    } else {\n                        fn = exp.fixed_value();\n                    }\n                    if (!(fn instanceof AST_Defun || fn instanceof AST_Function)) break;\n                    if (fn.rest) break;\n                    if (fn.uses_arguments) break;\n                    if (fn === exp) {\n                        if (fn.parent_scope !== self) break;\n                        if (!all(fn.enclosed, function(def) {\n                            return def.scope !== self;\n                        })) break;\n                    }\n                    if ((fn !== exp || fn.name)\n                        && (parent instanceof AST_ClassMethod || parent instanceof AST_ObjectMethod)\n                        && parent.value === compressor.self()) break;\n                    if (fn.contains_this()) break;\n                    var len = fn.argnames.length;\n                    if (len > 0 && compressor.option(\"inline\") < 2) break;\n                    if (len > self.argnames.length) break;\n                    if (!all(self.argnames, function(argname) {\n                        return argname instanceof AST_SymbolFunarg;\n                    })) break;\n                    if (!all(call.args, function(arg) {\n                        return !(arg instanceof AST_Spread);\n                    })) break;\n                    for (var j = 0; j < len; j++) {\n                        var arg = call.args[j];\n                        if (!(arg instanceof AST_SymbolRef)) break;\n                        if (arg.definition() !== self.argnames[j].definition()) break;\n                    }\n                    if (j < len) break;\n                    for (; j < call.args.length; j++) {\n                        if (call.args[j].has_side_effects(compressor)) break;\n                    }\n                    if (j < call.args.length) break;\n                    if (len < self.argnames.length && !compressor.drop_fargs(self, parent)) {\n                        if (!compressor.drop_fargs(fn, call)) break;\n                        do {\n                            fn.argnames.push(fn.make_var(AST_SymbolFunarg, fn, \"argument_\" + len));\n                        } while (++len < self.argnames.length);\n                    }\n                    return exp;\n                }\n                break;\n            }\n            return self;\n        });\n\n        var NO_MERGE = makePredicate(\"arguments await yield\");\n        AST_Scope.DEFMETHOD(\"merge_variables\", function(compressor) {\n            if (!compressor.option(\"merge_vars\")) return;\n            var in_arg = [], in_try, root, segment = {}, self = this;\n            var first = [], last = [], index = 0;\n            var declarations = new Dictionary();\n            var references = Object.create(null);\n            var prev = Object.create(null);\n            var tw = new TreeWalker(function(node, descend) {\n                if (node instanceof AST_Assign) {\n                    var lhs = node.left;\n                    var rhs = node.right;\n                    if (lhs instanceof AST_Destructured) {\n                        rhs.walk(tw);\n                        walk_destructured(AST_SymbolRef, mark, lhs);\n                        return true;\n                    }\n                    if (lazy_op[node.operator.slice(0, -1)]) {\n                        lhs.walk(tw);\n                        push();\n                        rhs.walk(tw);\n                        if (lhs instanceof AST_SymbolRef) mark(lhs);\n                        pop();\n                        return true;\n                    }\n                    if (lhs instanceof AST_SymbolRef) {\n                        if (node.operator != \"=\") mark(lhs, true);\n                        rhs.walk(tw);\n                        mark(lhs);\n                        return true;\n                    }\n                    return;\n                }\n                if (node instanceof AST_Binary) {\n                    if (!lazy_op[node.operator]) return;\n                    walk_cond(node);\n                    return true;\n                }\n                if (node instanceof AST_Break) {\n                    var target = tw.loopcontrol_target(node);\n                    if (!(target instanceof AST_IterationStatement)) insert(target);\n                    return true;\n                }\n                if (node instanceof AST_Call) {\n                    var exp = node.expression;\n                    if (exp instanceof AST_LambdaExpression) {\n                        node.args.forEach(function(arg) {\n                            arg.walk(tw);\n                        });\n                        exp.walk(tw);\n                    } else {\n                        descend();\n                        mark_expression(exp);\n                    }\n                    return true;\n                }\n                if (node instanceof AST_Class) {\n                    if (node.name) node.name.walk(tw);\n                    if (node.extends) node.extends.walk(tw);\n                    node.properties.filter(function(prop) {\n                        if (prop.key instanceof AST_Node) prop.key.walk(tw);\n                        return prop.value;\n                    }).forEach(function(prop) {\n                        if (prop.static) {\n                            prop.value.walk(tw);\n                        } else {\n                            push();\n                            segment.block = node;\n                            prop.value.walk(tw);\n                            pop();\n                        }\n                    });\n                    return true;\n                }\n                if (node instanceof AST_Conditional) {\n                    walk_cond(node.condition, node.consequent, node.alternative);\n                    return true;\n                }\n                if (node instanceof AST_Continue) {\n                    var target = tw.loopcontrol_target(node);\n                    if (target instanceof AST_Do) insert(target);\n                    return true;\n                }\n                if (node instanceof AST_Do) {\n                    push();\n                    segment.block = node;\n                    segment.loop = true;\n                    var save = segment;\n                    node.body.walk(tw);\n                    if (segment.inserted === node) segment = save;\n                    node.condition.walk(tw);\n                    pop();\n                    return true;\n                }\n                if (node instanceof AST_For) {\n                    if (node.init) node.init.walk(tw);\n                    push();\n                    segment.block = node;\n                    segment.loop = true;\n                    if (node.condition) node.condition.walk(tw);\n                    node.body.walk(tw);\n                    if (node.step) node.step.walk(tw);\n                    pop();\n                    return true;\n                }\n                if (node instanceof AST_ForEnumeration) {\n                    node.object.walk(tw);\n                    push();\n                    segment.block = node;\n                    segment.loop = true;\n                    node.init.walk(tw);\n                    node.body.walk(tw);\n                    pop();\n                    return true;\n                }\n                if (node instanceof AST_If) {\n                    walk_cond(node.condition, node.body, node.alternative);\n                    return true;\n                }\n                if (node instanceof AST_LabeledStatement) {\n                    push();\n                    segment.block = node;\n                    var save = segment;\n                    node.body.walk(tw);\n                    if (segment.inserted === node) segment = save;\n                    pop();\n                    return true;\n                }\n                if (node instanceof AST_Scope) {\n                    push();\n                    segment.block = node;\n                    if (node === self) root = segment;\n                    if (node instanceof AST_Lambda) {\n                        if (node.name) references[node.name.definition().id] = false;\n                        var marker = node.uses_arguments && !tw.has_directive(\"use strict\") ? function(node) {\n                            references[node.definition().id] = false;\n                        } : function(node) {\n                            mark(node);\n                        };\n                        in_arg.push(node);\n                        node.argnames.forEach(function(argname) {\n                            walk_destructured(AST_SymbolFunarg, marker, argname);\n                        });\n                        if (node.rest) walk_destructured(AST_SymbolFunarg, marker, node.rest);\n                        in_arg.pop();\n                    }\n                    walk_lambda(node, tw);\n                    pop();\n                    return true;\n                }\n                if (node instanceof AST_Sub) {\n                    var exp = node.expression;\n                    if (node.optional) {\n                        exp.walk(tw);\n                        push();\n                        node.property.walk(tw);\n                        pop();\n                    } else {\n                        descend();\n                    }\n                    mark_expression(exp);\n                    return true;\n                }\n                if (node instanceof AST_Switch) {\n                    node.expression.walk(tw);\n                    var save = segment;\n                    node.body.forEach(function(branch) {\n                        if (branch instanceof AST_Default) return;\n                        branch.expression.walk(tw);\n                        if (save === segment) push();\n                    });\n                    segment = save;\n                    node.body.forEach(function(branch) {\n                        push();\n                        segment.block = node;\n                        var save = segment;\n                        walk_body(branch, tw);\n                        if (segment.inserted === node) segment = save;\n                        pop();\n                    });\n                    return true;\n                }\n                if (node instanceof AST_SymbolConst || node instanceof AST_SymbolLet) {\n                    references[node.definition().id] = false;\n                    return true;\n                }\n                if (node instanceof AST_SymbolRef) {\n                    mark(node, true);\n                    return true;\n                }\n                if (node instanceof AST_Try) {\n                    var save_try = in_try;\n                    in_try = node;\n                    walk_body(node, tw);\n                    if (node.bcatch) {\n                        if (node.bcatch.argname) node.bcatch.argname.mark_symbol(function(node) {\n                            if (node instanceof AST_SymbolCatch) {\n                                var def = node.definition();\n                                references[def.id] = false;\n                                if (def = def.redefined()) references[def.id] = false;\n                            }\n                        }, tw);\n                        if (node.bfinally || (in_try = save_try)) {\n                            walk_body(node.bcatch, tw);\n                        } else {\n                            push();\n                            walk_body(node.bcatch, tw);\n                            pop();\n                        }\n                    }\n                    in_try = save_try;\n                    if (node.bfinally) node.bfinally.walk(tw);\n                    return true;\n                }\n                if (node instanceof AST_Unary) {\n                    if (!UNARY_POSTFIX[node.operator]) return;\n                    var sym = node.expression;\n                    if (!(sym instanceof AST_SymbolRef)) return;\n                    mark(sym, true);\n                    return true;\n                }\n                if (node instanceof AST_VarDef) {\n                    var assigned = node.value;\n                    if (assigned) {\n                        assigned.walk(tw);\n                    } else {\n                        assigned = segment.block instanceof AST_ForEnumeration && segment.block.init === tw.parent();\n                    }\n                    walk_destructured(AST_SymbolDeclaration, assigned ? function(node) {\n                        if (node instanceof AST_SymbolVar) {\n                            mark(node);\n                        } else {\n                            node.walk(tw);\n                        }\n                    } : function(node) {\n                        if (node instanceof AST_SymbolVar) {\n                            var id = node.definition().id;\n                            var refs = references[id];\n                            if (refs) {\n                                refs.push(node);\n                            } else if (!(id in references)) {\n                                declarations.add(id, node);\n                            }\n                        } else {\n                            node.walk(tw);\n                        }\n                    }, node.name);\n                    return true;\n                }\n                if (node instanceof AST_While) {\n                    push();\n                    segment.block = node;\n                    segment.loop = true;\n                    descend();\n                    pop();\n                    return true;\n                }\n\n                function mark_expression(exp) {\n                    if (!compressor.option(\"ie\")) return;\n                    var sym = root_expr(exp);\n                    if (sym instanceof AST_SymbolRef) sym.walk(tw);\n                }\n\n                function walk_cond(condition, consequent, alternative) {\n                    var save = segment;\n                    var segments = [ save, save ];\n                    if (condition instanceof AST_Binary) switch (condition.operator) {\n                      case \"&&\":\n                        segments[0] = walk_cond(condition.left, condition.right)[0];\n                        break;\n                      case \"||\":\n                      case \"??\":\n                        segments[1] = walk_cond(condition.left, null, condition.right)[1];\n                        break;\n                      default:\n                        condition.walk(tw);\n                        break;\n                    } else if (condition instanceof AST_Conditional) {\n                        walk_cond(condition.condition, condition.consequent, condition.alternative);\n                    } else {\n                        condition.walk(tw);\n                    }\n                    segment = segments[0];\n                    if (consequent) {\n                        push();\n                        consequent.walk(tw);\n                    }\n                    segments[0] = segment;\n                    segment = segments[1];\n                    if (alternative) {\n                        push();\n                        alternative.walk(tw);\n                    }\n                    segments[1] = segment;\n                    segment = save;\n                    return segments;\n                }\n            });\n            tw.directives = Object.create(compressor.directives);\n            self.walk(tw);\n            var changed = false;\n            var merged = Object.create(null);\n            while (first.length && last.length) {\n                var tail = last.shift();\n                if (!tail) continue;\n                var def = tail.definition;\n                var tail_refs = references[def.id];\n                if (!tail_refs) continue;\n                tail_refs = { end: tail_refs.end };\n                while (def.id in merged) def = merged[def.id];\n                tail_refs.start = references[def.id].start;\n                var skipped = [];\n                do {\n                    var head = first.shift();\n                    if (tail.index > head.index) continue;\n                    var prev_def = head.definition;\n                    if (!(prev_def.id in prev)) continue;\n                    var head_refs = references[prev_def.id];\n                    if (!head_refs) continue;\n                    if (head_refs.start.block !== tail_refs.start.block\n                        || !mergeable(head_refs, tail_refs)\n                        || (head_refs.start.loop || !same_scope(def)) && !mergeable(tail_refs, head_refs)\n                        || compressor.option(\"webkit\") && is_funarg(def) !== is_funarg(prev_def)\n                        || prev_def.const_redefs\n                        || !all(head_refs.scopes, function(scope) {\n                            return scope.find_variable(def.name) === def;\n                        })) {\n                        skipped.push(head);\n                        continue;\n                    }\n                    head_refs.forEach(function(sym) {\n                        sym.thedef = def;\n                        sym.name = def.name;\n                        if (sym instanceof AST_SymbolRef) {\n                            def.references.push(sym);\n                            prev_def.replaced++;\n                        } else {\n                            def.orig.push(sym);\n                            prev_def.eliminated++;\n                        }\n                    });\n                    if (!prev_def.fixed) def.fixed = false;\n                    merged[prev_def.id] = def;\n                    changed = true;\n                    break;\n                } while (first.length);\n                if (skipped.length) first = skipped.concat(first);\n            }\n            return changed;\n\n            function push() {\n                segment = Object.create(segment);\n            }\n\n            function pop() {\n                segment = Object.getPrototypeOf(segment);\n            }\n\n            function walk_destructured(symbol_type, mark, lhs) {\n                var marker = new TreeWalker(function(node) {\n                    if (node instanceof AST_Destructured) return;\n                    if (node instanceof AST_DefaultValue) {\n                        push();\n                        node.value.walk(tw);\n                        pop();\n                        node.name.walk(marker);\n                    } else if (node instanceof AST_DestructuredKeyVal) {\n                        if (!(node.key instanceof AST_Node)) {\n                            node.value.walk(marker);\n                        } else if (node.value instanceof AST_PropAccess) {\n                            push();\n                            segment.block = node;\n                            node.key.walk(tw);\n                            node.value.walk(marker);\n                            pop();\n                        } else {\n                            node.key.walk(tw);\n                            node.value.walk(marker);\n                        }\n                    } else if (node instanceof symbol_type) {\n                        mark(node);\n                    } else {\n                        node.walk(tw);\n                    }\n                    return true;\n                });\n                lhs.walk(marker);\n            }\n\n            function mark(sym, read) {\n                var def = sym.definition(), ldef;\n                if (read && !all(in_arg, function(fn) {\n                    ldef = fn.variables.get(sym.name);\n                    if (!ldef) return true;\n                    if (!is_funarg(ldef)) return true;\n                    return ldef !== def\n                        && !def.undeclared\n                        && fn.parent_scope.find_variable(sym.name) !== def;\n                })) return references[def.id] = references[ldef.id] = false;\n                var seg = segment;\n                if (in_try) {\n                    push();\n                    seg = segment;\n                    pop();\n                }\n                if (def.id in references) {\n                    var refs = references[def.id];\n                    if (!refs) return;\n                    if (refs.start.block !== seg.block) return references[def.id] = false;\n                    push_ref(sym);\n                    refs.end = seg;\n                    if (def.id in prev) {\n                        last[prev[def.id]] = null;\n                    } else if (!read) {\n                        return;\n                    }\n                } else if ((ldef = self.variables.get(def.name)) !== def) {\n                    if (ldef && root === seg) references[ldef.id] = false;\n                    return references[def.id] = false;\n                } else if (compressor.exposed(def) || NO_MERGE[sym.name]) {\n                    return references[def.id] = false;\n                } else {\n                    var refs = declarations.get(def.id) || [];\n                    refs.scopes = [];\n                    push_ref(sym);\n                    references[def.id] = refs;\n                    if (!read) {\n                        refs.start = seg;\n                        return first.push({\n                            index: index++,\n                            definition: def,\n                        });\n                    }\n                    if (seg.block !== self) return references[def.id] = false;\n                    refs.start = root;\n                }\n                prev[def.id] = last.length;\n                last.push({\n                    index: index++,\n                    definition: def,\n                });\n\n                function push_ref(sym) {\n                    refs.push(sym);\n                    push_uniq(refs.scopes, sym.scope);\n                    var scope = find_scope(tw);\n                    if (scope !== sym.scope) push_uniq(refs.scopes, scope);\n                }\n            }\n\n            function insert(target) {\n                var stack = [];\n                while (true) {\n                    if (HOP(segment, \"block\")) {\n                        var block = segment.block;\n                        if (block instanceof AST_LabeledStatement) block = block.body;\n                        if (block === target) break;\n                    }\n                    stack.push(segment);\n                    pop();\n                }\n                segment.inserted = segment.block;\n                push();\n                while (stack.length) {\n                    var seg = stack.pop();\n                    push();\n                    if (HOP(seg, \"block\")) segment.block = seg.block;\n                    if (HOP(seg, \"loop\")) segment.loop = seg.loop;\n                }\n            }\n\n            function must_visit(base, segment) {\n                return base === segment || base.isPrototypeOf(segment);\n            }\n\n            function mergeable(head, tail) {\n                return must_visit(head.start, head.end) || must_visit(head.start, tail.start);\n            }\n        });\n\n        function fill_holes(orig, elements) {\n            for (var i = elements.length; --i >= 0;) {\n                if (!elements[i]) elements[i] = make_node(AST_Hole, orig);\n            }\n        }\n\n        function to_class_expr(defcl, drop_name) {\n            var cl = make_node(AST_ClassExpression, defcl);\n            if (cl.name) cl.name = drop_name ? null : make_node(AST_SymbolClass, cl.name);\n            return cl;\n        }\n\n        function to_func_expr(defun, drop_name) {\n            var ctor;\n            switch (defun.CTOR) {\n              case AST_AsyncDefun:\n                ctor = AST_AsyncFunction;\n                break;\n              case AST_AsyncGeneratorDefun:\n                ctor = AST_AsyncGeneratorFunction;\n                break;\n              case AST_Defun:\n                ctor = AST_Function;\n                break;\n              case AST_GeneratorDefun:\n                ctor = AST_GeneratorFunction;\n                break;\n            }\n            var fn = make_node(ctor, defun);\n            fn.name = drop_name ? null : make_node(AST_SymbolLambda, defun.name);\n            return fn;\n        }\n\n        AST_Scope.DEFMETHOD(\"drop_unused\", function(compressor) {\n            if (!compressor.option(\"unused\")) return;\n            var self = this;\n            var drop_funcs = !(self instanceof AST_Toplevel) || compressor.toplevel.funcs;\n            var drop_vars = !(self instanceof AST_Toplevel) || compressor.toplevel.vars;\n            var assign_as_unused = /keep_assign/.test(compressor.option(\"unused\")) ? return_false : function(node, props) {\n                var sym, nested = false;\n                if (node instanceof AST_Assign) {\n                    if (node.write_only || node.operator == \"=\") sym = extract_reference(node.left, props);\n                } else if (node instanceof AST_Unary) {\n                    if (node.write_only) sym = extract_reference(node.expression, props);\n                }\n                if (!(sym instanceof AST_SymbolRef)) return;\n                var def = sym.definition();\n                if (export_defaults[def.id]) return;\n                if (compressor.exposed(def)) return;\n                if (!can_drop_symbol(sym, compressor, nested)) return;\n                return sym;\n\n                function extract_reference(node, props) {\n                    if (node instanceof AST_PropAccess) {\n                        var expr = node.expression;\n                        if (!expr.may_throw_on_access(compressor, true)) {\n                            nested = true;\n                            if (props && node instanceof AST_Sub) props.unshift(node.property);\n                            return extract_reference(expr, props);\n                        }\n                    } else if (node instanceof AST_Assign && node.operator == \"=\") {\n                        node.write_only = \"p\";\n                        var ref = extract_reference(node.right);\n                        if (!props) return ref;\n                        props.assign = node;\n                        return ref instanceof AST_SymbolRef ? ref : node.left;\n                    }\n                    return node;\n                }\n            };\n            var assign_in_use = Object.create(null);\n            var export_defaults = Object.create(null);\n            var find_variable = function(name) {\n                find_variable = compose(self, 0, noop);\n                return find_variable(name);\n\n                function compose(child, level, find) {\n                    var parent = compressor.parent(level);\n                    if (!parent) return find;\n                    var in_arg = parent instanceof AST_Lambda && member(child, parent.argnames);\n                    return compose(parent, level + 1, in_arg ? function(name) {\n                        var def = find(name);\n                        if (def) return def;\n                        def = parent.variables.get(name);\n                        if (def) {\n                            var sym = def.orig[0];\n                            if (sym instanceof AST_SymbolFunarg || sym instanceof AST_SymbolLambda) return def;\n                        }\n                    } : parent.variables ? function(name) {\n                        return find(name) || parent.variables.get(name);\n                    } : find);\n                }\n            };\n            var for_ins = Object.create(null);\n            var in_use = [];\n            var in_use_ids = Object.create(null); // avoid expensive linear scans of in_use\n            var lambda_ids = Object.create(null);\n            var value_read = Object.create(null);\n            var value_modified = Object.create(null);\n            var var_defs = Object.create(null);\n            if (self instanceof AST_Toplevel && compressor.top_retain) {\n                self.variables.each(function(def) {\n                    if (compressor.top_retain(def) && !(def.id in in_use_ids)) {\n                        AST_Node.info(\"Retaining variable {name}\", def);\n                        in_use_ids[def.id] = true;\n                        in_use.push(def);\n                    }\n                });\n            }\n            var assignments = new Dictionary();\n            var initializations = new Dictionary();\n            // pass 1: find out which symbols are directly used in\n            // this scope (not in nested scopes).\n            var scope = this;\n            var tw = new TreeWalker(function(node, descend) {\n                if (node instanceof AST_Lambda && node.uses_arguments && !tw.has_directive(\"use strict\")) {\n                    node.each_argname(function(argname) {\n                        var def = argname.definition();\n                        if (!(def.id in in_use_ids)) {\n                            in_use_ids[def.id] = true;\n                            in_use.push(def);\n                        }\n                    });\n                }\n                if (node === self) return;\n                if (scope === self) {\n                    if (node instanceof AST_DefClass) {\n                        var def = node.name.definition();\n                        var drop = drop_funcs && !def.exported;\n                        if (!drop && !(def.id in in_use_ids)) {\n                            in_use_ids[def.id] = true;\n                            in_use.push(def);\n                        }\n                        var used = tw.parent() instanceof AST_ExportDefault;\n                        if (used) {\n                            export_defaults[def.id] = true;\n                        } else if (drop && !(def.id in lambda_ids)) {\n                            lambda_ids[def.id] = 1;\n                        }\n                        if (node.extends) node.extends.walk(tw);\n                        var values = [];\n                        node.properties.forEach(function(prop) {\n                            if (prop.key instanceof AST_Node) prop.key.walk(tw);\n                            var value = prop.value;\n                            if (!value) return;\n                            if (is_static_field_or_init(prop)) {\n                                if (!used && value.contains_this()) used = true;\n                                walk_class_prop(value);\n                            } else {\n                                values.push(value);\n                            }\n                        });\n                        values.forEach(drop && used ? walk_class_prop : function(value) {\n                            initializations.add(def.id, value);\n                        });\n                        return true;\n                    }\n                    if (node instanceof AST_LambdaDefinition) {\n                        var def = node.name.definition();\n                        var drop = drop_funcs && !def.exported;\n                        if (!drop && !(def.id in in_use_ids)) {\n                            in_use_ids[def.id] = true;\n                            in_use.push(def);\n                        }\n                        initializations.add(def.id, node);\n                        if (tw.parent() instanceof AST_ExportDefault) {\n                            export_defaults[def.id] = true;\n                            return scan_ref_scoped(node, descend, true);\n                        }\n                        if (drop && !(def.id in lambda_ids)) lambda_ids[def.id] = 1;\n                        return true;\n                    }\n                    if (node instanceof AST_Definitions) {\n                        node.definitions.forEach(function(defn) {\n                            var value = defn.value;\n                            var side_effects = value\n                                && (defn.name instanceof AST_Destructured || value.has_side_effects(compressor));\n                            var shared = side_effects && value.tail_node().operator == \"=\";\n                            defn.name.mark_symbol(function(name) {\n                                if (!(name instanceof AST_SymbolDeclaration)) return;\n                                var def = name.definition();\n                                var_defs[def.id] = (var_defs[def.id] || 0) + 1;\n                                if (node instanceof AST_Var && def.orig[0] instanceof AST_SymbolCatch) {\n                                    var redef = def.redefined();\n                                    if (redef) var_defs[redef.id] = (var_defs[redef.id] || 0) + 1;\n                                }\n                                if (!(def.id in in_use_ids) && (!drop_vars || def.exported\n                                    || (node instanceof AST_Const ? def.redefined() : def.const_redefs)\n                                    || !(node instanceof AST_Var || is_safe_lexical(def)))) {\n                                    in_use_ids[def.id] = true;\n                                    in_use.push(def);\n                                }\n                                if (value) {\n                                    if (!side_effects) {\n                                        initializations.add(def.id, value);\n                                    } else if (shared) {\n                                        verify_safe_usage(def, name, value_modified[def.id]);\n                                    }\n                                    assignments.add(def.id, defn);\n                                }\n                                unmark_lambda(def);\n                                return true;\n                            }, tw);\n                            if (side_effects) value.walk(tw);\n                        });\n                        return true;\n                    }\n                    if (node instanceof AST_SymbolFunarg) {\n                        var def = node.definition();\n                        var_defs[def.id] = (var_defs[def.id] || 0) + 1;\n                        assignments.add(def.id, node);\n                        return true;\n                    }\n                    if (node instanceof AST_SymbolImport) {\n                        var def = node.definition();\n                        if (!(def.id in in_use_ids) && (!drop_vars || !is_safe_lexical(def))) {\n                            in_use_ids[def.id] = true;\n                            in_use.push(def);\n                        }\n                        return true;\n                    }\n                }\n                return scan_ref_scoped(node, descend, true);\n\n                function walk_class_prop(value) {\n                    var save_scope = scope;\n                    scope = node;\n                    value.walk(tw);\n                    scope = save_scope;\n                }\n            });\n            tw.directives = Object.create(compressor.directives);\n            self.walk(tw);\n            var drop_fn_name = compressor.option(\"keep_fnames\") ? return_false : compressor.option(\"ie\") ? function(def) {\n                return !compressor.exposed(def) && def.references.length == def.replaced;\n            } : function(def) {\n                if (!(def.id in in_use_ids)) return true;\n                if (def.orig.length - def.eliminated < 2) return false;\n                // function argument will always overshadow its name\n                if (def.orig[1] instanceof AST_SymbolFunarg) return true;\n                // retain if referenced within destructured object of argument\n                return all(def.references, function(ref) {\n                    return !ref.in_arg;\n                });\n            };\n            if (compressor.option(\"ie\")) initializations.each(function(init, id) {\n                if (id in in_use_ids) return;\n                init.forEach(function(init) {\n                    init.walk(new TreeWalker(function(node) {\n                        if (node instanceof AST_Function && node.name && !drop_fn_name(node.name.definition())) {\n                            node.walk(tw);\n                            return true;\n                        }\n                        if (node instanceof AST_Scope) return true;\n                    }));\n                });\n            });\n            // pass 2: for every used symbol we need to walk its\n            // initialization code to figure out if it uses other\n            // symbols (that may not be in_use).\n            tw = new TreeWalker(scan_ref_scoped);\n            for (var i = 0; i < in_use.length; i++) {\n                var init = initializations.get(in_use[i].id);\n                if (init) init.forEach(function(init) {\n                    init.walk(tw);\n                });\n            }\n            Object.keys(assign_in_use).forEach(function(id) {\n                var assigns = assign_in_use[id];\n                if (!assigns) {\n                    delete assign_in_use[id];\n                    return;\n                }\n                assigns = assigns.reduce(function(in_use, assigns) {\n                    assigns.forEach(function(assign) {\n                        push_uniq(in_use, assign);\n                    });\n                    return in_use;\n                }, []);\n                var in_use = (assignments.get(id) || []).filter(function(node) {\n                    return find_if(node instanceof AST_Unary ? function(assign) {\n                        return assign === node;\n                    } : function(assign) {\n                        if (assign === node) return true;\n                        if (assign instanceof AST_Unary) return false;\n                        return get_rvalue(assign) === get_rvalue(node);\n                    }, assigns);\n                });\n                if (assigns.length == in_use.length) {\n                    assign_in_use[id] = in_use;\n                } else {\n                    delete assign_in_use[id];\n                }\n            });\n            // pass 3: we should drop declarations not in_use\n            var calls_to_drop_args = [];\n            var fns_with_marked_args = [];\n            var trimmer = new TreeTransformer(function(node) {\n                if (node instanceof AST_DefaultValue) return trim_default(trimmer, node);\n                if (node instanceof AST_Destructured && node.rest) node.rest = node.rest.transform(trimmer);\n                if (node instanceof AST_DestructuredArray) {\n                    var trim = !node.rest;\n                    for (var i = node.elements.length; --i >= 0;) {\n                        var element = node.elements[i].transform(trimmer);\n                        if (element) {\n                            node.elements[i] = element;\n                            trim = false;\n                        } else if (trim) {\n                            node.elements.pop();\n                        } else {\n                            node.elements[i] = make_node(AST_Hole, node.elements[i]);\n                        }\n                    }\n                    return node;\n                }\n                if (node instanceof AST_DestructuredObject) {\n                    var properties = [];\n                    node.properties.forEach(function(prop) {\n                        var retain = false;\n                        if (prop.key instanceof AST_Node) {\n                            prop.key = prop.key.transform(tt);\n                            retain = prop.key.has_side_effects(compressor);\n                        }\n                        if ((retain || node.rest) && is_decl(prop.value)) {\n                            prop.value = prop.value.transform(tt);\n                            properties.push(prop);\n                        } else {\n                            var value = prop.value.transform(trimmer);\n                            if (!value && node.rest) {\n                                if (prop.value instanceof AST_DestructuredArray) {\n                                    value = make_node(AST_DestructuredArray, prop.value, { elements: [] });\n                                } else {\n                                    value = make_node(AST_DestructuredObject, prop.value, { properties: [] });\n                                }\n                            }\n                            if (value) {\n                                prop.value = value;\n                                properties.push(prop);\n                            }\n                        }\n                    });\n                    node.properties = properties;\n                    return node;\n                }\n                if (node instanceof AST_SymbolDeclaration) return trim_decl(node);\n            });\n            var tt = new TreeTransformer(function(node, descend, in_list) {\n                var parent = tt.parent();\n                if (drop_vars) {\n                    var props = [], sym = assign_as_unused(node, props);\n                    if (sym) {\n                        var value;\n                        if (can_drop_lhs(sym, node)) {\n                            if (node instanceof AST_Assign) {\n                                value = get_rhs(node);\n                                if (node.write_only === true) value = value.drop_side_effect_free(compressor);\n                            }\n                            if (!value) value = make_node(AST_Number, node, { value: 0 });\n                        }\n                        if (value) {\n                            if (props.assign) {\n                                var assign = props.assign.drop_side_effect_free(compressor);\n                                if (assign) {\n                                    assign.write_only = true;\n                                    props.unshift(assign);\n                                }\n                            }\n                            if (!(parent instanceof AST_Sequence)\n                                || parent.tail_node() === node\n                                || value.has_side_effects(compressor)) {\n                                props.push(value);\n                            }\n                            switch (props.length) {\n                              case 0:\n                                return List.skip;\n                              case 1:\n                                return maintain_this_binding(parent, node, props[0].transform(tt));\n                              default:\n                                return make_sequence(node, props.map(function(prop) {\n                                    return prop.transform(tt);\n                                }));\n                            }\n                        }\n                    } else if (node instanceof AST_UnaryPostfix\n                        && node.expression instanceof AST_SymbolRef\n                        && indexOf_assign(node.expression.definition(), node) < 0) {\n                        return make_node(AST_UnaryPrefix, node, {\n                            operator: \"+\",\n                            expression: node.expression,\n                        });\n                    }\n                }\n                if (node instanceof AST_Binary && node.operator == \"instanceof\") {\n                    var sym = node.right;\n                    if (!(sym instanceof AST_SymbolRef)) return;\n                    if (sym.definition().id in in_use_ids) return;\n                    var lhs = node.left.drop_side_effect_free(compressor);\n                    var value = make_node(AST_False, node).optimize(compressor);\n                    return lhs ? make_sequence(node, [ lhs, value ]) : value;\n                }\n                if (node instanceof AST_Call) {\n                    calls_to_drop_args.push(node);\n                    node.args = node.args.map(function(arg) {\n                        return arg.transform(tt);\n                    });\n                    node.expression = node.expression.transform(tt);\n                    return node;\n                }\n                if (scope !== self) return;\n                if (drop_funcs && node !== self && node instanceof AST_DefClass) {\n                    var def = node.name.definition();\n                    if (!(def.id in in_use_ids)) {\n                        log(node.name, \"Dropping unused class {name}\");\n                        def.eliminated++;\n                        descend(node, tt);\n                        var trimmed = to_class_expr(node, true);\n                        if (parent instanceof AST_ExportDefault) return trimmed;\n                        trimmed = trimmed.drop_side_effect_free(compressor, true);\n                        if (trimmed) return make_node(AST_SimpleStatement, node, { body: trimmed });\n                        return in_list ? List.skip : make_node(AST_EmptyStatement, node);\n                    }\n                }\n                if (node instanceof AST_ClassExpression && node.name && drop_fn_name(node.name.definition())) {\n                    node.name = null;\n                }\n                if (node instanceof AST_Lambda) {\n                    if (drop_funcs && node !== self && node instanceof AST_LambdaDefinition) {\n                        var def = node.name.definition();\n                        if (!(def.id in in_use_ids)) {\n                            log(node.name, \"Dropping unused function {name}\");\n                            def.eliminated++;\n                            if (parent instanceof AST_ExportDefault) {\n                                descend_scope();\n                                return to_func_expr(node, true);\n                            }\n                            return in_list ? List.skip : make_node(AST_EmptyStatement, node);\n                        }\n                    }\n                    descend_scope();\n                    if (node instanceof AST_LambdaExpression && node.name && drop_fn_name(node.name.definition())) {\n                        node.name = null;\n                    }\n                    if (!(node instanceof AST_Accessor)) {\n                        var args, spread, trim = compressor.drop_fargs(node, parent);\n                        if (trim && parent instanceof AST_Call && parent.expression === node) {\n                            args = parent.args;\n                            for (spread = 0; spread < args.length; spread++) {\n                                if (args[spread] instanceof AST_Spread) break;\n                            }\n                        }\n                        var argnames = node.argnames;\n                        var rest = node.rest;\n                        var after = false, before = false;\n                        if (rest) {\n                            before = true;\n                            if (!args || spread < argnames.length || rest instanceof AST_SymbolFunarg) {\n                                rest = rest.transform(trimmer);\n                            } else {\n                                var trimmed = trim_destructured(rest, make_node(AST_Array, parent, {\n                                    elements: args.slice(argnames.length),\n                                }), trim_decl, !node.uses_arguments, rest);\n                                rest = trimmed.name;\n                                args.length = argnames.length;\n                                if (trimmed.value.elements.length) [].push.apply(args, trimmed.value.elements);\n                            }\n                            if (rest instanceof AST_Destructured && !rest.rest) {\n                                if (rest instanceof AST_DestructuredArray) {\n                                    if (rest.elements.length == 0) rest = null;\n                                } else if (rest.properties.length == 0) {\n                                    rest = null;\n                                }\n                            }\n                            node.rest = rest;\n                            if (rest) {\n                                trim = false;\n                                after = true;\n                            }\n                        }\n                        var default_length = trim ? -1 : node.length();\n                        var trim_value = args && !node.uses_arguments && parent !== compressor.parent();\n                        for (var i = argnames.length; --i >= 0;) {\n                            var sym = argnames[i];\n                            if (sym instanceof AST_SymbolFunarg) {\n                                var def = sym.definition();\n                                if (def.id in in_use_ids) {\n                                    trim = false;\n                                    if (indexOf_assign(def, sym) < 0) sym.unused = null;\n                                } else if (trim) {\n                                    log(sym, \"Dropping unused function argument {name}\");\n                                    argnames.pop();\n                                    def.eliminated++;\n                                    sym.unused = true;\n                                } else {\n                                    sym.unused = true;\n                                }\n                            } else {\n                                before = true;\n                                var funarg;\n                                if (!args || spread < i) {\n                                    funarg = sym.transform(trimmer);\n                                } else {\n                                    var trimmed = trim_destructured(sym, args[i], trim_decl, trim_value, sym);\n                                    funarg = trimmed.name;\n                                    if (trimmed.value) args[i] = trimmed.value;\n                                }\n                                if (funarg) {\n                                    trim = false;\n                                    argnames[i] = funarg;\n                                    if (!after) after = !(funarg instanceof AST_SymbolFunarg);\n                                } else if (trim) {\n                                    log_default(sym, \"Dropping unused default argument {name}\");\n                                    argnames.pop();\n                                } else if (i > default_length) {\n                                    log_default(sym, \"Dropping unused default argument assignment {name}\");\n                                    if (sym.name instanceof AST_SymbolFunarg) {\n                                        sym.name.unused = true;\n                                    } else {\n                                        after = true;\n                                    }\n                                    argnames[i] = sym.name;\n                                } else {\n                                    log_default(sym, \"Dropping unused default argument value {name}\");\n                                    argnames[i] = sym = sym.clone();\n                                    sym.value = make_node(AST_Number, sym, { value: 0 });\n                                    after = true;\n                                }\n                            }\n                        }\n                        if (before && !after && node.uses_arguments && !tt.has_directive(\"use strict\")) {\n                            node.rest = make_node(AST_DestructuredArray, node, { elements: [] });\n                        }\n                        fns_with_marked_args.push(node);\n                    }\n                    return node;\n                }\n                if (node instanceof AST_Catch && node.argname instanceof AST_Destructured) {\n                    node.argname.transform(trimmer);\n                }\n                if (node instanceof AST_Definitions && !(parent instanceof AST_ForEnumeration && parent.init === node)) {\n                    // place uninitialized names at the start\n                    var body = [], head = [], tail = [];\n                    // for unused names whose initialization has\n                    // side effects, we can cascade the init. code\n                    // into the next one, or next statement.\n                    var side_effects = [];\n                    var duplicated = 0;\n                    var is_var = node instanceof AST_Var;\n                    node.definitions.forEach(function(def) {\n                        if (def.value) def.value = def.value.transform(tt);\n                        var value = def.value;\n                        if (def.name instanceof AST_Destructured) {\n                            var trimmed = trim_destructured(def.name, value, function(node) {\n                                if (!drop_vars) return node;\n                                if (node.definition().id in in_use_ids) return node;\n                                if (is_catch(node)) return node;\n                                if (is_var && !can_drop_symbol(node)) return node;\n                                return null;\n                            }, true);\n                            if (trimmed.name) {\n                                def = make_node(AST_VarDef, def, {\n                                    name: trimmed.name,\n                                    value: value = trimmed.value,\n                                });\n                                flush();\n                            } else if (trimmed.value) {\n                                side_effects.push(trimmed.value);\n                            }\n                            return;\n                        }\n                        var sym = def.name.definition();\n                        var drop_sym = is_var ? can_drop_symbol(def.name) : is_safe_lexical(sym);\n                        if (!drop_sym || !drop_vars || sym.id in in_use_ids) {\n                            var index;\n                            if (value && ((index = indexOf_assign(sym, def)) < 0 || self_assign(value.tail_node()))) {\n                                def = def.clone();\n                                value = value.drop_side_effect_free(compressor);\n                                if (value) AST_Node.warn(\"Side effects in definition of variable {name} [{start}]\", def.name);\n                                if (node instanceof AST_Const) {\n                                    def.value = value || make_node(AST_Number, def, { value: 0 });\n                                } else {\n                                    def.value = null;\n                                    if (value) side_effects.push(value);\n                                }\n                                value = null;\n                                if (index >= 0) assign_in_use[sym.id][index] = def;\n                            }\n                            var old_def, fn;\n                            if (!value && !(node instanceof AST_Let)) {\n                                if (parent instanceof AST_ExportDeclaration) {\n                                    flush();\n                                } else if (drop_sym && var_defs[sym.id] > 1) {\n                                    AST_Node.info(\"Dropping declaration of variable {name} [{start}]\", def.name);\n                                    var_defs[sym.id]--;\n                                    sym.eliminated++;\n                                } else {\n                                    head.push(def);\n                                }\n                            } else if (compressor.option(\"functions\")\n                                && !compressor.option(\"ie\")\n                                && drop_sym\n                                && value\n                                && var_defs[sym.id] == 1\n                                && sym.assignments == 0\n                                && (fn = value.tail_node()) instanceof AST_LambdaExpression\n                                && !is_arguments(sym)\n                                && !is_arrow(fn)\n                                && assigned_once(fn, sym.references)\n                                && can_declare_defun(fn)\n                                && (old_def = rename_def(fn, def.name.name)) !== false) {\n                                AST_Node.warn(\"Declaring {name} as function [{start}]\", def.name);\n                                var ctor;\n                                switch (fn.CTOR) {\n                                  case AST_AsyncFunction:\n                                    ctor = AST_AsyncDefun;\n                                    break;\n                                  case AST_AsyncGeneratorFunction:\n                                    ctor = AST_AsyncGeneratorDefun;\n                                    break;\n                                  case AST_Function:\n                                    ctor = AST_Defun;\n                                    break;\n                                  case AST_GeneratorFunction:\n                                    ctor = AST_GeneratorDefun;\n                                    break;\n                                }\n                                var defun = make_node(ctor, fn);\n                                defun.name = make_node(AST_SymbolDefun, def.name);\n                                var name_def = def.name.scope.resolve().def_function(defun.name);\n                                if (old_def) old_def.forEach(function(node) {\n                                    node.name = name_def.name;\n                                    node.thedef = name_def;\n                                    node.reference();\n                                });\n                                body.push(defun);\n                                if (value !== fn) [].push.apply(side_effects, value.expressions.slice(0, -1));\n                            } else {\n                                if (drop_sym\n                                    && var_defs[sym.id] > 1\n                                    && !(parent instanceof AST_ExportDeclaration)\n                                    && sym.orig.indexOf(def.name) > sym.eliminated) {\n                                    var_defs[sym.id]--;\n                                    duplicated++;\n                                }\n                                flush();\n                            }\n                        } else if (is_catch(def.name)) {\n                            value = value && value.drop_side_effect_free(compressor);\n                            if (value) side_effects.push(value);\n                            if (var_defs[sym.id] > 1) {\n                                AST_Node.warn(\"Dropping duplicated declaration of variable {name} [{start}]\", def.name);\n                                var_defs[sym.id]--;\n                                sym.eliminated++;\n                            } else {\n                                def.value = null;\n                                head.push(def);\n                            }\n                        } else {\n                            value = value && value.drop_side_effect_free(compressor);\n                            if (value) {\n                                AST_Node.warn(\"Side effects in initialization of unused variable {name} [{start}]\", def.name);\n                                side_effects.push(value);\n                            } else {\n                                log(def.name, \"Dropping unused variable {name}\");\n                            }\n                            sym.eliminated++;\n                        }\n\n                        function self_assign(ref) {\n                            return ref instanceof AST_SymbolRef && ref.definition() === sym;\n                        }\n\n                        function assigned_once(fn, refs) {\n                            if (refs.length == 0) return fn === def.name.fixed_value();\n                            return all(refs, function(ref) {\n                                return fn === ref.fixed_value();\n                            });\n                        }\n\n                        function can_declare_defun(fn) {\n                            if (!is_var || compressor.has_directive(\"use strict\") || !(fn instanceof AST_Function)) {\n                                return parent instanceof AST_Scope;\n                            }\n                            return parent instanceof AST_Block\n                                || parent instanceof AST_For && parent.init === node\n                                || parent instanceof AST_If;\n                        }\n\n                        function rename_def(fn, name) {\n                            if (!fn.name) return null;\n                            var def = fn.name.definition();\n                            if (def.orig.length > 1) return null;\n                            if (def.assignments > 0) return false;\n                            if (def.name == name) return def;\n                            if (compressor.option(\"keep_fnames\")) return false;\n                            var forbidden;\n                            switch (name) {\n                              case \"await\":\n                                forbidden = is_async;\n                                break;\n                              case \"yield\":\n                                forbidden = is_generator;\n                                break;\n                            }\n                            return all(def.references, function(ref) {\n                                var scope = ref.scope;\n                                if (scope.find_variable(name) !== sym) return false;\n                                if (forbidden) do {\n                                    scope = scope.resolve();\n                                    if (forbidden(scope)) return false;\n                                } while (scope !== fn && (scope = scope.parent_scope));\n                                return true;\n                            }) && def;\n                        }\n\n                        function is_catch(node) {\n                            var sym = node.definition();\n                            return sym.orig[0] instanceof AST_SymbolCatch && sym.scope.resolve() === node.scope.resolve();\n                        }\n\n                        function flush() {\n                            if (side_effects.length > 0) {\n                                if (tail.length == 0) {\n                                    body.push(make_node(AST_SimpleStatement, node, {\n                                        body: make_sequence(node, side_effects),\n                                    }));\n                                } else if (value) {\n                                    side_effects.push(value);\n                                    def.value = make_sequence(value, side_effects);\n                                } else {\n                                    def.value = make_node(AST_UnaryPrefix, def, {\n                                        operator: \"void\",\n                                        expression: make_sequence(def, side_effects),\n                                    });\n                                }\n                                side_effects = [];\n                            }\n                            tail.push(def);\n                        }\n                    });\n                    switch (head.length) {\n                      case 0:\n                        if (tail.length == 0) break;\n                        if (tail.length == duplicated) {\n                            [].unshift.apply(side_effects, tail.map(function(def) {\n                                AST_Node.info(\"Dropping duplicated definition of variable {name} [{start}]\", def.name);\n                                var sym = def.name.definition();\n                                var ref = make_node(AST_SymbolRef, def.name);\n                                sym.references.push(ref);\n                                var assign = make_node(AST_Assign, def, {\n                                    operator: \"=\",\n                                    left: ref,\n                                    right: def.value,\n                                });\n                                var index = indexOf_assign(sym, def);\n                                if (index >= 0) assign_in_use[sym.id][index] = assign;\n                                sym.assignments++;\n                                sym.eliminated++;\n                                return assign;\n                            }));\n                            break;\n                        }\n                      case 1:\n                        if (tail.length == 0) {\n                            var id = head[0].name.definition().id;\n                            if (id in for_ins) {\n                                node.definitions = head;\n                                for_ins[id].init = node;\n                                break;\n                            }\n                        }\n                      default:\n                        var seq;\n                        if (tail.length > 0 && (seq = tail[0].value) instanceof AST_Sequence) {\n                            tail[0].value = seq.tail_node();\n                            body.push(make_node(AST_SimpleStatement, node, {\n                                body: make_sequence(seq, seq.expressions.slice(0, -1)),\n                            }));\n                        }\n                        node.definitions = head.concat(tail);\n                        body.push(node);\n                    }\n                    if (side_effects.length > 0) {\n                        body.push(make_node(AST_SimpleStatement, node, { body: make_sequence(node, side_effects) }));\n                    }\n                    return insert_statements(body, node, in_list);\n                }\n                if (node instanceof AST_Assign) {\n                    descend(node, tt);\n                    if (!(node.left instanceof AST_Destructured)) return node;\n                    var trimmed = trim_destructured(node.left, node.right, function(node) {\n                        return node;\n                    }, node.write_only === true);\n                    if (trimmed.name) return make_node(AST_Assign, node, {\n                        operator: node.operator,\n                        left: trimmed.name,\n                        right: trimmed.value,\n                    });\n                    if (trimmed.value) return trimmed.value;\n                    if (parent instanceof AST_Sequence && parent.tail_node() !== node) return List.skip;\n                    return make_node(AST_Number, node, { value: 0 });\n                }\n                if (node instanceof AST_LabeledStatement && node.body instanceof AST_For) {\n                    // Certain combination of unused name + side effect leads to invalid AST:\n                    //    https://github.com/mishoo/UglifyJS/issues/1830\n                    // We fix it at this stage by moving the label inwards, back to the `for`.\n                    descend(node, tt);\n                    if (node.body instanceof AST_BlockStatement) {\n                        var block = node.body;\n                        node.body = block.body.pop();\n                        block.body.push(node);\n                        return in_list ? List.splice(block.body) : block;\n                    }\n                    return node;\n                }\n                if (node instanceof AST_Scope) {\n                    descend_scope();\n                    return node;\n                }\n                if (node instanceof AST_SymbolImport) {\n                    if (!compressor.option(\"imports\") || node.definition().id in in_use_ids) return node;\n                    return in_list ? List.skip : null;\n                }\n\n                function descend_scope() {\n                    var save_scope = scope;\n                    scope = node;\n                    descend(node, tt);\n                    scope = save_scope;\n                }\n            }, function(node, in_list) {\n                if (node instanceof AST_BlockStatement) return trim_block(node, tt.parent(), in_list);\n                if (node instanceof AST_ExportDeclaration) {\n                    var block = node.body;\n                    if (!(block instanceof AST_BlockStatement)) return;\n                    node.body = block.body.pop();\n                    block.body.push(node);\n                    return in_list ? List.splice(block.body) : block;\n                }\n                if (node instanceof AST_For) return patch_for_init(node, in_list);\n                if (node instanceof AST_ForIn) {\n                    if (!drop_vars || !compressor.option(\"loops\")) return;\n                    if (!is_empty(node.body)) return;\n                    var sym = get_init_symbol(node);\n                    if (!sym) return;\n                    var def = sym.definition();\n                    if (def.id in in_use_ids) return;\n                    log(sym, \"Dropping unused loop variable {name}\");\n                    if (for_ins[def.id] === node) delete for_ins[def.id];\n                    var body = [];\n                    var value = node.object.drop_side_effect_free(compressor);\n                    if (value) {\n                        AST_Node.warn(\"Side effects in object of for-in loop [{start}]\", value);\n                        body.push(make_node(AST_SimpleStatement, node, { body: value }));\n                    }\n                    if (node.init instanceof AST_Definitions && def.orig[0] instanceof AST_SymbolCatch) {\n                        body.push(node.init);\n                    }\n                    return insert_statements(body, node, in_list);\n                }\n                if (node instanceof AST_Import) {\n                    if (node.properties && node.properties.length == 0) node.properties = null;\n                    return node;\n                }\n                if (node instanceof AST_Sequence) {\n                    if (node.expressions.length > 1) return;\n                    return maintain_this_binding(tt.parent(), node, node.expressions[0]);\n                }\n            });\n            tt.push(compressor.parent());\n            tt.directives = Object.create(compressor.directives);\n            self.transform(tt);\n            if (self instanceof AST_Lambda\n                && self.body.length == 1\n                && self.body[0] instanceof AST_Directive\n                && self.body[0].value == \"use strict\") {\n                self.body.length = 0;\n            }\n            calls_to_drop_args.forEach(function(call) {\n                drop_unused_call_args(call, compressor, fns_with_marked_args);\n            });\n\n            function log(sym, text) {\n                AST_Node[sym.definition().references.length > 0 ? \"info\" : \"warn\"](text + \" [{start}]\", sym);\n            }\n\n            function log_default(node, text) {\n                if (node.name instanceof AST_SymbolFunarg) {\n                    log(node.name, text);\n                } else {\n                    AST_Node.info(text + \" [{start}]\", node);\n                }\n            }\n\n            function get_rvalue(expr) {\n                return expr[expr instanceof AST_Assign ? \"right\" : \"value\"];\n            }\n\n            function insert_statements(body, orig, in_list) {\n                switch (body.length) {\n                  case 0:\n                    return in_list ? List.skip : make_node(AST_EmptyStatement, orig);\n                  case 1:\n                    return body[0];\n                  default:\n                    return in_list ? List.splice(body) : make_node(AST_BlockStatement, orig, { body: body });\n                }\n            }\n\n            function track_assigns(def, node) {\n                if (def.scope.resolve() !== self) return false;\n                if (!def.fixed || !node.fixed) assign_in_use[def.id] = false;\n                return assign_in_use[def.id] !== false;\n            }\n\n            function add_assigns(def, node) {\n                if (!assign_in_use[def.id]) assign_in_use[def.id] = [];\n                if (node.fixed.assigns) push_uniq(assign_in_use[def.id], node.fixed.assigns);\n            }\n\n            function indexOf_assign(def, node) {\n                var nodes = assign_in_use[def.id];\n                return nodes && nodes.indexOf(node);\n            }\n\n            function unmark_lambda(def) {\n                if (lambda_ids[def.id] > 1 && !(def.id in in_use_ids)) {\n                    in_use_ids[def.id] = true;\n                    in_use.push(def);\n                }\n                lambda_ids[def.id] = 0;\n            }\n\n            function verify_safe_usage(def, read, modified) {\n                if (def.id in in_use_ids) return;\n                if (read && modified) {\n                    in_use_ids[def.id] = read;\n                    in_use.push(def);\n                } else {\n                    value_read[def.id] = read;\n                    value_modified[def.id] = modified;\n                }\n            }\n\n            function can_drop_lhs(sym, node) {\n                var def = sym.definition();\n                var in_use = in_use_ids[def.id];\n                if (!in_use) return true;\n                if (node[node instanceof AST_Assign ? \"left\" : \"expression\"] !== sym) return false;\n                return in_use === sym && def.references.length - def.replaced == 1 || indexOf_assign(def, node) < 0;\n            }\n\n            function get_rhs(assign) {\n                var rhs = assign.right;\n                if (!assign.write_only) return rhs;\n                if (!(rhs instanceof AST_Binary && lazy_op[rhs.operator])) return rhs;\n                if (!(rhs.left instanceof AST_SymbolRef)) return rhs;\n                if (!(assign.left instanceof AST_SymbolRef)) return rhs;\n                var def = assign.left.definition();\n                if (rhs.left.definition() !== def) return rhs;\n                if (rhs.right.has_side_effects(compressor)) return rhs;\n                if (track_assigns(def, rhs.left)) add_assigns(def, rhs.left);\n                return rhs.right;\n            }\n\n            function get_init_symbol(for_in) {\n                var init = for_in.init;\n                if (init instanceof AST_Definitions) {\n                    init = init.definitions[0].name;\n                    return init instanceof AST_SymbolDeclaration && init;\n                }\n                while (init instanceof AST_PropAccess) init = init.expression.tail_node();\n                if (init instanceof AST_SymbolRef) return init;\n            }\n\n            function scan_ref_scoped(node, descend, init) {\n                if (node instanceof AST_Assign && node.left instanceof AST_SymbolRef) {\n                    var def = node.left.definition();\n                    if (def.scope.resolve() === self) assignments.add(def.id, node);\n                }\n                if (node instanceof AST_SymbolRef && node.in_arg) var_defs[node.definition().id] = 0;\n                if (node instanceof AST_Unary && node.expression instanceof AST_SymbolRef) {\n                    var def = node.expression.definition();\n                    if (def.scope.resolve() === self) assignments.add(def.id, node);\n                }\n                var props = [], sym = assign_as_unused(node, props);\n                if (sym) {\n                    var node_def = sym.definition();\n                    if (node_def.scope.resolve() !== self && self.variables.get(sym.name) !== node_def) return;\n                    if (is_arguments(node_def) && !all(self.argnames, function(argname) {\n                        return !argname.match_symbol(function(node) {\n                            if (node instanceof AST_SymbolFunarg) {\n                                var def = node.definition();\n                                return def.references.length > def.replaced;\n                            }\n                        }, true);\n                    })) return;\n                    if (node.write_only === \"p\" && node.right.may_throw_on_access(compressor, true)) return;\n                    var assign = props.assign;\n                    if (assign) {\n                        assign.write_only = true;\n                        assign.walk(tw);\n                    }\n                    props.forEach(function(prop) {\n                        prop.walk(tw);\n                    });\n                    if (node instanceof AST_Assign) {\n                        var right = get_rhs(node), shared = false;\n                        if (init && node.write_only === true && !right.has_side_effects(compressor)) {\n                            initializations.add(node_def.id, right);\n                        } else {\n                            right.walk(tw);\n                            shared = right.tail_node().operator == \"=\";\n                        }\n                        if (node.left === sym) {\n                            if (!node.write_only || shared) {\n                                verify_safe_usage(node_def, sym, value_modified[node_def.id]);\n                            }\n                        } else {\n                            var fixed = sym.fixed_value();\n                            if (!fixed || !fixed.is_constant()) {\n                                verify_safe_usage(node_def, value_read[node_def.id], true);\n                            }\n                        }\n                    }\n                    if (track_assigns(node_def, sym) && is_lhs(sym, node) !== sym) add_assigns(node_def, sym);\n                    unmark_lambda(node_def);\n                    return true;\n                }\n                if (node instanceof AST_Binary) {\n                    if (node.operator != \"instanceof\") return;\n                    var sym = node.right;\n                    if (!(sym instanceof AST_SymbolRef)) return;\n                    var id = sym.definition().id;\n                    if (!lambda_ids[id]) return;\n                    node.left.walk(tw);\n                    lambda_ids[id]++;\n                    return true;\n                }\n                if (node instanceof AST_ForIn) {\n                    if (node.init instanceof AST_SymbolRef && scope === self) {\n                        var id = node.init.definition().id;\n                        if (!(id in for_ins)) for_ins[id] = node;\n                    }\n                    if (!drop_vars || !compressor.option(\"loops\")) return;\n                    if (!is_empty(node.body)) return;\n                    if (node.init.has_side_effects(compressor)) return;\n                    var sym = get_init_symbol(node);\n                    if (!sym) return;\n                    var def = sym.definition();\n                    if (def.scope.resolve() !== self) {\n                        var d = find_variable(sym.name);\n                        if (d === def || d && d.redefined() === def) return;\n                    }\n                    node.object.walk(tw);\n                    return true;\n                }\n                if (node instanceof AST_SymbolRef) {\n                    var node_def = node.definition();\n                    if (!(node_def.id in in_use_ids)) {\n                        in_use_ids[node_def.id] = true;\n                        in_use.push(node_def);\n                    }\n                    if (cross_scope(node_def.scope, node.scope)) {\n                        var redef = node_def.redefined();\n                        if (redef && !(redef.id in in_use_ids)) {\n                            in_use_ids[redef.id] = true;\n                            in_use.push(redef);\n                        }\n                    }\n                    if (track_assigns(node_def, node)) add_assigns(node_def, node);\n                    return true;\n                }\n                if (node instanceof AST_Scope) {\n                    var save_scope = scope;\n                    scope = node;\n                    descend();\n                    scope = save_scope;\n                    return true;\n                }\n            }\n\n            function is_decl(node) {\n                return (node instanceof AST_DefaultValue ? node.name : node) instanceof AST_SymbolDeclaration;\n            }\n\n            function trim_decl(node) {\n                if (node.definition().id in in_use_ids) return node;\n                if (node instanceof AST_SymbolFunarg) node.unused = true;\n                return null;\n            }\n\n            function trim_default(trimmer, node) {\n                node.value = node.value.transform(tt);\n                var name = node.name.transform(trimmer);\n                if (!name) {\n                    if (node.name instanceof AST_Destructured) return null;\n                    var value = node.value.drop_side_effect_free(compressor);\n                    if (!value) return null;\n                    log(node.name, \"Side effects in default value of unused variable {name}\");\n                    node = node.clone();\n                    node.name.unused = null;\n                    node.value = value;\n                }\n                return node;\n            }\n\n            function trim_destructured(node, value, process, drop, root) {\n                var trimmer = new TreeTransformer(function(node) {\n                    if (node instanceof AST_DefaultValue) {\n                        if (!(compressor.option(\"default_values\") && value && value.is_defined(compressor))) {\n                            var save_drop = drop;\n                            drop = false;\n                            var trimmed = trim_default(trimmer, node);\n                            drop = save_drop;\n                            if (!trimmed && drop && value) value = value.drop_side_effect_free(compressor);\n                            return trimmed;\n                        } else if (node === root) {\n                            root = node = node.name;\n                        } else {\n                            node = node.name;\n                        }\n                    }\n                    if (node instanceof AST_DestructuredArray) {\n                        var save_drop = drop;\n                        var save_value = value;\n                        if (value instanceof AST_SymbolRef) {\n                            drop = false;\n                            value = value.fixed_value();\n                        }\n                        var native, values;\n                        if (value instanceof AST_Array) {\n                            native = true;\n                            values = value.elements;\n                        } else {\n                            native = value && value.is_string(compressor);\n                            values = false;\n                        }\n                        var elements = [], newValues = drop && [], pos = 0;\n                        node.elements.forEach(function(element, index) {\n                            value = values && values[index];\n                            if (value instanceof AST_Hole) {\n                                value = null;\n                            } else if (value instanceof AST_Spread) {\n                                if (drop) {\n                                    newValues.length = pos;\n                                    fill_holes(save_value, newValues);\n                                    [].push.apply(newValues, values.slice(index));\n                                    save_value.elements = newValues;\n                                }\n                                value = values = false;\n                            }\n                            element = element.transform(trimmer);\n                            if (element) elements[pos] = element;\n                            if (drop && value) newValues[pos] = value;\n                            if (element || value || !drop || !values) pos++;\n                        });\n                        value = values && make_node(AST_Array, save_value, {\n                            elements: values.slice(node.elements.length),\n                        });\n                        if (node.rest) {\n                            var was_drop = drop;\n                            drop = false;\n                            node.rest = node.rest.transform(compressor.option(\"rests\") ? trimmer : tt);\n                            drop = was_drop;\n                            if (node.rest) elements.length = pos;\n                        }\n                        if (drop) {\n                            if (value && !node.rest) value = value.drop_side_effect_free(compressor);\n                            if (value instanceof AST_Array) {\n                                value = value.elements;\n                            } else if (value instanceof AST_Sequence) {\n                                value = value.expressions;\n                            } else if (value) {\n                                value = [ value ];\n                            }\n                            if (value && value.length) {\n                                newValues.length = pos;\n                                [].push.apply(newValues, value);\n                            }\n                        }\n                        value = save_value;\n                        drop = save_drop;\n                        if (values && newValues) {\n                            fill_holes(value, newValues);\n                            value = value.clone();\n                            value.elements = newValues;\n                        }\n                        if (!native) {\n                            elements.length = node.elements.length;\n                        } else if (!node.rest) switch (elements.length) {\n                          case 0:\n                            if (node === root) break;\n                            if (drop) value = value.drop_side_effect_free(compressor);\n                            return null;\n                          case 1:\n                            if (!drop) break;\n                            if (node === root) break;\n                            var sym = elements[0];\n                            if (sym.has_side_effects(compressor)) break;\n                            if (value.has_side_effects(compressor) && sym.match_symbol(function(node) {\n                                return node instanceof AST_PropAccess;\n                            })) break;\n                            value = make_node(AST_Sub, node, {\n                                expression: value,\n                                property: make_node(AST_Number, node, { value: 0 }),\n                            });\n                            return sym;\n                        }\n                        fill_holes(node, elements);\n                        node.elements = elements;\n                        return node;\n                    }\n                    if (node instanceof AST_DestructuredObject) {\n                        var save_drop = drop;\n                        var save_value = value;\n                        if (value instanceof AST_SymbolRef) {\n                            drop = false;\n                            value = value.fixed_value();\n                        }\n                        var prop_keys, prop_map, values;\n                        if (value instanceof AST_Object) {\n                            prop_keys = [];\n                            prop_map = new Dictionary();\n                            values = value.properties.map(function(prop, index) {\n                                prop = prop.clone();\n                                if (prop instanceof AST_Spread) {\n                                    prop_map = false;\n                                } else {\n                                    var key = prop.key;\n                                    if (key instanceof AST_Node) key = key.evaluate(compressor, true);\n                                    if (key instanceof AST_Node) {\n                                        prop_map = false;\n                                    } else if (prop_map && !(prop instanceof AST_ObjectSetter)) {\n                                        prop_map.set(key, prop);\n                                    }\n                                    prop_keys[index] = key;\n                                }\n                                return prop;\n                            });\n                        }\n                        if (node.rest) {\n                            value = false;\n                            node.rest = node.rest.transform(compressor.option(\"rests\") ? trimmer : tt);\n                        }\n                        var can_drop = new Dictionary();\n                        var drop_keys = drop && new Dictionary();\n                        var properties = [];\n                        node.properties.map(function(prop) {\n                            var key = prop.key;\n                            if (key instanceof AST_Node) {\n                                prop.key = key = key.transform(tt);\n                                key = key.evaluate(compressor, true);\n                            }\n                            if (key instanceof AST_Node) {\n                                drop_keys = false;\n                            } else {\n                                can_drop.set(key, !can_drop.has(key));\n                            }\n                            return key;\n                        }).forEach(function(key, index) {\n                            var prop = node.properties[index], trimmed;\n                            if (key instanceof AST_Node) {\n                                drop = false;\n                                value = false;\n                                trimmed = prop.value.transform(trimmer) || retain_lhs(prop.value);\n                            } else {\n                                drop = drop_keys && can_drop.get(key);\n                                var mapped = prop_map && prop_map.get(key);\n                                if (mapped) {\n                                    value = mapped.value;\n                                    if (value instanceof AST_Accessor) value = false;\n                                } else {\n                                    value = false;\n                                }\n                                trimmed = prop.value.transform(trimmer);\n                                if (!trimmed) {\n                                    if (node.rest || retain_key(prop)) trimmed = retain_lhs(prop.value);\n                                    if (drop_keys && !drop_keys.has(key)) {\n                                        if (mapped) {\n                                            drop_keys.set(key, mapped);\n                                            if (value === null) {\n                                                prop_map.set(key, retain_key(mapped) && make_node(AST_ObjectKeyVal, mapped, {\n                                                    key: mapped.key,\n                                                    value: make_node(AST_Number, mapped, { value: 0 }),\n                                                }));\n                                            }\n                                        } else {\n                                            drop_keys.set(key, true);\n                                        }\n                                    }\n                                } else if (drop_keys) {\n                                    drop_keys.set(key, false);\n                                }\n                                if (value) mapped.value = value;\n                            }\n                            if (trimmed) {\n                                prop.value = trimmed;\n                                properties.push(prop);\n                            }\n                        });\n                        value = save_value;\n                        drop = save_drop;\n                        if (drop_keys && prop_keys) {\n                            value = value.clone();\n                            value.properties = List(values, function(prop, index) {\n                                if (prop instanceof AST_Spread) return prop;\n                                var key = prop_keys[index];\n                                if (key instanceof AST_Node) return prop;\n                                if (drop_keys.has(key)) {\n                                    var mapped = drop_keys.get(key);\n                                    if (!mapped) return prop;\n                                    if (mapped === prop) return prop_map.get(key) || List.skip;\n                                } else if (node.rest) {\n                                    return prop;\n                                }\n                                var trimmed = prop.value.drop_side_effect_free(compressor);\n                                if (trimmed) {\n                                    prop.value = trimmed;\n                                    return prop;\n                                }\n                                return retain_key(prop) ? make_node(AST_ObjectKeyVal, prop, {\n                                    key: prop.key,\n                                    value: make_node(AST_Number, prop, { value: 0 }),\n                                }) : List.skip;\n                            });\n                        }\n                        if (value && !node.rest) switch (properties.length) {\n                          case 0:\n                            if (node === root) break;\n                            if (value.may_throw_on_access(compressor, true)) break;\n                            if (drop) value = value.drop_side_effect_free(compressor);\n                            return null;\n                          case 1:\n                            if (!drop) break;\n                            if (node === root) break;\n                            var prop = properties[0];\n                            if (prop.key instanceof AST_Node) break;\n                            if (prop.value.has_side_effects(compressor)) break;\n                            if (value.has_side_effects(compressor) && prop.value.match_symbol(function(node) {\n                                return node instanceof AST_PropAccess;\n                            })) break;\n                            value = make_node(AST_Sub, node, {\n                                expression: value,\n                                property: make_node_from_constant(prop.key, prop),\n                            });\n                            return prop.value;\n                        }\n                        node.properties = properties;\n                        return node;\n                    }\n                    if (node instanceof AST_Hole) {\n                        node = null;\n                    } else {\n                        node = process(node);\n                    }\n                    if (!node && drop && value) value = value.drop_side_effect_free(compressor);\n                    return node;\n                });\n                return {\n                    name: node.transform(trimmer),\n                    value: value,\n                };\n\n                function retain_key(prop) {\n                    return prop.key instanceof AST_Node && prop.key.has_side_effects(compressor);\n                }\n\n                function clear_write_only(node) {\n                    if (node instanceof AST_Assign) {\n                        node.write_only = false;\n                        clear_write_only(node.right);\n                    } else if (node instanceof AST_Binary) {\n                        if (!lazy_op[node.operator]) return;\n                        clear_write_only(node.left);\n                        clear_write_only(node.right);\n                    } else if (node instanceof AST_Conditional) {\n                        clear_write_only(node.consequent);\n                        clear_write_only(node.alternative);\n                    } else if (node instanceof AST_Sequence) {\n                        clear_write_only(node.tail_node());\n                    } else if (node instanceof AST_Unary) {\n                        node.write_only = false;\n                    }\n                }\n\n                function retain_lhs(node) {\n                    if (node instanceof AST_DefaultValue) return retain_lhs(node.name);\n                    if (node instanceof AST_Destructured) {\n                        if (value === null) {\n                            value = make_node(AST_Number, node, { value: 0 });\n                        } else if (value) {\n                            if (value.may_throw_on_access(compressor, true)) {\n                                value = make_node(AST_Array, node, {\n                                    elements: value instanceof AST_Sequence ? value.expressions : [ value ],\n                                });\n                            } else {\n                                clear_write_only(value);\n                            }\n                        }\n                        return make_node(AST_DestructuredObject, node, { properties: [] });\n                    }\n                    node.unused = null;\n                    return node;\n                }\n            }\n        });\n\n        AST_Scope.DEFMETHOD(\"hoist_declarations\", function(compressor) {\n            if (compressor.has_directive(\"use asm\")) return;\n            var hoist_funs = compressor.option(\"hoist_funs\");\n            var hoist_vars = compressor.option(\"hoist_vars\");\n            var self = this;\n            if (hoist_vars) {\n                // let's count var_decl first, we seem to waste a lot of\n                // space if we hoist `var` when there's only one.\n                var var_decl = 0;\n                self.walk(new TreeWalker(function(node) {\n                    if (var_decl > 1) return true;\n                    if (node instanceof AST_ExportDeclaration) return true;\n                    if (node instanceof AST_Scope && node !== self) return true;\n                    if (node instanceof AST_Var) {\n                        var_decl++;\n                        return true;\n                    }\n                }));\n                if (var_decl <= 1) hoist_vars = false;\n            }\n            if (!hoist_funs && !hoist_vars) return;\n            var consts = new Dictionary();\n            var dirs = [];\n            var hoisted = [];\n            var vars = new Dictionary();\n            var tt = new TreeTransformer(function(node, descend, in_list) {\n                if (node === self) return;\n                if (node instanceof AST_Directive) {\n                    dirs.push(node);\n                    return in_list ? List.skip : make_node(AST_EmptyStatement, node);\n                }\n                if (node instanceof AST_LambdaDefinition) {\n                    if (!hoist_funs) return node;\n                    var p = tt.parent();\n                    if (p instanceof AST_ExportDeclaration) return node;\n                    if (p instanceof AST_ExportDefault) return node;\n                    if (p !== self && compressor.has_directive(\"use strict\")) return node;\n                    hoisted.push(node);\n                    return in_list ? List.skip : make_node(AST_EmptyStatement, node);\n                }\n                if (node instanceof AST_Var) {\n                    if (!hoist_vars) return node;\n                    var p = tt.parent();\n                    if (p instanceof AST_ExportDeclaration) return node;\n                    if (!all(node.definitions, function(defn) {\n                        var sym = defn.name;\n                        return sym instanceof AST_SymbolVar\n                            && !consts.has(sym.name)\n                            && self.find_variable(sym.name) === sym.definition();\n                    })) return node;\n                    node.definitions.forEach(function(defn) {\n                        vars.set(defn.name.name, defn);\n                    });\n                    var seq = node.to_assignments();\n                    if (p instanceof AST_ForEnumeration && p.init === node) {\n                        if (seq) return seq;\n                        var sym = node.definitions[0].name;\n                        return make_node(AST_SymbolRef, sym);\n                    }\n                    if (p instanceof AST_For && p.init === node) return seq;\n                    if (!seq) return in_list ? List.skip : make_node(AST_EmptyStatement, node);\n                    return make_node(AST_SimpleStatement, node, { body: seq });\n                }\n                if (node instanceof AST_Scope) return node;\n                if (node instanceof AST_SymbolConst) {\n                    consts.set(node.name, true);\n                    return node;\n                }\n            });\n            self.transform(tt);\n            if (vars.size() > 0) {\n                // collect only vars which don't show up in self's arguments list\n                var defns = [];\n                if (self instanceof AST_Lambda) self.each_argname(function(argname) {\n                    if (all(argname.definition().references, function(ref) {\n                        return !ref.in_arg;\n                    })) vars.del(argname.name);\n                });\n                vars.each(function(defn, name) {\n                    defn = defn.clone();\n                    defn.name = defn.name.clone();\n                    defn.value = null;\n                    defns.push(defn);\n                    vars.set(name, defn);\n                    defn.name.definition().orig.unshift(defn.name);\n                });\n                if (defns.length > 0) hoisted.push(make_node(AST_Var, self, { definitions: defns }));\n            }\n            self.body = dirs.concat(hoisted, self.body);\n        });\n\n        function scan_local_returns(fn, transform) {\n            fn.walk(new TreeWalker(function(node) {\n                if (node instanceof AST_Return) {\n                    transform(node);\n                    return true;\n                }\n                if (node instanceof AST_Scope && node !== fn) return true;\n            }));\n        }\n\n        function map_self_returns(fn) {\n            var map = Object.create(null);\n            scan_local_returns(fn, function(node) {\n                var value = node.value;\n                if (value) value = value.tail_node();\n                if (value instanceof AST_SymbolRef) {\n                    var id = value.definition().id;\n                    map[id] = (map[id] || 0) + 1;\n                }\n            });\n            return map;\n        }\n\n        function can_trim_returns(def, self_returns, compressor) {\n            if (compressor.exposed(def)) return false;\n            switch (def.references.length - def.replaced - (self_returns[def.id] || 0)) {\n              case def.drop_return:\n                return \"d\";\n              case def.bool_return:\n                return true;\n            }\n        }\n\n        function process_boolean_returns(fn, compressor) {\n            scan_local_returns(fn, function(node) {\n                node.in_bool = true;\n                var value = node.value;\n                if (value) {\n                    var ev = fuzzy_eval(compressor, value);\n                    if (!ev) {\n                        value = value.drop_side_effect_free(compressor);\n                        node.value = value ? make_sequence(node.value, [\n                            value,\n                            make_node(AST_Number, node.value, { value: 0 }),\n                        ]) : null;\n                    } else if (!(ev instanceof AST_Node)) {\n                        value = value.drop_side_effect_free(compressor);\n                        node.value = value ? make_sequence(node.value, [\n                            value,\n                            make_node(AST_Number, node.value, { value: 1 }),\n                        ]) : make_node(AST_Number, node.value, { value: 1 });\n                    }\n                }\n            });\n        }\n\n        AST_Scope.DEFMETHOD(\"process_returns\", noop);\n        AST_Defun.DEFMETHOD(\"process_returns\", function(compressor) {\n            if (!compressor.option(\"booleans\")) return;\n            if (compressor.parent() instanceof AST_ExportDefault) return;\n            switch (can_trim_returns(this.name.definition(), map_self_returns(this), compressor)) {\n              case \"d\":\n                drop_returns(compressor, this, true);\n                break;\n              case true:\n                process_boolean_returns(this, compressor);\n                break;\n            }\n        });\n        AST_Function.DEFMETHOD(\"process_returns\", function(compressor) {\n            if (!compressor.option(\"booleans\")) return;\n            var drop = true;\n            var self_returns = map_self_returns(this);\n            if (this.name && !can_trim(this.name.definition())) return;\n            var parent = compressor.parent();\n            if (parent instanceof AST_Assign) {\n                if (parent.operator != \"=\") return;\n                var sym = parent.left;\n                if (!(sym instanceof AST_SymbolRef)) return;\n                if (!can_trim(sym.definition())) return;\n            } else if (parent instanceof AST_Call && parent.expression !== this) {\n                var exp = parent.expression;\n                if (exp instanceof AST_SymbolRef) exp = exp.fixed_value();\n                if (!(exp instanceof AST_Lambda)) return;\n                if (exp.uses_arguments || exp.pinned()) return;\n                var args = parent.args, sym;\n                for (var i = 0; i < args.length; i++) {\n                    var arg = args[i];\n                    if (arg === this) {\n                        sym = exp.argnames[i];\n                        if (!sym && exp.rest) return;\n                        break;\n                    }\n                    if (arg instanceof AST_Spread) return;\n                }\n                if (sym instanceof AST_DefaultValue) sym = sym.name;\n                if (sym instanceof AST_SymbolFunarg && !can_trim(sym.definition())) return;\n            } else if (parent.TYPE == \"Call\") {\n                compressor.pop();\n                var in_bool = compressor.in_boolean_context();\n                compressor.push(this);\n                switch (in_bool) {\n                  case true:\n                    drop = false;\n                  case \"d\":\n                    break;\n                  default:\n                    return;\n                }\n            } else return;\n            if (drop) {\n                drop_returns(compressor, this, true);\n            } else {\n                process_boolean_returns(this, compressor);\n            }\n\n            function can_trim(def) {\n                switch (can_trim_returns(def, self_returns, compressor)) {\n                  case true:\n                    drop = false;\n                  case \"d\":\n                    return true;\n                }\n            }\n        });\n\n        AST_BlockScope.DEFMETHOD(\"var_names\", function() {\n            var var_names = this._var_names;\n            if (!var_names) {\n                this._var_names = var_names = new Dictionary();\n                this.enclosed.forEach(function(def) {\n                    var_names.set(def.name, true);\n                });\n                this.variables.each(function(def, name) {\n                    var_names.set(name, true);\n                });\n            }\n            return var_names;\n        });\n\n        AST_Scope.DEFMETHOD(\"make_var\", function(type, orig, prefix) {\n            var scopes = [ this ];\n            if (orig instanceof AST_SymbolDeclaration) orig.definition().references.forEach(function(ref) {\n                var s = ref.scope;\n                do {\n                    if (!push_uniq(scopes, s)) return;\n                    s = s.parent_scope;\n                } while (s && s !== this);\n            });\n            prefix = prefix.replace(/^[^a-z_$]|[^a-z0-9_$]/gi, \"_\");\n            var name = prefix;\n            for (var i = 0; !all(scopes, function(scope) {\n                return !scope.var_names().has(name);\n            }); i++) name = prefix + \"$\" + i;\n            var sym = make_node(type, orig, {\n                name: name,\n                scope: this,\n            });\n            var def = this.def_variable(sym);\n            scopes.forEach(function(scope) {\n                scope.enclosed.push(def);\n                scope.var_names().set(name, true);\n            });\n            return sym;\n        });\n\n        AST_Scope.DEFMETHOD(\"hoist_properties\", function(compressor) {\n            if (!compressor.option(\"hoist_props\") || compressor.has_directive(\"use asm\")) return;\n            var self = this;\n            if (is_arrow(self) && self.value) return;\n            var top_retain = self instanceof AST_Toplevel && compressor.top_retain || return_false;\n            var defs_by_id = Object.create(null);\n            var tt = new TreeTransformer(function(node, descend) {\n                if (node instanceof AST_Assign) {\n                    if (node.operator != \"=\") return;\n                    if (!node.write_only) return;\n                    if (!can_hoist(node.left, node.right, 1)) return;\n                    descend(node, tt);\n                    var defs = new Dictionary();\n                    var assignments = [];\n                    var decls = [];\n                    node.right.properties.forEach(function(prop) {\n                        var decl = make_sym(AST_SymbolVar, node.left, prop.key);\n                        decls.push(make_node(AST_VarDef, node, {\n                            name: decl,\n                            value: null,\n                        }));\n                        var sym = make_node(AST_SymbolRef, node, {\n                            name: decl.name,\n                            scope: self,\n                            thedef: decl.definition(),\n                        });\n                        sym.reference();\n                        assignments.push(make_node(AST_Assign, node, {\n                            operator: \"=\",\n                            left: sym,\n                            right: prop.value,\n                        }));\n                    });\n                    defs.value = node.right;\n                    defs_by_id[node.left.definition().id] = defs;\n                    self.body.splice(self.body.indexOf(tt.stack[1]) + 1, 0, make_node(AST_Var, node, {\n                        definitions: decls,\n                    }));\n                    return make_sequence(node, assignments);\n                }\n                if (node instanceof AST_Scope) {\n                    if (node === self) return;\n                    var parent = tt.parent();\n                    if (parent.TYPE == \"Call\" && parent.expression === node) return;\n                    return node;\n                }\n                if (node instanceof AST_VarDef) {\n                    if (!can_hoist(node.name, node.value, 0)) return;\n                    descend(node, tt);\n                    var defs = new Dictionary();\n                    var var_defs = [];\n                    var decl = node.clone();\n                    decl.value = node.name instanceof AST_SymbolConst ? make_node(AST_Number, node, { value: 0 }) : null;\n                    var_defs.push(decl);\n                    node.value.properties.forEach(function(prop) {\n                        var_defs.push(make_node(AST_VarDef, node, {\n                            name: make_sym(node.name.CTOR, node.name, prop.key),\n                            value: prop.value,\n                        }));\n                    });\n                    defs.value = node.value;\n                    defs_by_id[node.name.definition().id] = defs;\n                    return List.splice(var_defs);\n                }\n\n                function make_sym(type, sym, key) {\n                    var new_var = self.make_var(type, sym, sym.name + \"_\" + key);\n                    defs.set(key, new_var.definition());\n                    return new_var;\n                }\n            });\n            self.transform(tt);\n            self.transform(new TreeTransformer(function(node, descend) {\n                if (node instanceof AST_PropAccess) {\n                    if (!(node.expression instanceof AST_SymbolRef)) return;\n                    var defs = defs_by_id[node.expression.definition().id];\n                    if (!defs) return;\n                    if (node.expression.fixed_value() !== defs.value) return;\n                    var def = defs.get(node.get_property());\n                    var sym = make_node(AST_SymbolRef, node, {\n                        name: def.name,\n                        scope: node.expression.scope,\n                        thedef: def,\n                    });\n                    sym.reference();\n                    return sym;\n                }\n                if (node instanceof AST_SymbolRef) {\n                    var defs = defs_by_id[node.definition().id];\n                    if (!defs) return;\n                    if (node.fixed_value() !== defs.value) return;\n                    return make_node(AST_Object, node, { properties: [] });\n                }\n            }));\n\n            function can_hoist(sym, right, count) {\n                if (!(sym instanceof AST_Symbol)) return;\n                var def = sym.definition();\n                if (def.assignments != count) return;\n                if (def.references.length - def.replaced == count) return;\n                if (def.single_use) return;\n                if (self.find_variable(sym.name) !== def) return;\n                if (top_retain(def)) return;\n                if (sym.fixed_value() !== right) return;\n                var fixed = sym.fixed || def.fixed;\n                if (fixed.direct_access) return;\n                if (fixed.escaped && fixed.escaped.depth == 1) return;\n                return right instanceof AST_Object\n                    && right.properties.length > 0\n                    && can_drop_symbol(sym, compressor)\n                    && all(right.properties, function(prop) {\n                        return can_hoist_property(prop) && prop.key !== \"__proto__\";\n                    });\n            }\n        });\n\n        function fn_name_unused(fn, compressor) {\n            if (!fn.name || !compressor.option(\"ie\")) return true;\n            var def = fn.name.definition();\n            if (compressor.exposed(def)) return false;\n            return all(def.references, function(sym) {\n                return !(sym instanceof AST_SymbolRef);\n            });\n        }\n\n        function drop_returns(compressor, exp, ignore_name) {\n            if (!(exp instanceof AST_Lambda)) return;\n            var arrow = is_arrow(exp);\n            var async = is_async(exp);\n            var changed = false;\n            var drop_body = false;\n            if (arrow && compressor.option(\"arrows\")) {\n                if (!exp.value) {\n                    drop_body = true;\n                } else if (!async || needs_enqueuing(compressor, exp.value)) {\n                    var dropped = exp.value.drop_side_effect_free(compressor);\n                    if (dropped !== exp.value) {\n                        changed = true;\n                        exp.value = dropped;\n                    }\n                }\n            } else if (!is_generator(exp)) {\n                if (!ignore_name && exp.name) {\n                    var def = exp.name.definition();\n                    drop_body = def.references.length == def.replaced;\n                } else {\n                    drop_body = true;\n                }\n            }\n            if (drop_body) {\n                exp.process_expression(false, function(node) {\n                    var value = node.value;\n                    if (value) {\n                        if (async && !needs_enqueuing(compressor, value)) return node;\n                        value = value.drop_side_effect_free(compressor, true);\n                    }\n                    changed = true;\n                    if (!value) return make_node(AST_EmptyStatement, node);\n                    return make_node(AST_SimpleStatement, node, { body: value });\n                });\n                scan_local_returns(exp, function(node) {\n                    var value = node.value;\n                    if (value) {\n                        if (async && !needs_enqueuing(compressor, value)) return;\n                        var dropped = value.drop_side_effect_free(compressor);\n                        if (dropped !== value) {\n                            changed = true;\n                            if (dropped && async && !needs_enqueuing(compressor, dropped)) {\n                                dropped = dropped.negate(compressor);\n                            }\n                            node.value = dropped;\n                        }\n                    }\n                });\n            }\n            if (async && compressor.option(\"awaits\")) {\n                if (drop_body) exp.process_expression(\"awaits\", function(node) {\n                    var body = node.body;\n                    if (body instanceof AST_Await) {\n                        if (needs_enqueuing(compressor, body.expression)) {\n                            changed = true;\n                            body = body.expression.drop_side_effect_free(compressor, true);\n                            if (!body) return make_node(AST_EmptyStatement, node);\n                            node.body = body;\n                        }\n                    } else if (body instanceof AST_Sequence) {\n                        var exprs = body.expressions;\n                        for (var i = exprs.length; --i >= 0;) {\n                            var tail = exprs[i];\n                            if (!(tail instanceof AST_Await)) break;\n                            var value = tail.expression;\n                            if (!needs_enqueuing(compressor, value)) break;\n                            changed = true;\n                            if (exprs[i] = value.drop_side_effect_free(compressor)) break;\n                        }\n                        switch (i) {\n                          case -1:\n                            return make_node(AST_EmptyStatement, node);\n                          case 0:\n                            node.body = exprs[0];\n                            break;\n                          default:\n                            exprs.length = i + 1;\n                            break;\n                        }\n                    }\n                    return node;\n                });\n                var abort = !drop_body && exp.name || arrow && exp.value && !needs_enqueuing(compressor, exp.value);\n                var tw = new TreeWalker(function(node) {\n                    if (abort) return true;\n                    if (tw.parent() === exp && node.may_throw(compressor)) return abort = true;\n                    if (node instanceof AST_Await) return abort = true;\n                    if (node instanceof AST_ForAwaitOf) return abort = true;\n                    if (node instanceof AST_Return) {\n                        if (node.value && !needs_enqueuing(compressor, node.value)) return abort = true;\n                        return;\n                    }\n                    if (node instanceof AST_Scope && node !== exp) return true;\n                });\n                exp.walk(tw);\n                if (!abort) {\n                    var ctor;\n                    switch (exp.CTOR) {\n                      case AST_AsyncArrow:\n                        ctor = AST_Arrow;\n                        break;\n                      case AST_AsyncFunction:\n                        ctor = AST_Function;\n                        break;\n                      case AST_AsyncGeneratorFunction:\n                        ctor = AST_GeneratorFunction;\n                        break;\n                    }\n                    return make_node(ctor, exp);\n                }\n            }\n            return changed && exp.clone();\n        }\n\n        // drop_side_effect_free()\n        // remove side-effect-free parts which only affects return value\n        (function(def) {\n            // Drop side-effect-free elements from an array of expressions.\n            // Returns an array of expressions with side-effects or null\n            // if all elements were dropped. Note: original array may be\n            // returned if nothing changed.\n            function trim(nodes, compressor, first_in_statement, spread) {\n                var len = nodes.length;\n                var ret = [], changed = false;\n                for (var i = 0; i < len; i++) {\n                    var node = nodes[i];\n                    var trimmed;\n                    if (spread && node instanceof AST_Spread) {\n                        trimmed = spread(node, compressor, first_in_statement);\n                    } else {\n                        trimmed = node.drop_side_effect_free(compressor, first_in_statement);\n                    }\n                    if (trimmed !== node) changed = true;\n                    if (trimmed) {\n                        ret.push(trimmed);\n                        first_in_statement = false;\n                    }\n                }\n                return ret.length ? changed ? ret : nodes : null;\n            }\n            function array_spread(node, compressor, first_in_statement) {\n                var exp = node.expression;\n                if (!exp.is_string(compressor)) return node;\n                return exp.drop_side_effect_free(compressor, first_in_statement);\n            }\n            function convert_spread(node) {\n                return node instanceof AST_Spread ? make_node(AST_Array, node, { elements: [ node ] }) : node;\n            }\n            def(AST_Node, return_this);\n            def(AST_Accessor, return_null);\n            def(AST_Array, function(compressor, first_in_statement) {\n                var values = trim(this.elements, compressor, first_in_statement, array_spread);\n                if (!values) return null;\n                if (values === this.elements && all(values, function(node) {\n                    return node instanceof AST_Spread;\n                })) return this;\n                return make_sequence(this, values.map(convert_spread));\n            });\n            def(AST_Assign, function(compressor) {\n                var left = this.left;\n                if (left instanceof AST_PropAccess) {\n                    var expr = left.expression;\n                    if (expr.may_throw_on_access(compressor, true)) return this;\n                    if (compressor.has_directive(\"use strict\") && expr.is_constant()) return this;\n                }\n                if (left.has_side_effects(compressor)) return this;\n                if (lazy_op[this.operator.slice(0, -1)]) return this;\n                this.write_only = true;\n                if (!root_expr(left).is_constant_expression(compressor.find_parent(AST_Scope))) return this;\n                return this.right.drop_side_effect_free(compressor);\n            });\n            def(AST_Await, function(compressor) {\n                if (!compressor.option(\"awaits\")) return this;\n                var exp = this.expression;\n                if (!needs_enqueuing(compressor, exp)) return this;\n                if (exp instanceof AST_UnaryPrefix && exp.operator == \"!\") exp = exp.expression;\n                var dropped = exp.drop_side_effect_free(compressor);\n                if (dropped === exp) return this;\n                if (!dropped) {\n                    dropped = make_node(AST_Number, exp, { value: 0 });\n                } else if (!needs_enqueuing(compressor, dropped)) {\n                    dropped = dropped.negate(compressor);\n                }\n                var node = this.clone();\n                node.expression = dropped;\n                return node;\n            });\n            def(AST_Binary, function(compressor, first_in_statement) {\n                var left = this.left;\n                var right = this.right;\n                var op = this.operator;\n                if (!can_drop_op(op, right, compressor)) {\n                    var lhs = left.drop_side_effect_free(compressor, first_in_statement);\n                    if (lhs === left) return this;\n                    var node = this.clone();\n                    node.left = lhs || make_node(AST_Number, left, { value: 0 });\n                    return node;\n                }\n                var rhs = right.drop_side_effect_free(compressor, first_in_statement);\n                if (!rhs) return left.drop_side_effect_free(compressor, first_in_statement);\n                if (lazy_op[op] && rhs.has_side_effects(compressor)) {\n                    var node = this;\n                    if (rhs !== right) {\n                        node = node.clone();\n                        node.right = rhs.drop_side_effect_free(compressor);\n                    }\n                    if (op == \"??\") return node;\n                    var negated = node.clone();\n                    negated.operator = op == \"&&\" ? \"||\" : \"&&\";\n                    negated.left = left.negate(compressor, first_in_statement);\n                    var negated_rhs = negated.right.tail_node();\n                    if (negated_rhs instanceof AST_Binary && negated.operator == negated_rhs.operator) swap_chain(negated);\n                    var best = first_in_statement ? best_of_statement : best_of_expression;\n                    return op == \"&&\" ? best(node, negated) : best(negated, node);\n                }\n                var lhs = left.drop_side_effect_free(compressor, first_in_statement);\n                if (!lhs) return rhs;\n                rhs = rhs.drop_side_effect_free(compressor);\n                if (!rhs) return lhs;\n                return make_sequence(this, [ lhs, rhs ]);\n            });\n            function assign_this_only(fn, compressor) {\n                fn.new = true;\n                var result = all(fn.body, function(stat) {\n                    return !stat.has_side_effects(compressor);\n                }) && all(fn.argnames, function(argname) {\n                    return !argname.match_symbol(return_false);\n                }) && !(fn.rest && fn.rest.match_symbol(return_false));\n                fn.new = false;\n                return result;\n            }\n            def(AST_Call, function(compressor, first_in_statement) {\n                var self = this;\n                if (self.is_expr_pure(compressor)) {\n                    if (self.pure) AST_Node.warn(\"Dropping __PURE__ call [{start}]\", self);\n                    var args = trim(self.args, compressor, first_in_statement, array_spread);\n                    return args && make_sequence(self, args.map(convert_spread));\n                }\n                var exp = self.expression;\n                if (self.is_call_pure(compressor)) {\n                    var exprs = self.args.slice();\n                    exprs.unshift(exp.expression);\n                    exprs = trim(exprs, compressor, first_in_statement, array_spread);\n                    return exprs && make_sequence(self, exprs.map(convert_spread));\n                }\n                if (compressor.option(\"yields\") && is_generator(exp)) {\n                    var call = self.clone();\n                    call.expression = make_node(AST_Function, exp);\n                    call.expression.body = [];\n                    var opt = call.transform(compressor);\n                    if (opt !== call) return opt.drop_side_effect_free(compressor, first_in_statement);\n                }\n                var dropped = drop_returns(compressor, exp);\n                if (dropped) {\n                    // always shallow clone to ensure stripping of negated IIFEs\n                    self = self.clone();\n                    self.expression = dropped;\n                    // avoid extraneous traversal\n                    if (exp._squeezed) self.expression._squeezed = true;\n                }\n                if (self instanceof AST_New) {\n                    var fn = exp;\n                    if (fn instanceof AST_SymbolRef) fn = fn.fixed_value();\n                    if (fn instanceof AST_Lambda) {\n                        if (assign_this_only(fn, compressor)) {\n                            var exprs = self.args.slice();\n                            exprs.unshift(exp);\n                            exprs = trim(exprs, compressor, first_in_statement, array_spread);\n                            return exprs && make_sequence(self, exprs.map(convert_spread));\n                        }\n                        if (!fn.contains_this()) {\n                            self = make_node(AST_Call, self);\n                            self.expression = self.expression.clone();\n                            self.args = self.args.slice();\n                        }\n                    }\n                }\n                self.call_only = true;\n                return self;\n            });\n            def(AST_ClassExpression, function(compressor, first_in_statement) {\n                var self = this;\n                var exprs = [], values = [], init = 0;\n                var props = self.properties;\n                for (var i = 0; i < props.length; i++) {\n                    var prop = props[i];\n                    if (prop.key instanceof AST_Node) exprs.push(prop.key);\n                    if (!is_static_field_or_init(prop)) continue;\n                    var value = prop.value;\n                    if (!value.has_side_effects(compressor)) continue;\n                    if (value.contains_this()) return self;\n                    if (prop instanceof AST_ClassInit) {\n                        init++;\n                        values.push(prop);\n                    } else {\n                        values.push(value);\n                    }\n                }\n                var base = self.extends;\n                if (base) {\n                    if (base instanceof AST_SymbolRef) base = base.fixed_value();\n                    base = !safe_for_extends(base);\n                    if (!base) exprs.unshift(self.extends);\n                }\n                exprs = trim(exprs, compressor, first_in_statement);\n                if (exprs) first_in_statement = false;\n                values = trim(values, compressor, first_in_statement);\n                if (!exprs) {\n                    if (!base && !values && !self.name) return null;\n                    exprs = [];\n                }\n                if (base || self.name || !compressor.has_directive(\"use strict\")) {\n                    var node = to_class_expr(self);\n                    if (!base) node.extends = null;\n                    node.properties = [];\n                    if (values) {\n                        if (values.length == init) {\n                            if (exprs.length) values.unshift(make_node(AST_ClassField, self, {\n                                key: make_sequence(self, exprs),\n                                value: null,\n                            }));\n                            node.properties = values;\n                        } else node.properties.push(make_node(AST_ClassField, self, {\n                            static: true,\n                            key: exprs.length ? make_sequence(self, exprs) : \"c\",\n                            value: make_value(),\n                        }));\n                    } else if (exprs.length) node.properties.push(make_node(AST_ClassMethod, self, {\n                        key: make_sequence(self, exprs),\n                        value: make_node(AST_Function, self, {\n                            argnames: [],\n                            body: [],\n                        }).init_vars(node),\n                    }));\n                    return node;\n                }\n                if (values) exprs.push(make_node(AST_Call, self, {\n                    expression: make_node(AST_Arrow, self, {\n                        argnames: [],\n                        body: [],\n                        value: make_value(),\n                    }).init_vars(self.parent_scope),\n                    args: [],\n                }));\n                return make_sequence(self, exprs);\n\n                function make_value() {\n                    return make_sequence(self, values.map(function(node) {\n                        if (!(node instanceof AST_ClassInit)) return node;\n                        var fn = make_node(AST_Arrow, node.value);\n                        fn.argnames = [];\n                        return make_node(AST_Call, node, {\n                            expression: fn,\n                            args: [],\n                        });\n                    }));\n                }\n            });\n            def(AST_Conditional, function(compressor) {\n                var consequent = this.consequent.drop_side_effect_free(compressor);\n                var alternative = this.alternative.drop_side_effect_free(compressor);\n                if (consequent === this.consequent && alternative === this.alternative) return this;\n                var exprs;\n                if (compressor.option(\"ie\")) {\n                    exprs = [];\n                    if (consequent instanceof AST_Function) {\n                        exprs.push(consequent);\n                        consequent = null;\n                    }\n                    if (alternative instanceof AST_Function) {\n                        exprs.push(alternative);\n                        alternative = null;\n                    }\n                }\n                var node;\n                if (!consequent) {\n                    node = alternative ? make_node(AST_Binary, this, {\n                        operator: \"||\",\n                        left: this.condition,\n                        right: alternative,\n                    }) : this.condition.drop_side_effect_free(compressor);\n                } else if (!alternative) {\n                    node = make_node(AST_Binary, this, {\n                        operator: \"&&\",\n                        left: this.condition,\n                        right: consequent,\n                    });\n                } else {\n                    node = this.clone();\n                    node.consequent = consequent;\n                    node.alternative = alternative;\n                }\n                if (!exprs) return node;\n                if (node) exprs.push(node);\n                return exprs.length == 0 ? null : make_sequence(this, exprs);\n            });\n            def(AST_Constant, return_null);\n            def(AST_Dot, function(compressor, first_in_statement) {\n                var expr = this.expression;\n                if (expr.may_throw_on_access(compressor)) return this;\n                return expr.drop_side_effect_free(compressor, first_in_statement);\n            });\n            def(AST_Function, function(compressor) {\n                return fn_name_unused(this, compressor) ? null : this;\n            });\n            def(AST_LambdaExpression, return_null);\n            def(AST_Object, function(compressor, first_in_statement) {\n                var exprs = [];\n                this.properties.forEach(function(prop) {\n                    if (prop instanceof AST_Spread) {\n                        exprs.push(prop);\n                    } else {\n                        if (prop.key instanceof AST_Node) exprs.push(prop.key);\n                        exprs.push(prop.value);\n                    }\n                });\n                var values = trim(exprs, compressor, first_in_statement, function(node, compressor, first_in_statement) {\n                    var exp = node.expression;\n                    return exp.safe_to_spread() ? exp.drop_side_effect_free(compressor, first_in_statement) : node;\n                });\n                if (!values) return null;\n                if (values === exprs && !all(values, function(node) {\n                    return !(node instanceof AST_Spread);\n                })) return this;\n                return make_sequence(this, values.map(function(node) {\n                    return node instanceof AST_Spread ? make_node(AST_Object, node, { properties: [ node ] }) : node;\n                }));\n            });\n            def(AST_ObjectIdentity, return_null);\n            def(AST_Sequence, function(compressor, first_in_statement) {\n                var expressions = trim(this.expressions, compressor, first_in_statement);\n                if (!expressions) return null;\n                var end = expressions.length - 1;\n                var last = expressions[end];\n                if (compressor.option(\"awaits\") && end > 0 && last instanceof AST_Await && last.expression.is_constant()) {\n                    expressions = expressions.slice(0, -1);\n                    end--;\n                    var expr = expressions[end];\n                    last.expression = needs_enqueuing(compressor, expr) ? expr : expr.negate(compressor);\n                    expressions[end] = last;\n                }\n                var assign, cond, lhs;\n                if (compressor.option(\"conditionals\")\n                    && end > 0\n                    && (assign = expressions[end - 1]) instanceof AST_Assign\n                    && assign.operator == \"=\"\n                    && (lhs = assign.left) instanceof AST_SymbolRef\n                    && (cond = to_conditional_assignment(compressor, lhs.definition(), assign.right, last))) {\n                    assign = assign.clone();\n                    assign.right = cond;\n                    expressions = expressions.slice(0, -2);\n                    expressions.push(assign.drop_side_effect_free(compressor, first_in_statement));\n                }\n                return expressions === this.expressions ? this : make_sequence(this, expressions);\n            });\n            def(AST_Sub, function(compressor, first_in_statement) {\n                var expr = this.expression;\n                if (expr.may_throw_on_access(compressor)) return this;\n                var prop = this.property;\n                expr = expr.drop_side_effect_free(compressor, first_in_statement);\n                if (!expr) return prop.drop_side_effect_free(compressor, first_in_statement);\n                prop = prop.drop_side_effect_free(compressor);\n                if (!prop) return expr;\n                return make_sequence(this, [ expr, prop ]);\n            });\n            def(AST_SymbolRef, function(compressor) {\n                return this.is_declared(compressor) && can_drop_symbol(this, compressor) ? null : this;\n            });\n            def(AST_Template, function(compressor, first_in_statement) {\n                var self = this;\n                if (self.is_expr_pure(compressor)) {\n                    var expressions = self.expressions;\n                    if (expressions.length == 0) return null;\n                    return make_sequence(self, expressions).drop_side_effect_free(compressor, first_in_statement);\n                }\n                var tag = self.tag;\n                var dropped = drop_returns(compressor, tag);\n                if (dropped) {\n                    // always shallow clone to signal internal changes\n                    self = self.clone();\n                    self.tag = dropped;\n                    // avoid extraneous traversal\n                    if (tag._squeezed) self.tag._squeezed = true;\n                }\n                return self;\n            });\n            def(AST_Unary, function(compressor, first_in_statement) {\n                var exp = this.expression;\n                if (unary_side_effects[this.operator]) {\n                    this.write_only = !exp.has_side_effects(compressor);\n                    return this;\n                }\n                if (this.operator == \"typeof\" && exp instanceof AST_SymbolRef && can_drop_symbol(exp, compressor)) {\n                    return null;\n                }\n                var node = exp.drop_side_effect_free(compressor, first_in_statement);\n                if (first_in_statement && node && is_iife_call(node)) {\n                    if (node === exp && this.operator == \"!\") return this;\n                    return node.negate(compressor, first_in_statement);\n                }\n                return node;\n            });\n        })(function(node, func) {\n            node.DEFMETHOD(\"drop_side_effect_free\", func);\n        });\n\n        OPT(AST_SimpleStatement, function(self, compressor) {\n            if (compressor.option(\"side_effects\")) {\n                var body = self.body;\n                var node = body.drop_side_effect_free(compressor, true);\n                if (!node) {\n                    AST_Node.warn(\"Dropping side-effect-free statement [{start}]\", self);\n                    return make_node(AST_EmptyStatement, self);\n                }\n                if (node !== body) {\n                    return make_node(AST_SimpleStatement, self, { body: node });\n                }\n            }\n            return self;\n        });\n\n        OPT(AST_While, function(self, compressor) {\n            return compressor.option(\"loops\") ? make_node(AST_For, self).optimize(compressor) : self;\n        });\n\n        function has_loop_control(loop, parent, type) {\n            if (!type) type = AST_LoopControl;\n            var found = false;\n            var tw = new TreeWalker(function(node) {\n                if (found || node instanceof AST_Scope) return true;\n                if (node instanceof type && tw.loopcontrol_target(node) === loop) {\n                    return found = true;\n                }\n            });\n            if (parent instanceof AST_LabeledStatement) tw.push(parent);\n            tw.push(loop);\n            loop.body.walk(tw);\n            return found;\n        }\n\n        OPT(AST_Do, function(self, compressor) {\n            if (!compressor.option(\"loops\")) return self;\n            var cond = fuzzy_eval(compressor, self.condition);\n            if (!(cond instanceof AST_Node)) {\n                if (cond && !has_loop_control(self, compressor.parent(), AST_Continue)) return make_node(AST_For, self, {\n                    body: make_node(AST_BlockStatement, self.body, {\n                        body: [\n                            self.body,\n                            make_node(AST_SimpleStatement, self.condition, { body: self.condition }),\n                        ],\n                    }),\n                }).optimize(compressor);\n                if (!has_loop_control(self, compressor.parent())) return make_node(AST_BlockStatement, self.body, {\n                    body: [\n                        self.body,\n                        make_node(AST_SimpleStatement, self.condition, { body: self.condition }),\n                    ],\n                }).optimize(compressor);\n            }\n            if (self.body instanceof AST_BlockStatement && !has_loop_control(self, compressor.parent(), AST_Continue)) {\n                var body = self.body.body;\n                for (var i = body.length; --i >= 0;) {\n                    var stat = body[i];\n                    if (stat instanceof AST_If\n                        && !stat.alternative\n                        && stat.body instanceof AST_Break\n                        && compressor.loopcontrol_target(stat.body) === self) {\n                        if (has_block_scope_refs(stat.condition)) break;\n                        self.condition = make_node(AST_Binary, self, {\n                            operator: \"&&\",\n                            left: stat.condition.negate(compressor),\n                            right: self.condition,\n                        });\n                        body.splice(i, 1);\n                    } else if (stat instanceof AST_SimpleStatement) {\n                        if (has_block_scope_refs(stat.body)) break;\n                        self.condition = make_sequence(self, [\n                            stat.body,\n                            self.condition,\n                        ]);\n                        body.splice(i, 1);\n                    } else if (!is_declaration(stat, true)) {\n                        break;\n                    }\n                }\n                self.body = trim_block(self.body, compressor.parent());\n            }\n            if (self.body instanceof AST_EmptyStatement) return make_node(AST_For, self).optimize(compressor);\n            if (self.body instanceof AST_SimpleStatement) return make_node(AST_For, self, {\n                condition: make_sequence(self.condition, [\n                    self.body.body,\n                    self.condition,\n                ]),\n                body: make_node(AST_EmptyStatement, self),\n            }).optimize(compressor);\n            return self;\n\n            function has_block_scope_refs(node) {\n                var found = false;\n                node.walk(new TreeWalker(function(node) {\n                    if (found) return true;\n                    if (node instanceof AST_SymbolRef) {\n                        if (!member(node.definition(), self.enclosed)) found = true;\n                        return true;\n                    }\n                }));\n                return found;\n            }\n        });\n\n        function if_break_in_loop(self, compressor) {\n            var first = first_statement(self.body);\n            if (compressor.option(\"dead_code\")\n                && (first instanceof AST_Break\n                    || first instanceof AST_Continue && external_target(first)\n                    || first instanceof AST_Exit)) {\n                var body = [];\n                if (is_statement(self.init)) {\n                    body.push(self.init);\n                } else if (self.init) {\n                    body.push(make_node(AST_SimpleStatement, self.init, { body: self.init }));\n                }\n                var retain = external_target(first) || first instanceof AST_Exit;\n                if (self.condition && retain) {\n                    body.push(make_node(AST_If, self, {\n                        condition: self.condition,\n                        body: first,\n                        alternative: null,\n                    }));\n                } else if (self.condition) {\n                    body.push(make_node(AST_SimpleStatement, self.condition, { body: self.condition }));\n                } else if (retain) {\n                    body.push(first);\n                }\n                extract_declarations_from_unreachable_code(compressor, self.body, body);\n                return make_node(AST_BlockStatement, self, { body: body });\n            }\n            if (first instanceof AST_If) {\n                var ab = first_statement(first.body);\n                if (ab instanceof AST_Break && !external_target(ab)) {\n                    if (self.condition) {\n                        self.condition = make_node(AST_Binary, self.condition, {\n                            left: self.condition,\n                            operator: \"&&\",\n                            right: first.condition.negate(compressor),\n                        });\n                    } else {\n                        self.condition = first.condition.negate(compressor);\n                    }\n                    var body = as_statement_array(first.alternative);\n                    extract_declarations_from_unreachable_code(compressor, first.body, body);\n                    return drop_it(body);\n                }\n                ab = first_statement(first.alternative);\n                if (ab instanceof AST_Break && !external_target(ab)) {\n                    if (self.condition) {\n                        self.condition = make_node(AST_Binary, self.condition, {\n                            left: self.condition,\n                            operator: \"&&\",\n                            right: first.condition,\n                        });\n                    } else {\n                        self.condition = first.condition;\n                    }\n                    var body = as_statement_array(first.body);\n                    extract_declarations_from_unreachable_code(compressor, first.alternative, body);\n                    return drop_it(body);\n                }\n            }\n            return self;\n\n            function first_statement(body) {\n                return body instanceof AST_BlockStatement ? body.body[0] : body;\n            }\n\n            function external_target(node) {\n                return compressor.loopcontrol_target(node) !== compressor.self();\n            }\n\n            function drop_it(rest) {\n                if (self.body instanceof AST_BlockStatement) {\n                    self.body = self.body.clone();\n                    self.body.body = rest.concat(self.body.body.slice(1));\n                    self.body = self.body.transform(compressor);\n                } else {\n                    self.body = make_node(AST_BlockStatement, self.body, { body: rest }).transform(compressor);\n                }\n                return if_break_in_loop(self, compressor);\n            }\n        }\n\n        OPT(AST_For, function(self, compressor) {\n            if (!compressor.option(\"loops\")) return self;\n            if (compressor.option(\"side_effects\")) {\n                if (self.init) self.init = self.init.drop_side_effect_free(compressor);\n                if (self.step) self.step = self.step.drop_side_effect_free(compressor);\n            }\n            if (self.condition) {\n                var cond = fuzzy_eval(compressor, self.condition);\n                if (!cond) {\n                    if (compressor.option(\"dead_code\")) {\n                        var body = [];\n                        if (is_statement(self.init)) {\n                            body.push(self.init);\n                        } else if (self.init) {\n                            body.push(make_node(AST_SimpleStatement, self.init, { body: self.init }));\n                        }\n                        body.push(make_node(AST_SimpleStatement, self.condition, { body: self.condition }));\n                        extract_declarations_from_unreachable_code(compressor, self.body, body);\n                        return make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);\n                    }\n                } else if (!(cond instanceof AST_Node)) {\n                    self.body = make_node(AST_BlockStatement, self.body, {\n                        body: [\n                            make_node(AST_SimpleStatement, self.condition, { body: self.condition }),\n                            self.body,\n                        ],\n                    });\n                    self.condition = null;\n                }\n            }\n            return if_break_in_loop(self, compressor);\n        });\n\n        OPT(AST_ForEnumeration, function(self, compressor) {\n            if (compressor.option(\"varify\") && is_lexical_definition(self.init)) {\n                var name = self.init.definitions[0].name;\n                if ((name instanceof AST_Destructured || name instanceof AST_SymbolLet)\n                    && !name.match_symbol(function(node) {\n                        if (node instanceof AST_SymbolDeclaration) {\n                            var def = node.definition();\n                            return !same_scope(def) || may_overlap(compressor, def);\n                        }\n                    }, true)) {\n                    self.init = to_var(self.init, self.resolve());\n                }\n            }\n            return self;\n        });\n\n        function mark_locally_defined(condition, consequent, alternative) {\n            if (condition instanceof AST_Sequence) condition = condition.tail_node();\n            if (!(condition instanceof AST_Binary)) return;\n            if (!(condition.left instanceof AST_String)) {\n                switch (condition.operator) {\n                  case \"&&\":\n                    mark_locally_defined(condition.left, consequent);\n                    mark_locally_defined(condition.right, consequent);\n                    break;\n                  case \"||\":\n                    mark_locally_defined(negate(condition.left), alternative);\n                    mark_locally_defined(negate(condition.right), alternative);\n                    break;\n                }\n                return;\n            }\n            if (!(condition.right instanceof AST_UnaryPrefix)) return;\n            if (condition.right.operator != \"typeof\") return;\n            var sym = condition.right.expression;\n            if (!is_undeclared_ref(sym)) return;\n            var body;\n            var undef = condition.left.value == \"undefined\";\n            switch (condition.operator) {\n              case \"==\":\n                body = undef ? alternative : consequent;\n                break;\n              case \"!=\":\n                body = undef ? consequent : alternative;\n                break;\n              default:\n                return;\n            }\n            if (!body) return;\n            var abort = false;\n            var def = sym.definition();\n            var fn;\n            var refs = [];\n            var scanned = [];\n            var tw = new TreeWalker(function(node, descend) {\n                if (abort) return true;\n                if (node instanceof AST_Assign) {\n                    var ref = node.left;\n                    if (!(ref instanceof AST_SymbolRef && ref.definition() === def)) return;\n                    node.right.walk(tw);\n                    switch (node.operator) {\n                      case \"=\":\n                      case \"&&=\":\n                        abort = true;\n                    }\n                    return true;\n                }\n                if (node instanceof AST_Call) {\n                    descend();\n                    fn = node.expression.tail_node();\n                    var save;\n                    if (fn instanceof AST_SymbolRef) {\n                        fn = fn.fixed_value();\n                        save = refs.length;\n                    }\n                    if (!(fn instanceof AST_Lambda)) {\n                        abort = true;\n                    } else if (push_uniq(scanned, fn)) {\n                        fn.walk(tw);\n                    }\n                    if (save >= 0) refs.length = save;\n                    return true;\n                }\n                if (node instanceof AST_DWLoop) {\n                    var save = refs.length;\n                    descend();\n                    if (abort) refs.length = save;\n                    return true;\n                }\n                if (node instanceof AST_For) {\n                    if (node.init) node.init.walk(tw);\n                    var save = refs.length;\n                    if (node.condition) node.condition.walk(tw);\n                    node.body.walk(tw);\n                    if (node.step) node.step.walk(tw);\n                    if (abort) refs.length = save;\n                    return true;\n                }\n                if (node instanceof AST_ForEnumeration) {\n                    node.object.walk(tw);\n                    var save = refs.length;\n                    node.init.walk(tw);\n                    node.body.walk(tw);\n                    if (abort) refs.length = save;\n                    return true;\n                }\n                if (node instanceof AST_Scope) {\n                    if (node === fn) return;\n                    return true;\n                }\n                if (node instanceof AST_SymbolRef) {\n                    if (node.definition() === def) refs.push(node);\n                    return true;\n                }\n            });\n            body.walk(tw);\n            refs.forEach(function(ref) {\n                ref.defined = true;\n            });\n\n            function negate(node) {\n                if (!(node instanceof AST_Binary)) return;\n                switch (node.operator) {\n                  case \"==\":\n                    node = node.clone();\n                    node.operator = \"!=\";\n                    return node;\n                  case \"!=\":\n                    node = node.clone();\n                    node.operator = \"==\";\n                    return node;\n                }\n            }\n        }\n\n        function fuzzy_eval(compressor, node, nullish) {\n            if (node.truthy) return true;\n            if (is_undefined(node)) return undefined;\n            if (node.falsy && !nullish) return false;\n            if (node.is_truthy()) return true;\n            return node.evaluate(compressor, true);\n        }\n\n        function mark_duplicate_condition(compressor, node) {\n            var child;\n            var level = 0;\n            var negated = false;\n            var parent = compressor.self();\n            if (!is_statement(parent)) while (true) {\n                child = parent;\n                parent = compressor.parent(level++);\n                if (parent instanceof AST_Binary) {\n                    switch (child) {\n                      case parent.left:\n                        if (lazy_op[parent.operator]) continue;\n                        break;\n                      case parent.right:\n                        if (match(parent.left)) switch (parent.operator) {\n                          case \"&&\":\n                            node[negated ? \"falsy\" : \"truthy\"] = true;\n                            break;\n                          case \"||\":\n                          case \"??\":\n                            node[negated ? \"truthy\" : \"falsy\"] = true;\n                            break;\n                        }\n                        break;\n                    }\n                } else if (parent instanceof AST_Conditional) {\n                    var cond = parent.condition;\n                    if (cond === child) continue;\n                    if (match(cond)) switch (child) {\n                      case parent.consequent:\n                        node[negated ? \"falsy\" : \"truthy\"] = true;\n                        break;\n                      case parent.alternative:\n                        node[negated ? \"truthy\" : \"falsy\"] = true;\n                        break;\n                    }\n                } else if (parent instanceof AST_Exit) {\n                    break;\n                } else if (parent instanceof AST_If) {\n                    break;\n                } else if (parent instanceof AST_Sequence) {\n                    if (parent.expressions[0] === child) continue;\n                } else if (parent instanceof AST_SimpleStatement) {\n                    break;\n                }\n                return;\n            }\n            while (true) {\n                child = parent;\n                parent = compressor.parent(level++);\n                if (parent instanceof AST_BlockStatement) {\n                    if (parent.body[0] === child) continue;\n                } else if (parent instanceof AST_If) {\n                    if (match(parent.condition)) switch (child) {\n                      case parent.body:\n                        node[negated ? \"falsy\" : \"truthy\"] = true;\n                        break;\n                      case parent.alternative:\n                        node[negated ? \"truthy\" : \"falsy\"] = true;\n                        break;\n                    }\n                }\n                return;\n            }\n\n            function match(cond) {\n                if (node.equals(cond)) return true;\n                if (!(cond instanceof AST_UnaryPrefix)) return false;\n                if (cond.operator != \"!\") return false;\n                if (!node.equals(cond.expression)) return false;\n                negated = true;\n                return true;\n            }\n        }\n\n        OPT(AST_If, function(self, compressor) {\n            if (is_empty(self.alternative)) self.alternative = null;\n\n            if (!compressor.option(\"conditionals\")) return self;\n            if (compressor.option(\"booleans\") && !self.condition.has_side_effects(compressor)) {\n                mark_duplicate_condition(compressor, self.condition);\n            }\n            // if condition can be statically determined, warn and drop\n            // one of the blocks.  note, statically determined implies\n            // has no side effects; also it doesn't work for cases like\n            // `x && true`, though it probably should.\n            if (compressor.option(\"dead_code\")) {\n                var cond = fuzzy_eval(compressor, self.condition);\n                if (!cond) {\n                    AST_Node.warn(\"Condition always false [{start}]\", self.condition);\n                    var body = [\n                        make_node(AST_SimpleStatement, self.condition, { body: self.condition }).transform(compressor),\n                    ];\n                    extract_declarations_from_unreachable_code(compressor, self.body, body);\n                    if (self.alternative) body.push(self.alternative);\n                    return make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);\n                } else if (!(cond instanceof AST_Node)) {\n                    AST_Node.warn(\"Condition always true [{start}]\", self.condition);\n                    var body = [\n                        make_node(AST_SimpleStatement, self.condition, { body: self.condition }).transform(compressor),\n                        self.body,\n                    ];\n                    if (self.alternative) extract_declarations_from_unreachable_code(compressor, self.alternative, body);\n                    return make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);\n                }\n            }\n            var negated = self.condition.negate(compressor);\n            var self_condition_length = self.condition.print_to_string().length;\n            var negated_length = negated.print_to_string().length;\n            var negated_is_best = negated_length < self_condition_length;\n            if (self.alternative && negated_is_best) {\n                negated_is_best = false; // because we already do the switch here.\n                // no need to swap values of self_condition_length and negated_length\n                // here because they are only used in an equality comparison later on.\n                self.condition = negated;\n                var tmp = self.body;\n                self.body = self.alternative;\n                self.alternative = is_empty(tmp) ? null : tmp;\n            }\n            var body_defuns = [];\n            var body_var_defs = [];\n            var body_refs = [];\n            var body_exprs = sequencesize(self.body, body_defuns, body_var_defs, body_refs);\n            var alt_defuns = [];\n            var alt_var_defs = [];\n            var alt_refs = [];\n            var alt_exprs = sequencesize(self.alternative, alt_defuns, alt_var_defs, alt_refs);\n            if (body_exprs instanceof AST_BlockStatement || alt_exprs instanceof AST_BlockStatement) {\n                var body = [], var_defs = [];\n                if (body_exprs) {\n                    [].push.apply(body, body_defuns);\n                    [].push.apply(var_defs, body_var_defs);\n                    if (body_exprs instanceof AST_BlockStatement) {\n                        self.body = body_exprs;\n                    } else if (body_exprs.length == 0) {\n                        self.body = make_node(AST_EmptyStatement, self.body);\n                    } else {\n                        self.body = make_node(AST_SimpleStatement, self.body, {\n                            body: make_sequence(self.body, body_exprs),\n                        });\n                    }\n                    body_refs.forEach(process_to_assign);\n                }\n                if (alt_exprs) {\n                    [].push.apply(body, alt_defuns);\n                    [].push.apply(var_defs, alt_var_defs);\n                    if (alt_exprs instanceof AST_BlockStatement) {\n                        self.alternative = alt_exprs;\n                    } else if (alt_exprs.length == 0) {\n                        self.alternative = null;\n                    } else {\n                        self.alternative = make_node(AST_SimpleStatement, self.alternative, {\n                            body: make_sequence(self.alternative, alt_exprs),\n                        });\n                    }\n                    alt_refs.forEach(process_to_assign);\n                }\n                if (var_defs.length > 0) body.push(make_node(AST_Var, self, { definitions: var_defs }));\n                if (body.length > 0) {\n                    body.push(self.transform(compressor));\n                    return make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);\n                }\n            } else if (body_exprs && alt_exprs) {\n                var body = body_defuns.concat(alt_defuns);\n                if (body_var_defs.length > 0 || alt_var_defs.length > 0) body.push(make_node(AST_Var, self, {\n                    definitions: body_var_defs.concat(alt_var_defs),\n                }));\n                if (body_exprs.length == 0) {\n                    body.push(make_node(AST_SimpleStatement, self.condition, {\n                        body: alt_exprs.length > 0 ? make_node(AST_Binary, self, {\n                            operator: \"||\",\n                            left: self.condition,\n                            right: make_sequence(self.alternative, alt_exprs),\n                        }).transform(compressor) : self.condition.clone(),\n                    }).optimize(compressor));\n                } else if (alt_exprs.length == 0) {\n                    if (self_condition_length === negated_length && !negated_is_best\n                        && self.condition instanceof AST_Binary && self.condition.operator == \"||\") {\n                        // although the code length of self.condition and negated are the same,\n                        // negated does not require additional surrounding parentheses.\n                        // see https://github.com/mishoo/UglifyJS/issues/979\n                        negated_is_best = true;\n                    }\n                    body.push(make_node(AST_SimpleStatement, self, {\n                        body: make_node(AST_Binary, self, {\n                            operator: negated_is_best ? \"||\" : \"&&\",\n                            left: negated_is_best ? negated : self.condition,\n                            right: make_sequence(self.body, body_exprs),\n                        }).transform(compressor),\n                    }).optimize(compressor));\n                } else {\n                    body.push(make_node(AST_SimpleStatement, self, {\n                        body: make_node(AST_Conditional, self, {\n                            condition: self.condition,\n                            consequent: make_sequence(self.body, body_exprs),\n                            alternative: make_sequence(self.alternative, alt_exprs),\n                        }),\n                    }).optimize(compressor));\n                }\n                body_refs.forEach(process_to_assign);\n                alt_refs.forEach(process_to_assign);\n                return make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);\n            }\n            if (is_empty(self.body)) self = make_node(AST_If, self, {\n                condition: negated,\n                body: self.alternative,\n                alternative: null,\n            });\n            if (self.alternative instanceof AST_Exit && self.body.TYPE == self.alternative.TYPE) {\n                var cons_value = self.body.value;\n                var alt_value = self.alternative.value;\n                if (!cons_value && !alt_value) return make_node(AST_BlockStatement, self, {\n                    body: [\n                        make_node(AST_SimpleStatement, self, { body: self.condition }),\n                        self.body,\n                    ],\n                }).optimize(compressor);\n                if (cons_value && alt_value || !keep_return_void()) {\n                    var exit = make_node(self.body.CTOR, self, {\n                        value: make_node(AST_Conditional, self, {\n                            condition: self.condition,\n                            consequent: cons_value || make_node(AST_Undefined, self.body).transform(compressor),\n                            alternative: alt_value || make_node(AST_Undefined, self.alternative).transform(compressor),\n                        }),\n                    });\n                    if (exit instanceof AST_Return) exit.in_bool = self.body.in_bool || self.alternative.in_bool;\n                    return exit;\n                }\n            }\n            if (self.body instanceof AST_If && !self.body.alternative && !self.alternative) {\n                self = make_node(AST_If, self, {\n                    condition: make_node(AST_Binary, self.condition, {\n                        operator: \"&&\",\n                        left: self.condition,\n                        right: self.body.condition,\n                    }),\n                    body: self.body.body,\n                    alternative: null,\n                });\n            }\n            if (aborts(self.body) && self.alternative) {\n                var alt = self.alternative;\n                self.alternative = null;\n                return make_node(AST_BlockStatement, self, { body: [ self, alt ] }).optimize(compressor);\n            }\n            if (aborts(self.alternative)) {\n                var body = self.body;\n                self.body = self.alternative;\n                self.condition = negated_is_best ? negated : self.condition.negate(compressor);\n                self.alternative = null;\n                return make_node(AST_BlockStatement, self, { body: [ self, body ] }).optimize(compressor);\n            }\n            if (self.alternative) {\n                var body_stats = as_array(self.body);\n                var body_index = last_index(body_stats);\n                var alt_stats = as_array(self.alternative);\n                var alt_index = last_index(alt_stats);\n                for (var stats = []; body_index >= 0 && alt_index >= 0;) {\n                    var stat = body_stats[body_index];\n                    var alt_stat = alt_stats[alt_index];\n                    if (stat.equals(alt_stat)) {\n                        body_stats.splice(body_index--, 1);\n                        alt_stats.splice(alt_index--, 1);\n                        stats.unshift(merge_expression(stat, alt_stat));\n                    } else {\n                        if (!(stat instanceof AST_SimpleStatement)) break;\n                        if (!(alt_stat instanceof AST_SimpleStatement)) break;\n                        var expr1 = stat.body.tail_node();\n                        var expr2 = alt_stat.body.tail_node();\n                        if (!expr1.equals(expr2)) break;\n                        body_index = pop_expr(body_stats, stat.body, body_index);\n                        alt_index = pop_expr(alt_stats, alt_stat.body, alt_index);\n                        stats.unshift(make_node(AST_SimpleStatement, expr1, { body: merge_expression(expr1, expr2) }));\n                    }\n                }\n                if (stats.length > 0) {\n                    self.body = body_stats.length > 0 ? make_node(AST_BlockStatement, self, {\n                        body: body_stats,\n                    }) : make_node(AST_EmptyStatement, self);\n                    self.alternative = alt_stats.length > 0 ? make_node(AST_BlockStatement, self, {\n                        body: alt_stats,\n                    }) : null;\n                    stats.unshift(self);\n                    return make_node(AST_BlockStatement, self, { body: stats }).optimize(compressor);\n                }\n            }\n            if (compressor.option(\"typeofs\")) mark_locally_defined(self.condition, self.body, self.alternative);\n            return self;\n\n            function as_array(node) {\n                return node instanceof AST_BlockStatement ? node.body : [ node ];\n            }\n\n            function keep_return_void() {\n                var has_finally = false, level = 0, node = compressor.self();\n                do {\n                    if (node instanceof AST_Catch) {\n                        if (compressor.parent(level).bfinally) has_finally = true;\n                        level++;\n                    } else if (node instanceof AST_Finally) {\n                        level++;\n                    } else if (node instanceof AST_Scope) {\n                        return has_finally && in_async_generator(node);\n                    } else if (node instanceof AST_Try) {\n                        if (node.bfinally) has_finally = true;\n                    }\n                } while (node = compressor.parent(level++));\n            }\n\n            function last_index(stats) {\n                for (var index = stats.length; --index >= 0;) {\n                    if (!is_declaration(stats[index], true)) break;\n                }\n                return index;\n            }\n\n            function pop_expr(stats, body, index) {\n                if (body instanceof AST_Sequence) {\n                    stats[index] = make_node(AST_SimpleStatement, body, {\n                        body: make_sequence(body, body.expressions.slice(0, -1)),\n                    });\n                } else {\n                    stats.splice(index--, 1);\n                }\n                return index;\n            }\n\n            function sequencesize(stat, defuns, var_defs, refs) {\n                if (stat == null) return [];\n                if (stat instanceof AST_BlockStatement) {\n                    var exprs = [];\n                    for (var i = 0; i < stat.body.length; i++) {\n                        var line = stat.body[i];\n                        if (line instanceof AST_EmptyStatement) continue;\n                        if (line instanceof AST_Exit) {\n                            if (i == 0) return;\n                            if (exprs.length > 0) {\n                                line = line.clone();\n                                exprs.push(line.value || make_node(AST_Undefined, line).transform(compressor));\n                                line.value = make_sequence(stat, exprs);\n                            }\n                            var block = stat.clone();\n                            block.body = block.body.slice(i + 1);\n                            block.body.unshift(line);\n                            return block;\n                        }\n                        if (line instanceof AST_LambdaDefinition) {\n                            defuns.push(line);\n                        } else if (line instanceof AST_SimpleStatement) {\n                            if (!compressor.option(\"sequences\") && exprs.length > 0) return;\n                            exprs.push(line.body);\n                        } else if (line instanceof AST_Var) {\n                            if (!compressor.option(\"sequences\") && exprs.length > 0) return;\n                            line.remove_initializers(compressor, var_defs);\n                            line.definitions.forEach(process_var_def);\n                        } else {\n                            return;\n                        }\n                    }\n                    return exprs;\n                }\n                if (stat instanceof AST_LambdaDefinition) {\n                    defuns.push(stat);\n                    return [];\n                }\n                if (stat instanceof AST_EmptyStatement) return [];\n                if (stat instanceof AST_SimpleStatement) return [ stat.body ];\n                if (stat instanceof AST_Var) {\n                    var exprs = [];\n                    stat.remove_initializers(compressor, var_defs);\n                    stat.definitions.forEach(process_var_def);\n                    return exprs;\n                }\n\n                function process_var_def(var_def) {\n                    if (!var_def.value) return;\n                    exprs.push(make_node(AST_Assign, var_def, {\n                        operator: \"=\",\n                        left: var_def.name.convert_symbol(AST_SymbolRef, function(ref) {\n                            refs.push(ref);\n                        }),\n                        right: var_def.value,\n                    }));\n                }\n            }\n        });\n\n        OPT(AST_Switch, function(self, compressor) {\n            if (!compressor.option(\"switches\")) return self;\n            if (!compressor.option(\"dead_code\")) return self;\n            var body = [];\n            var branch;\n            var decl = [];\n            var default_branch;\n            var exact_match;\n            var side_effects = [];\n            for (var i = 0, len = self.body.length; i < len; i++) {\n                branch = self.body[i];\n                if (branch instanceof AST_Default) {\n                    var prev = body[body.length - 1];\n                    if (default_branch || is_break(branch.body[0], compressor) && (!prev || aborts(prev))) {\n                        eliminate_branch(branch, prev);\n                        continue;\n                    } else {\n                        default_branch = branch;\n                    }\n                } else {\n                    var exp = branch.expression;\n                    var equals = make_node(AST_Binary, self, {\n                        operator: \"===\",\n                        left: self.expression,\n                        right: exp,\n                    }).evaluate(compressor, true);\n                    if (!equals) {\n                        if (exp.has_side_effects(compressor)) side_effects.push(exp);\n                        eliminate_branch(branch, body[body.length - 1]);\n                        continue;\n                    }\n                    if (!(equals instanceof AST_Node)) {\n                        if (default_branch) {\n                            var default_index = body.indexOf(default_branch);\n                            body.splice(default_index, 1);\n                            eliminate_branch(default_branch, body[default_index - 1]);\n                            default_branch = null;\n                        }\n                        if (exp.has_side_effects(compressor)) {\n                            exact_match = branch;\n                        } else {\n                            default_branch = branch = make_node(AST_Default, branch);\n                        }\n                        while (++i < len) eliminate_branch(self.body[i], branch);\n                    }\n                }\n                if (i + 1 >= len || aborts(branch)) {\n                    var prev = body[body.length - 1];\n                    var statements = branch.body;\n                    if (aborts(prev)) switch (prev.body.length - statements.length) {\n                      case 1:\n                        var stat = prev.body[prev.body.length - 1];\n                        if (!is_break(stat, compressor)) break;\n                        statements = statements.concat(stat);\n                      case 0:\n                        var prev_block = make_node(AST_BlockStatement, prev);\n                        var next_block = make_node(AST_BlockStatement, branch, { body: statements });\n                        if (prev_block.equals(next_block)) prev.body = [];\n                    }\n                }\n                if (side_effects.length) {\n                    if (branch instanceof AST_Default) {\n                        body.push(make_node(AST_Case, self, { expression: make_sequence(self, side_effects), body: [] }));\n                    } else {\n                        side_effects.push(branch.expression);\n                        branch.expression = make_sequence(self, side_effects);\n                    }\n                    side_effects = [];\n                }\n                body.push(branch);\n            }\n            if (side_effects.length && !exact_match) {\n                body.push(make_node(AST_Case, self, { expression: make_sequence(self, side_effects), body: [] }));\n            }\n            while (branch = body[body.length - 1]) {\n                var stat = branch.body[branch.body.length - 1];\n                if (is_break(stat, compressor)) branch.body.pop();\n                if (branch === default_branch) {\n                    if (!has_declarations_only(branch)) break;\n                } else if (branch.expression.has_side_effects(compressor)) {\n                    break;\n                } else if (default_branch) {\n                    if (!has_declarations_only(default_branch)) break;\n                    if (body[body.length - 2] !== default_branch) break;\n                    default_branch.body = default_branch.body.concat(branch.body);\n                    branch.body = [];\n                } else if (!has_declarations_only(branch)) break;\n                eliminate_branch(branch);\n                if (body.pop() === default_branch) default_branch = null;\n            }\n            if (!branch) {\n                decl.push(make_node(AST_SimpleStatement, self.expression, { body: self.expression }));\n                if (side_effects.length) decl.push(make_node(AST_SimpleStatement, self, {\n                    body: make_sequence(self, side_effects),\n                }));\n                return make_node(AST_BlockStatement, self, { body: decl }).optimize(compressor);\n            }\n            if (branch === default_branch) while (branch = body[body.length - 2]) {\n                if (branch instanceof AST_Default) break;\n                if (!has_declarations_only(branch)) break;\n                var exp = branch.expression;\n                if (exp.has_side_effects(compressor)) {\n                    var prev = body[body.length - 3];\n                    if (prev && !aborts(prev)) break;\n                    default_branch.body.unshift(make_node(AST_SimpleStatement, self, { body: exp }));\n                }\n                eliminate_branch(branch);\n                body.splice(-2, 1);\n            }\n            body[0].body = decl.concat(body[0].body);\n            self.body = body;\n            if (compressor.option(\"conditionals\")) switch (body.length) {\n              case 1:\n                if (!no_break(body[0])) break;\n                var exp = body[0].expression;\n                var statements = body[0].body.slice();\n                if (body[0] !== default_branch && body[0] !== exact_match) return make_node(AST_If, self, {\n                    condition: make_node(AST_Binary, self, {\n                        operator: \"===\",\n                        left: self.expression,\n                        right: exp,\n                    }),\n                    body: make_node(AST_BlockStatement, self, { body: statements }),\n                    alternative: null,\n                }).optimize(compressor);\n                if (exp) statements.unshift(make_node(AST_SimpleStatement, exp, { body: exp }));\n                statements.unshift(make_node(AST_SimpleStatement, self.expression, { body: self.expression }));\n                return make_node(AST_BlockStatement, self, { body: statements }).optimize(compressor);\n              case 2:\n                if (!member(default_branch, body) || !no_break(body[1])) break;\n                var statements = body[0].body.slice();\n                var exclusive = statements.length && is_break(statements[statements.length - 1], compressor);\n                if (exclusive) statements.pop();\n                if (!all(statements, no_break)) break;\n                var alternative = body[1].body.length && make_node(AST_BlockStatement, body[1]);\n                var node = make_node(AST_If, self, {\n                    condition: make_node(AST_Binary, self, body[0] === default_branch ? {\n                        operator: \"!==\",\n                        left: self.expression,\n                        right: body[1].expression,\n                    } : {\n                        operator: \"===\",\n                        left: self.expression,\n                        right: body[0].expression,\n                    }),\n                    body: make_node(AST_BlockStatement, body[0], { body: statements }),\n                    alternative: exclusive && alternative || null,\n                });\n                if (!exclusive && alternative) node = make_node(AST_BlockStatement, self, { body: [ node, alternative ] });\n                return node.optimize(compressor);\n            }\n            return self;\n\n            function is_break(node, tw) {\n                return node instanceof AST_Break && tw.loopcontrol_target(node) === self;\n            }\n\n            function no_break(node) {\n                var found = false;\n                var tw = new TreeWalker(function(node) {\n                    if (found\n                        || node instanceof AST_Lambda\n                        || node instanceof AST_SimpleStatement) return true;\n                    if (is_break(node, tw)) found = true;\n                });\n                tw.push(self);\n                node.walk(tw);\n                return !found;\n            }\n\n            function eliminate_branch(branch, prev) {\n                if (prev && !aborts(prev)) {\n                    prev.body = prev.body.concat(branch.body);\n                } else {\n                    extract_declarations_from_unreachable_code(compressor, branch, decl);\n                }\n            }\n        });\n\n        OPT(AST_Try, function(self, compressor) {\n            self.body = tighten_body(self.body, compressor);\n            if (compressor.option(\"dead_code\")) {\n                if (has_declarations_only(self)\n                    && !(self.bcatch && self.bcatch.argname && self.bcatch.argname.match_symbol(function(node) {\n                        return node instanceof AST_SymbolCatch && !can_drop_symbol(node);\n                    }, true))) {\n                    var body = [];\n                    if (self.bcatch) {\n                        extract_declarations_from_unreachable_code(compressor, self.bcatch, body);\n                        body.forEach(function(stat) {\n                            if (!(stat instanceof AST_Var)) return;\n                            stat.definitions.forEach(function(var_def) {\n                                var def = var_def.name.definition().redefined();\n                                if (!def) return;\n                                var_def.name = var_def.name.clone();\n                                var_def.name.thedef = def;\n                            });\n                        });\n                    }\n                    body.unshift(make_node(AST_BlockStatement, self).optimize(compressor));\n                    if (self.bfinally) {\n                        body.push(make_node(AST_BlockStatement, self.bfinally).optimize(compressor));\n                    }\n                    return make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);\n                }\n                if (self.bfinally && has_declarations_only(self.bfinally)) {\n                    var body = make_node(AST_BlockStatement, self.bfinally).optimize(compressor);\n                    body = self.body.concat(body);\n                    if (!self.bcatch) return make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);\n                    self.body = body;\n                    self.bfinally = null;\n                }\n            }\n            return self;\n        });\n\n        function remove_initializers(make_value) {\n            return function(compressor, defns) {\n                var dropped = false;\n                this.definitions.forEach(function(defn) {\n                    if (defn.value) dropped = true;\n                    defn.name.match_symbol(function(node) {\n                        if (node instanceof AST_SymbolDeclaration) defns.push(make_node(AST_VarDef, node, {\n                            name: node,\n                            value: make_value(compressor, node),\n                        }));\n                    }, true);\n                });\n                return dropped;\n            };\n        }\n\n        AST_Const.DEFMETHOD(\"remove_initializers\", remove_initializers(function(compressor, node) {\n            return make_node(AST_Undefined, node).optimize(compressor);\n        }));\n        AST_Let.DEFMETHOD(\"remove_initializers\", remove_initializers(return_null));\n        AST_Var.DEFMETHOD(\"remove_initializers\", remove_initializers(return_null));\n\n        AST_Definitions.DEFMETHOD(\"to_assignments\", function() {\n            var assignments = this.definitions.reduce(function(a, defn) {\n                var def = defn.name.definition();\n                var value = defn.value;\n                if (value) {\n                    if (value instanceof AST_Sequence) value = value.clone();\n                    var name = make_node(AST_SymbolRef, defn.name);\n                    var assign = make_node(AST_Assign, defn, {\n                        operator: \"=\",\n                        left: name,\n                        right: value,\n                    });\n                    a.push(assign);\n                    var fixed = function() {\n                        return assign.right;\n                    };\n                    fixed.assigns = [ assign ];\n                    fixed.direct_access = def.direct_access;\n                    fixed.escaped = def.escaped;\n                    name.fixed = fixed;\n                    def.references.forEach(function(ref) {\n                        if (!ref.fixed) return;\n                        var assigns = ref.fixed.assigns;\n                        if (!assigns) return;\n                        if (assigns[0] !== defn) return;\n                        if (assigns.length > 1 || ref.fixed.to_binary || ref.fixed.to_prefix) {\n                            assigns[0] = assign;\n                        } else {\n                            ref.fixed = fixed;\n                            if (def.fixed === ref.fixed) def.fixed = fixed;\n                        }\n                    });\n                    def.references.push(name);\n                }\n                def.assignments++;\n                def.eliminated++;\n                def.single_use = false;\n                return a;\n            }, []);\n            if (assignments.length == 0) return null;\n            return make_sequence(this, assignments);\n        });\n\n        function is_safe_lexical(def) {\n            return def.name != \"arguments\" && def.orig.length < (def.orig[0] instanceof AST_SymbolLambda ? 3 : 2);\n        }\n\n        function may_overlap(compressor, def) {\n            if (compressor.exposed(def)) return true;\n            var scope = def.scope.resolve();\n            for (var s = def.scope; s !== scope;) {\n                s = s.parent_scope;\n                if (s.var_names().has(def.name)) return true;\n            }\n        }\n\n        function to_var(stat, scope) {\n            return make_node(AST_Var, stat, {\n                definitions: stat.definitions.map(function(defn) {\n                    return make_node(AST_VarDef, defn, {\n                        name: defn.name.convert_symbol(AST_SymbolVar, function(name, node) {\n                            var def = name.definition();\n                            def.orig[def.orig.indexOf(node)] = name;\n                            if (def.scope === scope) return;\n                            def.scope = scope;\n                            scope.variables.set(def.name, def);\n                            scope.enclosed.push(def);\n                            scope.var_names().set(def.name, true);\n                        }),\n                        value: defn.value,\n                    });\n                }),\n            });\n        }\n\n        function can_varify(compressor, sym) {\n            var def = sym.definition();\n            return (def.fixed || def.fixed === 0)\n                && is_safe_lexical(def)\n                && same_scope(def)\n                && !may_overlap(compressor, def);\n        }\n\n        function varify(self, compressor) {\n            return compressor.option(\"varify\") && all(self.definitions, function(defn) {\n                return !defn.name.match_symbol(function(node) {\n                    if (node instanceof AST_SymbolDeclaration) return !can_varify(compressor, node);\n                }, true);\n            }) ? to_var(self, compressor.find_parent(AST_Scope)) : self;\n        }\n\n        OPT(AST_Const, varify);\n        OPT(AST_Let, varify);\n\n        function trim_optional_chain(node, compressor) {\n            if (!compressor.option(\"optional_chains\")) return;\n            if (node.terminal) do {\n                var expr = node.expression;\n                if (node.optional) {\n                    var ev = fuzzy_eval(compressor, expr, true);\n                    if (ev == null) return make_node(AST_UnaryPrefix, node, {\n                        operator: \"void\",\n                        expression: expr,\n                    }).optimize(compressor);\n                    if (!(ev instanceof AST_Node)) node.optional = false;\n                }\n                node = expr;\n            } while ((node.TYPE == \"Call\" || node instanceof AST_PropAccess) && !node.terminal);\n        }\n\n        function lift_sequence_in_expression(node, compressor) {\n            var exp = node.expression;\n            if (!(exp instanceof AST_Sequence)) return node;\n            var x = exp.expressions.slice();\n            var e = node.clone();\n            e.expression = x.pop();\n            x.push(e);\n            return make_sequence(node, x);\n        }\n\n        function drop_unused_call_args(call, compressor, fns_with_marked_args) {\n            var exp = call.expression;\n            var fn = exp instanceof AST_SymbolRef ? exp.fixed_value() : exp;\n            if (!(fn instanceof AST_Lambda)) return;\n            if (fn.uses_arguments) return;\n            if (fn.pinned()) return;\n            if (fns_with_marked_args && fns_with_marked_args.indexOf(fn) < 0) return;\n            var args = call.args;\n            if (!all(args, function(arg) {\n                return !(arg instanceof AST_Spread);\n            })) return;\n            var argnames = fn.argnames;\n            var is_iife = fn === exp && !fn.name;\n            if (fn.rest) {\n                if (!(is_iife && compressor.option(\"rests\"))) return;\n                var insert = argnames.length;\n                args = args.slice(0, insert);\n                while (args.length < insert) args.push(make_node(AST_Undefined, call).optimize(compressor));\n                args.push(make_node(AST_Array, call, { elements: call.args.slice(insert) }));\n                argnames = argnames.concat(fn.rest);\n                fn.rest = null;\n            } else {\n                args = args.slice();\n                argnames = argnames.slice();\n            }\n            var pos = 0, last = 0;\n            var drop_defaults = is_iife && compressor.option(\"default_values\");\n            var drop_fargs = is_iife && compressor.drop_fargs(fn, call) ? function(argname, arg) {\n                if (!argname) return true;\n                if (argname instanceof AST_DestructuredArray) {\n                    return argname.elements.length == 0 && !argname.rest && arg instanceof AST_Array;\n                }\n                if (argname instanceof AST_DestructuredObject) {\n                    return argname.properties.length == 0 && !argname.rest && arg && !arg.may_throw_on_access(compressor);\n                }\n                return argname.unused;\n            } : return_false;\n            var side_effects = [];\n            for (var i = 0; i < args.length; i++) {\n                var argname = argnames[i];\n                if (drop_defaults && argname instanceof AST_DefaultValue && args[i].is_defined(compressor)) {\n                    argnames[i] = argname = argname.name;\n                }\n                if (!argname || argname.unused !== undefined) {\n                    var node = args[i].drop_side_effect_free(compressor);\n                    if (drop_fargs(argname)) {\n                        if (argname) argnames.splice(i, 1);\n                        args.splice(i, 1);\n                        if (node) side_effects.push(node);\n                        i--;\n                        continue;\n                    } else if (node) {\n                        side_effects.push(node);\n                        args[pos++] = make_sequence(call, side_effects);\n                        side_effects = [];\n                    } else if (argname) {\n                        if (side_effects.length) {\n                            args[pos++] = make_sequence(call, side_effects);\n                            side_effects = [];\n                        } else {\n                            args[pos++] = make_node(AST_Number, args[i], { value: 0 });\n                            continue;\n                        }\n                    }\n                } else if (drop_fargs(argname, args[i])) {\n                    var node = args[i].drop_side_effect_free(compressor);\n                    argnames.splice(i, 1);\n                    args.splice(i, 1);\n                    if (node) side_effects.push(node);\n                    i--;\n                    continue;\n                } else {\n                    side_effects.push(args[i]);\n                    args[pos++] = make_sequence(call, side_effects);\n                    side_effects = [];\n                }\n                last = pos;\n            }\n            for (; i < argnames.length; i++) {\n                if (drop_fargs(argnames[i])) argnames.splice(i--, 1);\n            }\n            fn.argnames = argnames;\n            args.length = last;\n            call.args = args;\n            if (!side_effects.length) return;\n            var arg = make_sequence(call, side_effects);\n            args.push(args.length < argnames.length ? make_node(AST_UnaryPrefix, call, {\n                operator: \"void\",\n                expression: arg,\n            }) : arg);\n        }\n\n        function avoid_await_yield(compressor, parent_scope) {\n            if (!parent_scope) parent_scope = compressor.find_parent(AST_Scope);\n            var avoid = [];\n            if (is_async(parent_scope) || parent_scope instanceof AST_Toplevel && compressor.option(\"module\")) {\n                avoid.push(\"await\");\n            }\n            if (is_generator(parent_scope)) avoid.push(\"yield\");\n            return avoid.length && makePredicate(avoid);\n        }\n\n        function safe_from_await_yield(fn, avoid) {\n            if (!avoid) return true;\n            var safe = true;\n            var tw = new TreeWalker(function(node) {\n                if (!safe) return true;\n                if (node instanceof AST_Scope) {\n                    if (node === fn) return;\n                    if (is_arrow(node)) {\n                        for (var i = 0; safe && i < node.argnames.length; i++) node.argnames[i].walk(tw);\n                    } else if (node instanceof AST_LambdaDefinition && avoid[node.name.name]) {\n                        safe = false;\n                    }\n                    return true;\n                }\n                if (node instanceof AST_Symbol && avoid[node.name] && node !== fn.name) safe = false;\n            });\n            fn.walk(tw);\n            return safe;\n        }\n\n        function safe_from_strict_mode(fn, compressor) {\n            return fn.in_strict_mode(compressor) || !compressor.has_directive(\"use strict\");\n        }\n\n        OPT(AST_Call, function(self, compressor) {\n            var exp = self.expression;\n            var terminated = trim_optional_chain(self, compressor);\n            if (terminated) return terminated;\n            if (compressor.option(\"sequences\")) {\n                if (exp instanceof AST_PropAccess) {\n                    var seq = lift_sequence_in_expression(exp, compressor);\n                    if (seq !== exp) {\n                        var call = self.clone();\n                        call.expression = seq.expressions.pop();\n                        seq.expressions.push(call);\n                        return seq.optimize(compressor);\n                    }\n                } else if (!needs_unbinding(exp.tail_node())) {\n                    var seq = lift_sequence_in_expression(self, compressor);\n                    if (seq !== self) return seq.optimize(compressor);\n                }\n            }\n            if (compressor.option(\"unused\")) drop_unused_call_args(self, compressor);\n            if (compressor.option(\"unsafe\")) {\n                if (is_undeclared_ref(exp)) switch (exp.name) {\n                  case \"Array\":\n                    // Array(n) ---> [ , , ... , ]\n                    if (self.args.length == 1) {\n                        var first = self.args[0];\n                        if (first instanceof AST_Number) try {\n                            var length = first.value;\n                            if (length > 6) break;\n                            var elements = Array(length);\n                            for (var i = 0; i < length; i++) elements[i] = make_node(AST_Hole, self);\n                            return make_node(AST_Array, self, { elements: elements });\n                        } catch (ex) {\n                            AST_Node.warn(\"Invalid array length: {length} [{start}]\", {\n                                length: length,\n                                start: self.start,\n                            });\n                            break;\n                        }\n                        if (!first.is_boolean(compressor) && !first.is_string(compressor)) break;\n                    }\n                    // Array(...) ---> [ ... ]\n                    return make_node(AST_Array, self, { elements: self.args });\n                  case \"Object\":\n                    // Object() ---> {}\n                    if (self.args.length == 0) return make_node(AST_Object, self, { properties: [] });\n                    break;\n                  case \"String\":\n                    // String() ---> \"\"\n                    if (self.args.length == 0) return make_node(AST_String, self, { value: \"\" });\n                    // String(x) ---> \"\" + x\n                    if (self.args.length == 1) return make_node(AST_Binary, self, {\n                        operator: \"+\",\n                        left: make_node(AST_String, self, { value: \"\" }),\n                        right: self.args[0],\n                    }).optimize(compressor);\n                    break;\n                  case \"Number\":\n                    // Number() ---> 0\n                    if (self.args.length == 0) return make_node(AST_Number, self, { value: 0 });\n                    // Number(x) ---> +(\"\" + x)\n                    if (self.args.length == 1) return make_node(AST_UnaryPrefix, self, {\n                        operator: \"+\",\n                        expression: make_node(AST_Binary, self, {\n                            operator: \"+\",\n                            left: make_node(AST_String, self, { value: \"\" }),\n                            right: self.args[0],\n                        }),\n                    }).optimize(compressor);\n                    break;\n                  case \"Boolean\":\n                    // Boolean() ---> false\n                    if (self.args.length == 0) return make_node(AST_False, self).optimize(compressor);\n                    // Boolean(x) ---> !!x\n                    if (self.args.length == 1) return make_node(AST_UnaryPrefix, self, {\n                        operator: \"!\",\n                        expression: make_node(AST_UnaryPrefix, self, {\n                            operator: \"!\",\n                            expression: self.args[0],\n                        }),\n                    }).optimize(compressor);\n                    break;\n                  case \"RegExp\":\n                    // attempt to convert RegExp(...) to literal\n                    var params = [];\n                    if (all(self.args, function(arg) {\n                        var value = arg.evaluate(compressor);\n                        params.unshift(value);\n                        return arg !== value;\n                    })) try {\n                        return best_of(compressor, self, make_node(AST_RegExp, self, {\n                            value: RegExp.apply(RegExp, params),\n                        }));\n                    } catch (ex) {\n                        AST_Node.warn(\"Error converting {this} [{start}]\", self);\n                    }\n                    break;\n                } else if (exp instanceof AST_Dot) switch (exp.property) {\n                  case \"toString\":\n                    // x.toString() ---> \"\" + x\n                    var expr = exp.expression;\n                    if (self.args.length == 0 && !(expr.may_throw_on_access(compressor) || expr instanceof AST_Super)) {\n                        return make_node(AST_Binary, self, {\n                            operator: \"+\",\n                            left: make_node(AST_String, self, { value: \"\" }),\n                            right: expr,\n                        }).optimize(compressor);\n                    }\n                    break;\n                  case \"join\":\n                    if (exp.expression instanceof AST_Array && self.args.length < 2) EXIT: {\n                        var separator = self.args[0];\n                        // [].join() ---> \"\"\n                        // [].join(x) ---> (x, \"\")\n                        if (exp.expression.elements.length == 0 && !(separator instanceof AST_Spread)) {\n                            return separator ? make_sequence(self, [\n                                separator,\n                                make_node(AST_String, self, { value: \"\" }),\n                            ]).optimize(compressor) : make_node(AST_String, self, { value: \"\" });\n                        }\n                        if (separator) {\n                            separator = separator.evaluate(compressor);\n                            if (separator instanceof AST_Node) break EXIT; // not a constant\n                        }\n                        var elements = [];\n                        var consts = [];\n                        for (var i = 0; i < exp.expression.elements.length; i++) {\n                            var el = exp.expression.elements[i];\n                            var value = el.evaluate(compressor);\n                            if (value !== el) {\n                                consts.push(value);\n                            } else if (el instanceof AST_Spread) {\n                                break EXIT;\n                            } else {\n                                if (consts.length > 0) {\n                                    elements.push(make_node(AST_String, self, { value: consts.join(separator) }));\n                                    consts.length = 0;\n                                }\n                                elements.push(el);\n                            }\n                        }\n                        if (consts.length > 0) elements.push(make_node(AST_String, self, {\n                            value: consts.join(separator),\n                        }));\n                        // [ x ].join() ---> \"\" + x\n                        // [ x ].join(\".\") ---> \"\" + x\n                        // [ 1, 2, 3 ].join() ---> \"1,2,3\"\n                        // [ 1, 2, 3 ].join(\".\") ---> \"1.2.3\"\n                        if (elements.length == 1) {\n                            if (elements[0].is_string(compressor)) return elements[0];\n                            return make_node(AST_Binary, elements[0], {\n                                operator: \"+\",\n                                left: make_node(AST_String, self, { value: \"\" }),\n                                right: elements[0],\n                            });\n                        }\n                        // [ 1, 2, a, 3 ].join(\"\") ---> \"12\" + a + \"3\"\n                        if (separator == \"\") {\n                            var first;\n                            if (elements[0].is_string(compressor) || elements[1].is_string(compressor)) {\n                                first = elements.shift();\n                            } else {\n                                first = make_node(AST_String, self, { value: \"\" });\n                            }\n                            return elements.reduce(function(prev, el) {\n                                return make_node(AST_Binary, el, {\n                                    operator: \"+\",\n                                    left: prev,\n                                    right: el,\n                                });\n                            }, first).optimize(compressor);\n                        }\n                        // [ x, \"foo\", \"bar\", y ].join() ---> [ x, \"foo,bar\", y ].join()\n                        // [ x, \"foo\", \"bar\", y ].join(\"-\") ---> [ x, \"foo-bar\", y ].join(\"-\")\n                        // need this awkward cloning to not affect original element\n                        // best_of will decide which one to get through.\n                        var node = self.clone();\n                        node.expression = node.expression.clone();\n                        node.expression.expression = node.expression.expression.clone();\n                        node.expression.expression.elements = elements;\n                        return best_of(compressor, self, node);\n                    }\n                    break;\n                  case \"charAt\":\n                    if (self.args.length < 2) {\n                        var node = make_node(AST_Binary, self, {\n                            operator: \"||\",\n                            left: make_node(AST_Sub, self, {\n                                expression: exp.expression,\n                                property: self.args.length ? make_node(AST_Binary, self.args[0], {\n                                    operator: \"|\",\n                                    left: make_node(AST_Number, self, { value: 0 }),\n                                    right: self.args[0],\n                                }) : make_node(AST_Number, self, { value: 0 }),\n                            }).optimize(compressor),\n                            right: make_node(AST_String, self, { value: \"\" }),\n                        });\n                        node.is_string = return_true;\n                        return node.optimize(compressor);\n                    }\n                    break;\n                  case \"apply\":\n                    if (self.args.length == 2 && self.args[1] instanceof AST_Array) {\n                        var args = self.args[1].elements.slice();\n                        args.unshift(self.args[0]);\n                        return make_node(AST_Call, self, {\n                            expression: make_node(AST_Dot, exp, {\n                                expression: exp.expression,\n                                property: \"call\",\n                            }),\n                            args: args,\n                        }).optimize(compressor);\n                    }\n                    break;\n                  case \"call\":\n                    var func = exp.expression;\n                    if (func instanceof AST_SymbolRef) {\n                        func = func.fixed_value();\n                    }\n                    if (func instanceof AST_Lambda && !func.contains_this()) {\n                        return (self.args.length ? make_sequence(self, [\n                            self.args[0],\n                            make_node(AST_Call, self, {\n                                expression: exp.expression,\n                                args: self.args.slice(1),\n                            }),\n                        ]) : make_node(AST_Call, self, {\n                            expression: exp.expression,\n                            args: [],\n                        })).optimize(compressor);\n                    }\n                    break;\n                } else if (compressor.option(\"side_effects\")\n                    && exp instanceof AST_Call\n                    && exp.args.length == 1\n                    && is_undeclared_ref(exp.expression)\n                    && exp.expression.name == \"Object\") {\n                    var call = self.clone();\n                    call.expression = maintain_this_binding(self, exp, exp.args[0]);\n                    return call.optimize(compressor);\n                }\n            }\n            if (compressor.option(\"unsafe_Function\")\n                && is_undeclared_ref(exp)\n                && exp.name == \"Function\") {\n                // new Function() ---> function(){}\n                if (self.args.length == 0) return make_node(AST_Function, self, {\n                    argnames: [],\n                    body: [],\n                }).init_vars(exp.scope);\n                if (all(self.args, function(x) {\n                    return x instanceof AST_String;\n                })) {\n                    // quite a corner-case, but we can handle it:\n                    //   https://github.com/mishoo/UglifyJS/issues/203\n                    // if the code argument is a constant, then we can minify it.\n                    try {\n                        var code = \"n(function(\" + self.args.slice(0, -1).map(function(arg) {\n                            return arg.value;\n                        }).join() + \"){\" + self.args[self.args.length - 1].value + \"})\";\n                        var ast = parse(code);\n                        var mangle = { ie: compressor.option(\"ie\") };\n                        ast.figure_out_scope(mangle);\n                        var comp = new Compressor(compressor.options);\n                        ast = ast.transform(comp);\n                        ast.figure_out_scope(mangle);\n                        ast.compute_char_frequency(mangle);\n                        ast.mangle_names(mangle);\n                        var fun;\n                        ast.walk(new TreeWalker(function(node) {\n                            if (fun) return true;\n                            if (node instanceof AST_Lambda) {\n                                fun = node;\n                                return true;\n                            }\n                        }));\n                        var code = OutputStream();\n                        AST_BlockStatement.prototype._codegen.call(fun, code);\n                        self.args = [\n                            make_node(AST_String, self, {\n                                value: fun.argnames.map(function(arg) {\n                                    return arg.print_to_string();\n                                }).join(),\n                            }),\n                            make_node(AST_String, self.args[self.args.length - 1], {\n                                value: code.get().replace(/^\\{|\\}$/g, \"\")\n                            }),\n                        ];\n                        return self;\n                    } catch (ex) {\n                        if (ex instanceof JS_Parse_Error) {\n                            AST_Node.warn(\"Error parsing code passed to new Function [{start}]\", self.args[self.args.length - 1]);\n                            AST_Node.warn(ex.toString());\n                        } else {\n                            throw ex;\n                        }\n                    }\n                }\n            }\n            var fn = exp instanceof AST_SymbolRef ? exp.fixed_value() : exp;\n            var parent = compressor.parent(), current = compressor.self();\n            var is_func = fn instanceof AST_Lambda\n                && (!is_async(fn) || compressor.option(\"awaits\") && parent instanceof AST_Await)\n                && (!is_generator(fn) || compressor.option(\"yields\") && current instanceof AST_Yield && current.nested);\n            var stat = is_func && fn.first_statement();\n            var has_default = 0, has_destructured = false;\n            var has_spread = !all(self.args, function(arg) {\n                return !(arg instanceof AST_Spread);\n            });\n            var can_drop = is_func && all(fn.argnames, function(argname, index) {\n                if (has_default == 1 && self.args[index] instanceof AST_Spread) has_default = 2;\n                if (argname instanceof AST_DefaultValue) {\n                    if (!has_default) has_default = 1;\n                    var arg = has_default == 1 && self.args[index];\n                    if (!is_undefined(arg)) has_default = 2;\n                    if (has_arg_refs(fn, argname.value)) return false;\n                    argname = argname.name;\n                }\n                if (argname instanceof AST_Destructured) {\n                    has_destructured = true;\n                    if (has_arg_refs(fn, argname)) return false;\n                }\n                return true;\n            }) && !(fn.rest instanceof AST_Destructured && has_arg_refs(fn, fn.rest));\n            var can_inline = can_drop\n                && compressor.option(\"inline\")\n                && !self.is_expr_pure(compressor)\n                && (exp === fn || safe_from_strict_mode(fn, compressor));\n            if (can_inline && stat instanceof AST_Return) {\n                var value = stat.value;\n                if (exp === fn\n                    && !fn.name\n                    && (!value || value.is_constant_expression())\n                    && safe_from_await_yield(fn, avoid_await_yield(compressor))) {\n                    return make_sequence(self, convert_args(value)).optimize(compressor);\n                }\n            }\n            if (is_func && !fn.contains_this()) {\n                var def, value, var_assigned = false;\n                if (can_inline\n                    && !fn.uses_arguments\n                    && !fn.pinned()\n                    && !(fn.name && fn instanceof AST_LambdaExpression)\n                    && (exp === fn || !recursive_ref(compressor, def = exp.definition(), fn)\n                        && fn.is_constant_expression(find_scope(compressor)))\n                    && (value = can_flatten_body(stat))) {\n                    var replacing = exp === fn || def.single_use && def.references.length - def.replaced == 1;\n                    if (can_substitute_directly()) {\n                        var args = self.args.slice();\n                        var refs = [];\n                        var retValue = value.clone(true).transform(new TreeTransformer(function(node) {\n                            if (node instanceof AST_SymbolRef) {\n                                var def = node.definition();\n                                if (fn.variables.get(node.name) !== def) {\n                                    refs.push(node);\n                                    return node;\n                                }\n                                var index = resolve_index(def);\n                                var arg = args[index];\n                                if (!arg) return make_node(AST_Undefined, self);\n                                args[index] = null;\n                                var parent = this.parent();\n                                return parent ? maintain_this_binding(parent, node, arg) : arg;\n                            }\n                        }));\n                        var save_inlined = fn.inlined;\n                        if (exp !== fn) fn.inlined = true;\n                        var exprs = [];\n                        args.forEach(function(arg) {\n                            if (!arg) return;\n                            arg = arg.clone(true);\n                            arg.walk(new TreeWalker(function(node) {\n                                if (node instanceof AST_SymbolRef) refs.push(node);\n                            }));\n                            exprs.push(arg);\n                        }, []);\n                        exprs.push(retValue);\n                        var node = make_sequence(self, exprs).optimize(compressor);\n                        fn.inlined = save_inlined;\n                        node = maintain_this_binding(parent, current, node);\n                        if (replacing || best_of_expression(node, self) === node) {\n                            refs.forEach(function(ref) {\n                                ref.scope = exp === fn ? fn.parent_scope : exp.scope;\n                                ref.reference();\n                                var def = ref.definition();\n                                if (replacing) def.replaced++;\n                                def.single_use = false;\n                            });\n                            return node;\n                        } else if (!node.has_side_effects(compressor)) {\n                            self.drop_side_effect_free = function(compressor, first_in_statement) {\n                                var self = this;\n                                var exprs = self.args.slice();\n                                exprs.unshift(self.expression);\n                                return make_sequence(self, exprs).drop_side_effect_free(compressor, first_in_statement);\n                            };\n                        }\n                    }\n                    var arg_used, insert, in_loop, scope;\n                    if (replacing && can_inject_symbols()) {\n                        fn._squeezed = true;\n                        if (exp !== fn) fn.parent_scope = exp.scope;\n                        var node = make_sequence(self, flatten_fn()).optimize(compressor);\n                        return maintain_this_binding(parent, current, node);\n                    }\n                }\n                if (compressor.option(\"side_effects\")\n                    && can_drop\n                    && all(fn.body, is_empty)\n                    && (fn === exp ? fn_name_unused(fn, compressor) : !has_default && !has_destructured && !fn.rest)\n                    && !(is_arrow(fn) && fn.value)\n                    && safe_from_await_yield(fn, avoid_await_yield(compressor))) {\n                    return make_sequence(self, convert_args()).optimize(compressor);\n                }\n            }\n            if (compressor.option(\"drop_console\")) {\n                if (exp instanceof AST_PropAccess) {\n                    var name = exp.expression;\n                    while (name.expression) {\n                        name = name.expression;\n                    }\n                    if (is_undeclared_ref(name) && name.name == \"console\") {\n                        return make_node(AST_Undefined, self).optimize(compressor);\n                    }\n                }\n            }\n            if (compressor.option(\"negate_iife\") && parent instanceof AST_SimpleStatement && is_iife_call(current)) {\n                return self.negate(compressor, true);\n            }\n            return try_evaluate(compressor, self);\n\n            function make_void_lhs(orig) {\n                return make_node(AST_Sub, orig, {\n                    expression: make_node(AST_Array, orig, { elements: [] }),\n                    property: make_node(AST_Number, orig, { value: 0 }),\n                });\n            }\n\n            function convert_args(value) {\n                var args = self.args.slice();\n                var destructured = has_default > 1 || has_destructured || fn.rest;\n                if (destructured || has_spread) args = [ make_node(AST_Array, self, { elements: args }) ];\n                if (destructured) {\n                    var tt = new TreeTransformer(function(node, descend) {\n                        if (node instanceof AST_DefaultValue) return make_node(AST_DefaultValue, node, {\n                            name: node.name.transform(tt) || make_void_lhs(node),\n                            value: node.value,\n                        });\n                        if (node instanceof AST_DestructuredArray) {\n                            var elements = [];\n                            node.elements.forEach(function(node, index) {\n                                node = node.transform(tt);\n                                if (node) elements[index] = node;\n                            });\n                            fill_holes(node, elements);\n                            return make_node(AST_DestructuredArray, node, { elements: elements });\n                        }\n                        if (node instanceof AST_DestructuredObject) {\n                            var properties = [], side_effects = [];\n                            node.properties.forEach(function(prop) {\n                                var key = prop.key;\n                                var value = prop.value.transform(tt);\n                                if (value) {\n                                    if (side_effects.length) {\n                                        if (!(key instanceof AST_Node)) key = make_node_from_constant(key, prop);\n                                        side_effects.push(key);\n                                        key = make_sequence(node, side_effects);\n                                        side_effects = [];\n                                    }\n                                    properties.push(make_node(AST_DestructuredKeyVal, prop, {\n                                        key: key,\n                                        value: value,\n                                    }));\n                                } else if (key instanceof AST_Node) {\n                                    side_effects.push(key);\n                                }\n                            });\n                            if (side_effects.length) properties.push(make_node(AST_DestructuredKeyVal, node, {\n                                key: make_sequence(node, side_effects),\n                                value: make_void_lhs(node),\n                            }));\n                            return make_node(AST_DestructuredObject, node, { properties: properties });\n                        }\n                        if (node instanceof AST_SymbolFunarg) return null;\n                    });\n                    var lhs = [];\n                    fn.argnames.forEach(function(argname, index) {\n                        argname = argname.transform(tt);\n                        if (argname) lhs[index] = argname;\n                    });\n                    var rest = fn.rest && fn.rest.transform(tt);\n                    if (rest) lhs.length = fn.argnames.length;\n                    fill_holes(fn, lhs);\n                    args[0] = make_node(AST_Assign, self, {\n                        operator: \"=\",\n                        left: make_node(AST_DestructuredArray, fn, {\n                            elements: lhs,\n                            rest: rest,\n                        }),\n                        right: args[0],\n                    });\n                } else fn.argnames.forEach(function(argname) {\n                    if (argname instanceof AST_DefaultValue) args.push(argname.value);\n                });\n                args.push(value || make_node(AST_Undefined, self));\n                return args;\n            }\n\n            function noop_value() {\n                return self.call_only ? make_node(AST_Number, self, { value: 0 }) : make_node(AST_Undefined, self);\n            }\n\n            function return_value(stat) {\n                if (!stat) return noop_value();\n                if (stat instanceof AST_Return) return stat.value || noop_value();\n                if (stat instanceof AST_SimpleStatement) {\n                    return self.call_only ? stat.body : make_node(AST_UnaryPrefix, stat, {\n                        operator: \"void\",\n                        expression: stat.body,\n                    });\n                }\n            }\n\n            function can_flatten_body(stat) {\n                var len = fn.body.length;\n                if (len < 2) {\n                    stat = return_value(stat);\n                    if (stat) return stat;\n                }\n                if (compressor.option(\"inline\") < 3) return false;\n                stat = null;\n                for (var i = 0; i < len; i++) {\n                    var line = fn.body[i];\n                    if (line instanceof AST_Var) {\n                        if (var_assigned) {\n                            if (!stat) continue;\n                            if (!(stat instanceof AST_SimpleStatement)) return false;\n                            if (!declarations_only(line)) stat = null;\n                        } else if (!declarations_only(line)) {\n                            if (stat && !(stat instanceof AST_SimpleStatement)) return false;\n                            stat = null;\n                            var_assigned = true;\n                        }\n                    } else if (line instanceof AST_AsyncDefun\n                        || line instanceof AST_Defun\n                        || line instanceof AST_EmptyStatement) {\n                        continue;\n                    } else if (stat) {\n                        return false;\n                    } else {\n                        stat = line;\n                    }\n                }\n                return return_value(stat);\n            }\n\n            function resolve_index(def) {\n                for (var i = fn.argnames.length; --i >= 0;) {\n                    if (fn.argnames[i].definition() === def) return i;\n                }\n            }\n\n            function can_substitute_directly() {\n                if (has_default || has_destructured || has_spread || var_assigned || fn.rest) return;\n                if (compressor.option(\"inline\") < 2 && fn.argnames.length) return;\n                if (!fn.variables.all(function(def) {\n                    return def.references.length - def.replaced < 2 && def.orig[0] instanceof AST_SymbolFunarg;\n                })) return;\n                var scope = compressor.find_parent(AST_Scope);\n                var abort = false;\n                var avoid = avoid_await_yield(compressor, scope);\n                var begin;\n                var in_order = [];\n                var side_effects = false;\n                var tw = new TreeWalker(function(node, descend) {\n                    if (abort) return true;\n                    if (node instanceof AST_Binary && lazy_op[node.operator]\n                        || node instanceof AST_Conditional) {\n                        in_order = null;\n                        return;\n                    }\n                    if (node instanceof AST_Scope) return abort = true;\n                    if (avoid && node instanceof AST_Symbol && avoid[node.name]) return abort = true;\n                    if (node instanceof AST_SymbolRef) {\n                        var def = node.definition();\n                        if (fn.variables.get(node.name) !== def) {\n                            in_order = null;\n                            return;\n                        }\n                        if (def.init instanceof AST_LambdaDefinition) return abort = true;\n                        if (is_lhs(node, tw.parent())) return abort = true;\n                        var index = resolve_index(def);\n                        if (!(begin < index)) begin = index;\n                        if (!in_order) return;\n                        if (side_effects) {\n                            in_order = null;\n                        } else {\n                            in_order.push(fn.argnames[index]);\n                        }\n                        return;\n                    }\n                    if (side_effects) return;\n                    if (node instanceof AST_Assign && node.left instanceof AST_PropAccess) {\n                        node.left.expression.walk(tw);\n                        if (node.left instanceof AST_Sub) node.left.property.walk(tw);\n                        node.right.walk(tw);\n                        side_effects = true;\n                        return true;\n                    }\n                    if (node.has_side_effects(compressor)) {\n                        descend();\n                        side_effects = true;\n                        return true;\n                    }\n                });\n                value.walk(tw);\n                if (abort) return;\n                var end = self.args.length;\n                if (in_order && fn.argnames.length >= end) {\n                    end = fn.argnames.length;\n                    while (end-- > begin && fn.argnames[end] === in_order.pop());\n                    end++;\n                }\n                return end <= begin || all(self.args.slice(begin, end), side_effects && !in_order ? function(funarg) {\n                    return funarg.is_constant_expression(scope);\n                } : function(funarg) {\n                    return !funarg.has_side_effects(compressor);\n                });\n            }\n\n            function var_exists(defined, name) {\n                return defined.has(name) || identifier_atom[name] || scope.var_names().has(name);\n            }\n\n            function can_inject_args(defined, safe_to_inject) {\n                var abort = false;\n                fn.each_argname(function(arg) {\n                    if (abort) return;\n                    if (arg.unused) return;\n                    if (!safe_to_inject || var_exists(defined, arg.name)) return abort = true;\n                    arg_used.set(arg.name, true);\n                    if (in_loop) in_loop.push(arg.definition());\n                });\n                return !abort;\n            }\n\n            function can_inject_vars(defined, safe_to_inject) {\n                for (var i = 0; i < fn.body.length; i++) {\n                    var stat = fn.body[i];\n                    if (stat instanceof AST_LambdaDefinition) {\n                        var name = stat.name;\n                        if (!safe_to_inject) return false;\n                        if (arg_used.has(name.name)) return false;\n                        if (var_exists(defined, name.name)) return false;\n                        if (!all(stat.enclosed, function(def) {\n                            return def.scope === scope || def.scope === stat || !defined.has(def.name);\n                        })) return false;\n                        if (in_loop) in_loop.push(name.definition());\n                        continue;\n                    }\n                    if (!(stat instanceof AST_Var)) continue;\n                    if (!safe_to_inject) return false;\n                    for (var j = stat.definitions.length; --j >= 0;) {\n                        var name = stat.definitions[j].name;\n                        if (var_exists(defined, name.name)) return false;\n                        if (in_loop) in_loop.push(name.definition());\n                    }\n                }\n                return true;\n            }\n\n            function can_inject_symbols() {\n                var defined = new Dictionary();\n                var level = 0, child;\n                scope = current;\n                do {\n                    if (scope.variables) scope.variables.each(function(def) {\n                        defined.set(def.name, true);\n                    });\n                    child = scope;\n                    scope = compressor.parent(level++);\n                    if (scope instanceof AST_ClassField) {\n                        if (!scope.static) return false;\n                    } else if (scope instanceof AST_DWLoop) {\n                        in_loop = [];\n                    } else if (scope instanceof AST_For) {\n                        if (scope.init === child) continue;\n                        in_loop = [];\n                    } else if (scope instanceof AST_ForEnumeration) {\n                        if (scope.init === child) continue;\n                        if (scope.object === child) continue;\n                        in_loop = [];\n                    }\n                } while (!(scope instanceof AST_Scope));\n                insert = scope.body.indexOf(child) + 1;\n                if (!insert) return false;\n                if (!safe_from_await_yield(fn, avoid_await_yield(compressor, scope))) return false;\n                var safe_to_inject = (exp !== fn || fn.parent_scope.resolve() === scope) && !scope.pinned();\n                if (scope instanceof AST_Toplevel) {\n                    if (compressor.toplevel.vars) {\n                        defined.set(\"arguments\", true);\n                    } else {\n                        safe_to_inject = false;\n                    }\n                }\n                arg_used = new Dictionary();\n                var inline = compressor.option(\"inline\");\n                if (!can_inject_args(defined, inline >= 2 && safe_to_inject)) return false;\n                if (!can_inject_vars(defined, inline >= 3 && safe_to_inject)) return false;\n                return !in_loop || in_loop.length == 0 || !is_reachable(fn, in_loop);\n            }\n\n            function append_var(decls, expressions, name, value) {\n                var def = name.definition();\n                if (!scope.var_names().has(name.name)) {\n                    scope.var_names().set(name.name, true);\n                    decls.push(make_node(AST_VarDef, name, {\n                        name: name,\n                        value: null,\n                    }));\n                }\n                scope.variables.set(name.name, def);\n                scope.enclosed.push(def);\n                if (!value) return;\n                var sym = make_node(AST_SymbolRef, name);\n                def.assignments++;\n                def.references.push(sym);\n                expressions.push(make_node(AST_Assign, self, {\n                    operator: \"=\",\n                    left: sym,\n                    right: value,\n                }));\n            }\n\n            function flatten_args(decls, expressions) {\n                var len = fn.argnames.length;\n                for (var i = self.args.length; --i >= len;) {\n                    expressions.push(self.args[i]);\n                }\n                var default_args = [];\n                for (i = len; --i >= 0;) {\n                    var argname = fn.argnames[i];\n                    var name;\n                    if (argname instanceof AST_DefaultValue) {\n                        default_args.push(argname);\n                        name = argname.name;\n                    } else {\n                        name = argname;\n                    }\n                    var value = self.args[i];\n                    if (name.unused || scope.var_names().has(name.name)) {\n                        if (value) expressions.push(value);\n                    } else {\n                        var symbol = make_node(AST_SymbolVar, name);\n                        var def = name.definition();\n                        def.orig.push(symbol);\n                        def.eliminated++;\n                        if (name.unused !== undefined) {\n                            append_var(decls, expressions, symbol);\n                            if (value) expressions.push(value);\n                        } else {\n                            if (!value && argname === name && (in_loop\n                                || name.name == \"arguments\" && !is_arrow(fn) && is_arrow(scope))) {\n                                value = make_node(AST_Undefined, self);\n                            }\n                            append_var(decls, expressions, symbol, value);\n                        }\n                    }\n                }\n                decls.reverse();\n                expressions.reverse();\n                for (i = default_args.length; --i >= 0;) {\n                    var node = default_args[i];\n                    if (node.name.unused !== undefined) {\n                        expressions.push(node.value);\n                    } else {\n                        var sym = make_node(AST_SymbolRef, node.name);\n                        node.name.definition().references.push(sym);\n                        expressions.push(make_node(AST_Assign, node, {\n                            operator: \"=\",\n                            left: sym,\n                            right: node.value,\n                        }));\n                    }\n                }\n            }\n\n            function flatten_destructured(decls, expressions) {\n                expressions.push(make_node(AST_Assign, self, {\n                    operator: \"=\",\n                    left: make_node(AST_DestructuredArray, self, {\n                        elements: fn.argnames.map(function(argname) {\n                            if (argname.unused) return make_node(AST_Hole, argname);\n                            return argname.convert_symbol(AST_SymbolRef, process);\n                        }),\n                        rest: fn.rest && fn.rest.convert_symbol(AST_SymbolRef, process),\n                    }),\n                    right: make_node(AST_Array, self, { elements: self.args.slice() }),\n                }));\n\n                function process(ref, name) {\n                    if (name.unused) return make_void_lhs(name);\n                    var def = name.definition();\n                    def.assignments++;\n                    def.references.push(ref);\n                    var symbol = make_node(AST_SymbolVar, name);\n                    def.orig.push(symbol);\n                    def.eliminated++;\n                    append_var(decls, expressions, symbol);\n                }\n            }\n\n            function flatten_vars(decls, expressions) {\n                var args = [ insert, 0 ];\n                var decl_var = [], expr_fn = [], expr_var = [], expr_loop = [], exprs = [];\n                fn.body.filter(in_loop ? function(stat) {\n                    if (!(stat instanceof AST_LambdaDefinition)) return true;\n                    var name = make_node(AST_SymbolVar, flatten_var(stat.name));\n                    var def = name.definition();\n                    def.fixed = false;\n                    def.orig.push(name);\n                    def.eliminated++;\n                    append_var(decls, expr_fn, name, to_func_expr(stat, true));\n                    return false;\n                } : function(stat) {\n                    if (!(stat instanceof AST_LambdaDefinition)) return true;\n                    var def = stat.name.definition();\n                    scope.functions.set(def.name, def);\n                    scope.variables.set(def.name, def);\n                    scope.enclosed.push(def);\n                    scope.var_names().set(def.name, true);\n                    args.push(stat);\n                    return false;\n                }).forEach(function(stat) {\n                    if (!(stat instanceof AST_Var)) {\n                        if (stat instanceof AST_SimpleStatement) exprs.push(stat.body);\n                        return;\n                    }\n                    for (var j = 0; j < stat.definitions.length; j++) {\n                        var var_def = stat.definitions[j];\n                        var name = flatten_var(var_def.name);\n                        var value = var_def.value;\n                        if (value && exprs.length > 0) {\n                            exprs.push(value);\n                            value = make_sequence(var_def, exprs);\n                            exprs = [];\n                        }\n                        append_var(decl_var, expr_var, name, value);\n                        if (!in_loop) continue;\n                        if (arg_used.has(name.name)) continue;\n                        if (name.definition().orig.length == 1 && fn.functions.has(name.name)) continue;\n                        expr_loop.push(init_ref(compressor, name));\n                    }\n                });\n                [].push.apply(decls, decl_var);\n                [].push.apply(expressions, expr_loop);\n                [].push.apply(expressions, expr_fn);\n                [].push.apply(expressions, expr_var);\n                return args;\n            }\n\n            function flatten_fn() {\n                var decls = [];\n                var expressions = [];\n                if (has_default > 1 || has_destructured || has_spread || fn.rest) {\n                    flatten_destructured(decls, expressions);\n                } else {\n                    flatten_args(decls, expressions);\n                }\n                var args = flatten_vars(decls, expressions);\n                expressions.push(value);\n                if (decls.length) args.push(make_node(AST_Var, fn, { definitions: decls }));\n                [].splice.apply(scope.body, args);\n                fn.enclosed.forEach(function(def) {\n                    if (scope.var_names().has(def.name)) return;\n                    scope.enclosed.push(def);\n                    scope.var_names().set(def.name, true);\n                });\n                return expressions;\n            }\n        });\n\n        OPT(AST_New, function(self, compressor) {\n            if (compressor.option(\"unsafe\")) {\n                var exp = self.expression;\n                if (is_undeclared_ref(exp)) switch (exp.name) {\n                  case \"Array\":\n                  case \"Error\":\n                  case \"Function\":\n                  case \"Object\":\n                  case \"RegExp\":\n                    return make_node(AST_Call, self).transform(compressor);\n                }\n            }\n            if (compressor.option(\"sequences\")) {\n                var seq = lift_sequence_in_expression(self, compressor);\n                if (seq !== self) return seq.optimize(compressor);\n            }\n            if (compressor.option(\"unused\")) drop_unused_call_args(self, compressor);\n            return self;\n        });\n\n        // (a = b, x && a = c) ---> a = x ? c : b\n        // (a = b, x || a = c) ---> a = x ? b : c\n        function to_conditional_assignment(compressor, def, value, node) {\n            if (!(node instanceof AST_Binary)) return;\n            if (!(node.operator == \"&&\" || node.operator == \"||\")) return;\n            if (!(node.right instanceof AST_Assign)) return;\n            if (node.right.operator != \"=\") return;\n            if (!(node.right.left instanceof AST_SymbolRef)) return;\n            if (node.right.left.definition() !== def) return;\n            if (value.has_side_effects(compressor)) return;\n            if (!safe_from_assignment(node.left)) return;\n            if (!safe_from_assignment(node.right.right)) return;\n            def.replaced++;\n            return node.operator == \"&&\" ? make_node(AST_Conditional, node, {\n                condition: node.left,\n                consequent: node.right.right,\n                alternative: value,\n            }) : make_node(AST_Conditional, node, {\n                condition: node.left,\n                consequent: value,\n                alternative: node.right.right,\n            });\n\n            function safe_from_assignment(node) {\n                if (node.has_side_effects(compressor)) return;\n                var hit = false;\n                node.walk(new TreeWalker(function(node) {\n                    if (hit) return true;\n                    if (node instanceof AST_SymbolRef && node.definition() === def) return hit = true;\n                }));\n                return !hit;\n            }\n        }\n\n        OPT(AST_Sequence, function(self, compressor) {\n            var expressions = filter_for_side_effects();\n            var end = expressions.length - 1;\n            merge_assignments();\n            trim_right_for_undefined();\n            if (end == 0) {\n                self = maintain_this_binding(compressor.parent(), compressor.self(), expressions[0]);\n                if (!(self instanceof AST_Sequence)) self = self.optimize(compressor);\n                return self;\n            }\n            self.expressions = expressions;\n            return self;\n\n            function filter_for_side_effects() {\n                if (!compressor.option(\"side_effects\")) return self.expressions;\n                var expressions = [];\n                var first = first_in_statement(compressor);\n                var last = self.expressions.length - 1;\n                self.expressions.forEach(function(expr, index) {\n                    if (index < last) expr = expr.drop_side_effect_free(compressor, first);\n                    if (expr) {\n                        merge_sequence(expressions, expr);\n                        first = false;\n                    }\n                });\n                return expressions;\n            }\n\n            function trim_right_for_undefined() {\n                if (!compressor.option(\"side_effects\")) return;\n                while (end > 0 && is_undefined(expressions[end], compressor)) end--;\n                if (end < expressions.length - 1) {\n                    expressions[end] = make_node(AST_UnaryPrefix, self, {\n                        operator: \"void\",\n                        expression: expressions[end],\n                    });\n                    expressions.length = end + 1;\n                }\n            }\n\n            function is_simple_assign(node) {\n                return node instanceof AST_Assign\n                    && node.operator == \"=\"\n                    && node.left instanceof AST_SymbolRef\n                    && node.left.definition();\n            }\n\n            function merge_assignments() {\n                for (var i = 1; i < end; i++) {\n                    var prev = expressions[i - 1];\n                    var def = is_simple_assign(prev);\n                    if (!def) continue;\n                    var expr = expressions[i];\n                    if (compressor.option(\"conditionals\")) {\n                        var cond = to_conditional_assignment(compressor, def, prev.right, expr);\n                        if (cond) {\n                            prev.right = cond;\n                            expressions.splice(i--, 1);\n                            end--;\n                            continue;\n                        }\n                    }\n                    if (compressor.option(\"dead_code\")\n                        && is_simple_assign(expr) === def\n                        && expr.right.is_constant_expression(def.scope.resolve())) {\n                        expressions[--i] = prev.right;\n                    }\n                }\n            }\n        });\n\n        OPT(AST_UnaryPostfix, function(self, compressor) {\n            if (compressor.option(\"sequences\")) {\n                var seq = lift_sequence_in_expression(self, compressor);\n                if (seq !== self) return seq.optimize(compressor);\n            }\n            return try_evaluate(compressor, self);\n        });\n\n        var SIGN_OPS = makePredicate(\"+ -\");\n        var MULTIPLICATIVE_OPS = makePredicate(\"* / %\");\n        OPT(AST_UnaryPrefix, function(self, compressor) {\n            var op = self.operator;\n            var exp = self.expression;\n            if (compressor.option(\"sequences\") && can_lift()) {\n                var seq = lift_sequence_in_expression(self, compressor);\n                if (seq !== self) return seq.optimize(compressor);\n            }\n            switch (op) {\n              case \"+\":\n                if (!compressor.option(\"evaluate\")) break;\n                if (!exp.is_number(compressor, true)) break;\n                var parent = compressor.parent();\n                if (parent instanceof AST_UnaryPrefix && parent.operator == \"delete\") break;\n                return exp;\n              case \"-\":\n                if (exp instanceof AST_Infinity) exp = exp.transform(compressor);\n                // avoids infinite recursion of numerals\n                if (exp instanceof AST_Number || exp instanceof AST_Infinity) return self;\n                break;\n              case \"!\":\n                if (!compressor.option(\"booleans\")) break;\n                if (exp.is_truthy()) return make_sequence(self, [ exp, make_node(AST_False, self) ]).optimize(compressor);\n                if (compressor.in_boolean_context()) {\n                    // !!foo ---> foo, if we're in boolean context\n                    if (exp instanceof AST_UnaryPrefix && exp.operator == \"!\") return exp.expression;\n                    if (exp instanceof AST_Binary) {\n                        var first = first_in_statement(compressor);\n                        self = (first ? best_of_statement : best_of_expression)(self, exp.negate(compressor, first));\n                    }\n                }\n                break;\n              case \"delete\":\n                if (!compressor.option(\"evaluate\")) break;\n                if (may_not_delete(exp)) break;\n                return make_sequence(self, [ exp, make_node(AST_True, self) ]).optimize(compressor);\n              case \"typeof\":\n                if (!compressor.option(\"booleans\")) break;\n                if (!compressor.in_boolean_context()) break;\n                // typeof always returns a non-empty string, thus always truthy\n                AST_Node.warn(\"Boolean expression always true [{start}]\", self);\n                var exprs = [ make_node(AST_True, self) ];\n                if (!(exp instanceof AST_SymbolRef && can_drop_symbol(exp, compressor))) exprs.unshift(exp);\n                return make_sequence(self, exprs).optimize(compressor);\n              case \"void\":\n                if (!compressor.option(\"side_effects\")) break;\n                exp = exp.drop_side_effect_free(compressor);\n                if (!exp) return make_node(AST_Undefined, self).optimize(compressor);\n                self.expression = exp;\n                return self;\n            }\n            if (compressor.option(\"evaluate\")\n                && exp instanceof AST_Binary\n                && SIGN_OPS[op]\n                && MULTIPLICATIVE_OPS[exp.operator]\n                && (exp.left.is_constant() || !exp.right.has_side_effects(compressor))) {\n                return make_node(AST_Binary, self, {\n                    operator: exp.operator,\n                    left: make_node(AST_UnaryPrefix, exp.left, {\n                        operator: op,\n                        expression: exp.left,\n                    }),\n                    right: exp.right,\n                });\n            }\n            return try_evaluate(compressor, self);\n\n            function may_not_delete(node) {\n                return node instanceof AST_Infinity\n                    || node instanceof AST_NaN\n                    || node instanceof AST_NewTarget\n                    || node instanceof AST_PropAccess\n                    || node instanceof AST_SymbolRef\n                    || node instanceof AST_Undefined;\n            }\n\n            function can_lift() {\n                switch (op) {\n                  case \"delete\":\n                    return !may_not_delete(exp.tail_node());\n                  case \"typeof\":\n                    return !is_undeclared_ref(exp.tail_node());\n                  default:\n                    return true;\n                }\n            }\n        });\n\n        OPT(AST_Await, function(self, compressor) {\n            if (!compressor.option(\"awaits\")) return self;\n            if (compressor.option(\"sequences\")) {\n                var seq = lift_sequence_in_expression(self, compressor);\n                if (seq !== self) return seq.optimize(compressor);\n            }\n            if (compressor.option(\"side_effects\")) {\n                var exp = self.expression;\n                if (exp instanceof AST_Await) return exp.optimize(compressor);\n                if (exp instanceof AST_UnaryPrefix && exp.expression instanceof AST_Await) return exp.optimize(compressor);\n                for (var level = 0, node = self, parent; parent = compressor.parent(level++); node = parent) {\n                    if (is_arrow(parent)) {\n                        if (parent.value === node) return exp.optimize(compressor);\n                    } else if (parent instanceof AST_Return) {\n                        var drop = true;\n                        do {\n                            node = parent;\n                            parent = compressor.parent(level++);\n                            if (parent instanceof AST_Try && (parent.bfinally || parent.bcatch) !== node) {\n                                drop = false;\n                                break;\n                            }\n                        } while (parent && !(parent instanceof AST_Scope));\n                        if (drop) return exp.optimize(compressor);\n                    } else if (parent instanceof AST_Sequence) {\n                        if (parent.tail_node() === node) continue;\n                    }\n                    break;\n                }\n            }\n            return self;\n        });\n\n        OPT(AST_Yield, function(self, compressor) {\n            if (!compressor.option(\"yields\")) return self;\n            if (compressor.option(\"sequences\")) {\n                var seq = lift_sequence_in_expression(self, compressor);\n                if (seq !== self) return seq.optimize(compressor);\n            }\n            var exp = self.expression;\n            if (self.nested && exp.TYPE == \"Call\") {\n                var inlined = exp.clone().optimize(compressor);\n                if (inlined.TYPE != \"Call\") return inlined;\n            }\n            return self;\n        });\n\n        AST_Binary.DEFMETHOD(\"lift_sequences\", function(compressor) {\n            if (this.left instanceof AST_PropAccess) {\n                if (!(this.left.expression instanceof AST_Sequence)) return this;\n                var x = this.left.expression.expressions.slice();\n                var e = this.clone();\n                e.left = e.left.clone();\n                e.left.expression = x.pop();\n                x.push(e);\n                return make_sequence(this, x);\n            }\n            if (this.left instanceof AST_Sequence) {\n                var x = this.left.expressions.slice();\n                var e = this.clone();\n                e.left = x.pop();\n                x.push(e);\n                return make_sequence(this, x);\n            }\n            if (this.right instanceof AST_Sequence) {\n                if (this.left.has_side_effects(compressor)) return this;\n                var assign = this.operator == \"=\" && this.left instanceof AST_SymbolRef;\n                var x = this.right.expressions;\n                var last = x.length - 1;\n                for (var i = 0; i < last; i++) {\n                    if (!assign && x[i].has_side_effects(compressor)) break;\n                }\n                if (i == last) {\n                    x = x.slice();\n                    var e = this.clone();\n                    e.right = x.pop();\n                    x.push(e);\n                    return make_sequence(this, x);\n                }\n                if (i > 0) {\n                    var e = this.clone();\n                    e.right = make_sequence(this.right, x.slice(i));\n                    x = x.slice(0, i);\n                    x.push(e);\n                    return make_sequence(this, x);\n                }\n            }\n            return this;\n        });\n\n        var indexFns = makePredicate(\"indexOf lastIndexOf\");\n        var commutativeOperators = makePredicate(\"== === != !== * & | ^\");\n        function is_object(node, plain) {\n            if (node instanceof AST_Assign) return !plain && node.operator == \"=\" && is_object(node.right);\n            if (node instanceof AST_New) return !plain;\n            if (node instanceof AST_Sequence) return is_object(node.tail_node(), plain);\n            if (node instanceof AST_SymbolRef) return !plain && is_object(node.fixed_value());\n            return node instanceof AST_Array\n                || node instanceof AST_Class\n                || node instanceof AST_Lambda\n                || node instanceof AST_Object;\n        }\n\n        function can_drop_op(op, rhs, compressor) {\n            switch (op) {\n              case \"in\":\n                return is_object(rhs) || compressor && compressor.option(\"unsafe_comps\");\n              case \"instanceof\":\n                if (rhs instanceof AST_SymbolRef) rhs = rhs.fixed_value();\n                return is_lambda(rhs) || compressor && compressor.option(\"unsafe_comps\");\n              default:\n                return true;\n            }\n        }\n\n        function needs_enqueuing(compressor, node) {\n            if (node.is_constant()) return true;\n            if (node instanceof AST_Assign) return node.operator != \"=\" || needs_enqueuing(compressor, node.right);\n            if (node instanceof AST_Binary) {\n                return !lazy_op[node.operator]\n                    || needs_enqueuing(compressor, node.left) && needs_enqueuing(compressor, node.right);\n            }\n            if (node instanceof AST_Call) return is_async(node.expression);\n            if (node instanceof AST_Conditional) {\n                return needs_enqueuing(compressor, node.consequent) && needs_enqueuing(compressor, node.alternative);\n            }\n            if (node instanceof AST_Sequence) return needs_enqueuing(compressor, node.tail_node());\n            if (node instanceof AST_SymbolRef) {\n                var fixed = node.fixed_value();\n                return fixed && needs_enqueuing(compressor, fixed);\n            }\n            if (node instanceof AST_Template) return !node.tag || is_raw_tag(compressor, node.tag);\n            if (node instanceof AST_Unary) return true;\n        }\n\n        function extract_lhs(node, compressor) {\n            if (node instanceof AST_Assign) return is_lhs_read_only(node.left, compressor) ? node : node.left;\n            if (node instanceof AST_Sequence) return extract_lhs(node.tail_node(), compressor);\n            if (node instanceof AST_UnaryPrefix && UNARY_POSTFIX[node.operator]) {\n                return is_lhs_read_only(node.expression, compressor) ? node : node.expression;\n            }\n            return node;\n        }\n\n        function repeatable(compressor, node) {\n            if (node instanceof AST_Dot) return repeatable(compressor, node.expression);\n            if (node instanceof AST_Sub) {\n                return repeatable(compressor, node.expression) && repeatable(compressor, node.property);\n            }\n            if (node instanceof AST_Symbol) return true;\n            return !node.has_side_effects(compressor);\n        }\n\n        function swap_chain(self, compressor) {\n            var rhs = self.right.tail_node();\n            if (rhs !== self.right) {\n                var exprs = self.right.expressions.slice(0, -1);\n                exprs.push(rhs.left);\n                rhs = rhs.clone();\n                rhs.left = make_sequence(self.right, exprs);\n                self.right = rhs;\n            }\n            self.left = make_node(AST_Binary, self, {\n                operator: self.operator,\n                left: self.left,\n                right: rhs.left,\n                start: self.left.start,\n                end: rhs.left.end,\n            });\n            self.right = rhs.right;\n            if (compressor) {\n                self.left = self.left.transform(compressor);\n            } else if (self.operator == rhs.left.operator) {\n                swap_chain(self.left);\n            }\n        }\n\n        OPT(AST_Binary, function(self, compressor) {\n            if (commutativeOperators[self.operator]\n                && self.right.is_constant()\n                && !self.left.is_constant()\n                && !(self.left instanceof AST_Binary\n                    && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {\n                // if right is a constant, whatever side effects the\n                // left side might have could not influence the\n                // result.  hence, force switch.\n                reverse();\n            }\n            if (compressor.option(\"sequences\")) {\n                var seq = self.lift_sequences(compressor);\n                if (seq !== self) return seq.optimize(compressor);\n            }\n            if (compressor.option(\"assignments\") && lazy_op[self.operator]) {\n                var lhs = extract_lhs(self.left, compressor);\n                var right = self.right;\n                // a || (a = x) ---> a = a || x\n                // (a = x) && (a = y) ---> a = (a = x) && y\n                if (lhs instanceof AST_SymbolRef\n                    && right instanceof AST_Assign\n                    && right.operator == \"=\"\n                    && lhs.equals(right.left)) {\n                    lhs = lhs.clone();\n                    var assign = make_node(AST_Assign, self, {\n                        operator: \"=\",\n                        left: lhs,\n                        right: make_node(AST_Binary, self, {\n                            operator: self.operator,\n                            left: self.left,\n                            right: right.right,\n                        }),\n                    });\n                    if (lhs.fixed) {\n                        lhs.fixed = function() {\n                            return assign.right;\n                        };\n                        lhs.fixed.assigns = [ assign ];\n                    }\n                    var def = lhs.definition();\n                    def.references.push(lhs);\n                    def.replaced++;\n                    return assign.optimize(compressor);\n                }\n            }\n            if (compressor.option(\"comparisons\")) switch (self.operator) {\n              case \"===\":\n              case \"!==\":\n                if (is_undefined(self.left, compressor) && self.right.is_defined(compressor)) {\n                    AST_Node.warn(\"Expression always defined [{start}]\", self);\n                    return make_sequence(self, [\n                        self.right,\n                        make_node(self.operator == \"===\" ? AST_False : AST_True, self),\n                    ]).optimize(compressor);\n                }\n                var is_strict_comparison = true;\n                if ((self.left.is_string(compressor) && self.right.is_string(compressor)) ||\n                    (self.left.is_number(compressor) && self.right.is_number(compressor)) ||\n                    (self.left.is_boolean(compressor) && self.right.is_boolean(compressor)) ||\n                    repeatable(compressor, self.left) && self.left.equals(self.right)) {\n                    self.operator = self.operator.slice(0, 2);\n                }\n                // XXX: intentionally falling down to the next case\n              case \"==\":\n              case \"!=\":\n                // void 0 == x ---> null == x\n                if (!is_strict_comparison && is_undefined(self.left, compressor)) {\n                    self.left = make_node(AST_Null, self.left);\n                }\n                // \"undefined\" == typeof x ---> undefined === x\n                else if (compressor.option(\"typeofs\")\n                    && self.left instanceof AST_String\n                    && self.left.value == \"undefined\"\n                    && self.right instanceof AST_UnaryPrefix\n                    && self.right.operator == \"typeof\") {\n                    var expr = self.right.expression;\n                    if (expr instanceof AST_SymbolRef ? expr.is_declared(compressor)\n                        : !(expr instanceof AST_PropAccess && compressor.option(\"ie\"))) {\n                        self.right = expr;\n                        self.left = make_node(AST_Undefined, self.left).optimize(compressor);\n                        if (self.operator.length == 2) self.operator += \"=\";\n                    }\n                }\n                // obj !== obj ---> false\n                else if (self.left instanceof AST_SymbolRef\n                    && self.right instanceof AST_SymbolRef\n                    && self.left.definition() === self.right.definition()\n                    && is_object(self.left)) {\n                    return make_node(self.operator[0] == \"=\" ? AST_True : AST_False, self).optimize(compressor);\n                }\n                break;\n              case \"&&\":\n              case \"||\":\n                // void 0 !== x && null !== x ---> null != x\n                // void 0 === x || null === x ---> null == x\n                var left = self.left;\n                if (!(left instanceof AST_Binary)) break;\n                if (left.operator != (self.operator == \"&&\" ? \"!==\" : \"===\")) break;\n                if (!(self.right instanceof AST_Binary)) break;\n                if (left.operator != self.right.operator) break;\n                if (is_undefined(left.left, compressor) && self.right.left instanceof AST_Null\n                    || left.left instanceof AST_Null && is_undefined(self.right.left, compressor)) {\n                    var expr = left.right;\n                    if (expr instanceof AST_Assign && expr.operator == \"=\") expr = expr.left;\n                    if (expr.has_side_effects(compressor)) break;\n                    if (!expr.equals(self.right.right)) break;\n                    left.operator = left.operator.slice(0, -1);\n                    left.left = make_node(AST_Null, self);\n                    return left;\n                }\n                break;\n            }\n            var in_bool = false;\n            var parent = compressor.parent();\n            if (compressor.option(\"booleans\")) {\n                var lhs = extract_lhs(self.left, compressor);\n                if (lazy_op[self.operator] && !lhs.has_side_effects(compressor)) {\n                    // a || a ---> a\n                    // (a = x) && a --> a = x\n                    if (lhs.equals(self.right)) {\n                        return maintain_this_binding(parent, compressor.self(), self.left).optimize(compressor);\n                    }\n                    mark_duplicate_condition(compressor, lhs);\n                }\n                in_bool = compressor.in_boolean_context();\n            }\n            if (in_bool) switch (self.operator) {\n              case \"+\":\n                var ev = self.left.evaluate(compressor, true);\n                if (ev && typeof ev == \"string\" || (ev = self.right.evaluate(compressor, true)) && typeof ev == \"string\") {\n                    AST_Node.warn(\"+ in boolean context always true [{start}]\", self);\n                    var exprs = [];\n                    if (self.left.evaluate(compressor) instanceof AST_Node) exprs.push(self.left);\n                    if (self.right.evaluate(compressor) instanceof AST_Node) exprs.push(self.right);\n                    if (exprs.length < 2) {\n                        exprs.push(make_node(AST_True, self));\n                        return make_sequence(self, exprs).optimize(compressor);\n                    }\n                    self.truthy = true;\n                }\n                break;\n              case \"==\":\n                if (self.left instanceof AST_String && self.left.value == \"\" && self.right.is_string(compressor)) {\n                    return make_node(AST_UnaryPrefix, self, {\n                        operator: \"!\",\n                        expression: self.right,\n                    }).optimize(compressor);\n                }\n                break;\n              case \"!=\":\n                if (self.left instanceof AST_String && self.left.value == \"\" && self.right.is_string(compressor)) {\n                    return self.right.optimize(compressor);\n                }\n                break;\n            }\n            if (compressor.option(\"comparisons\") && self.is_boolean(compressor)) {\n                if (parent.TYPE != \"Binary\") {\n                    var negated = make_node(AST_UnaryPrefix, self, {\n                        operator: \"!\",\n                        expression: self.negate(compressor),\n                    });\n                    if (best_of(compressor, self, negated) === negated) return negated;\n                }\n                switch (self.operator) {\n                  case \">\": reverse(\"<\"); break;\n                  case \">=\": reverse(\"<=\"); break;\n                }\n            }\n            if (compressor.option(\"conditionals\") && lazy_op[self.operator]) {\n                if (self.left instanceof AST_Binary && self.operator == self.left.operator) {\n                    var before = make_node(AST_Binary, self, {\n                        operator: self.operator,\n                        left: self.left.right,\n                        right: self.right,\n                    });\n                    var after = before.transform(compressor);\n                    if (before !== after) {\n                        self.left = self.left.left;\n                        self.right = after;\n                    }\n                }\n                // x && (y && z) ---> x && y && z\n                // w || (x, y || z) ---> w || (x, y) || z\n                var rhs = self.right.tail_node();\n                if (rhs instanceof AST_Binary && self.operator == rhs.operator) swap_chain(self, compressor);\n            }\n            if (compressor.option(\"strings\") && self.operator == \"+\") {\n                // \"foo\" + 42 + \"\" ---> \"foo\" + 42\n                if (self.right instanceof AST_String\n                    && self.right.value == \"\"\n                    && self.left.is_string(compressor)) {\n                    return self.left.optimize(compressor);\n                }\n                // \"\" + (\"foo\" + 42) ---> \"foo\" + 42\n                if (self.left instanceof AST_String\n                    && self.left.value == \"\"\n                    && self.right.is_string(compressor)) {\n                    return self.right.optimize(compressor);\n                }\n                // \"\" + 42 + \"foo\" ---> 42 + \"foo\"\n                if (self.left instanceof AST_Binary\n                    && self.left.operator == \"+\"\n                    && self.left.left instanceof AST_String\n                    && self.left.left.value == \"\"\n                    && self.right.is_string(compressor)\n                    && (self.left.right.is_constant() || !self.right.has_side_effects(compressor))) {\n                    self.left = self.left.right;\n                    return self.optimize(compressor);\n                }\n                // \"x\" + (y + \"z\") ---> \"x\" + y + \"z\"\n                // w + (x, \"y\" + z) ---> w + (x, \"y\") + z\n                var rhs = self.right.tail_node();\n                if (rhs instanceof AST_Binary\n                    && self.operator == rhs.operator\n                    && (self.left.is_string(compressor) && rhs.is_string(compressor)\n                        || rhs.left.is_string(compressor)\n                            && (self.left.is_constant() || !rhs.right.has_side_effects(compressor)))) {\n                    swap_chain(self, compressor);\n                }\n            }\n            if (compressor.option(\"evaluate\")) {\n                var associative = true;\n                switch (self.operator) {\n                  case \"&&\":\n                    var ll = fuzzy_eval(compressor, self.left);\n                    if (!ll) {\n                        AST_Node.warn(\"Condition left of && always false [{start}]\", self);\n                        return maintain_this_binding(parent, compressor.self(), self.left).optimize(compressor);\n                    } else if (!(ll instanceof AST_Node)) {\n                        AST_Node.warn(\"Condition left of && always true [{start}]\", self);\n                        return make_sequence(self, [ self.left, self.right ]).optimize(compressor);\n                    }\n                    if (!self.right.evaluate(compressor, true)) {\n                        if (in_bool && !(self.right.evaluate(compressor) instanceof AST_Node)) {\n                            AST_Node.warn(\"Boolean && always false [{start}]\", self);\n                            return make_sequence(self, [ self.left, make_node(AST_False, self) ]).optimize(compressor);\n                        } else self.falsy = true;\n                    } else if ((in_bool || parent.operator == \"&&\" && parent.left === compressor.self())\n                        && !(self.right.evaluate(compressor) instanceof AST_Node)) {\n                        AST_Node.warn(\"Dropping side-effect-free && [{start}]\", self);\n                        return self.left.optimize(compressor);\n                    }\n                    // (x || false) && y ---> x ? y : false\n                    if (self.left.operator == \"||\") {\n                        var lr = fuzzy_eval(compressor, self.left.right);\n                        if (!lr) return make_node(AST_Conditional, self, {\n                            condition: self.left.left,\n                            consequent: self.right,\n                            alternative: self.left.right,\n                        }).optimize(compressor);\n                    }\n                    break;\n                  case \"??\":\n                    var nullish = true;\n                  case \"||\":\n                    var ll = fuzzy_eval(compressor, self.left, nullish);\n                    if (nullish ? ll == null : !ll) {\n                        AST_Node.warn(\"Condition left of {operator} always {value} [{start}]\", {\n                            operator: self.operator,\n                            value: nullish ? \"nullish\" : \"false\",\n                            start: self.start,\n                        });\n                        return make_sequence(self, [ self.left, self.right ]).optimize(compressor);\n                    } else if (!(ll instanceof AST_Node)) {\n                        AST_Node.warn(\"Condition left of {operator} always {value} [{start}]\", {\n                            operator: self.operator,\n                            value: nullish ? \"defined\" : \"true\",\n                            start: self.start,\n                        });\n                        return maintain_this_binding(parent, compressor.self(), self.left).optimize(compressor);\n                    }\n                    var rr;\n                    if (!nullish && (rr = self.right.evaluate(compressor, true)) && !(rr instanceof AST_Node)) {\n                        if (in_bool && !(self.right.evaluate(compressor) instanceof AST_Node)) {\n                            AST_Node.warn(\"Boolean || always true [{start}]\", self);\n                            return make_sequence(self, [ self.left, make_node(AST_True, self) ]).optimize(compressor);\n                        } else self.truthy = true;\n                    } else if ((in_bool || parent.operator == \"||\" && parent.left === compressor.self())\n                        && !self.right.evaluate(compressor)) {\n                        AST_Node.warn(\"Dropping side-effect-free {operator} [{start}]\", self);\n                        return self.left.optimize(compressor);\n                    }\n                    // x && true || y ---> x ? true : y\n                    if (!nullish && self.left.operator == \"&&\") {\n                        var lr = fuzzy_eval(compressor, self.left.right);\n                        if (lr && !(lr instanceof AST_Node)) return make_node(AST_Conditional, self, {\n                            condition: self.left.left,\n                            consequent: self.left.right,\n                            alternative: self.right,\n                        }).optimize(compressor);\n                    }\n                    break;\n                  case \"+\":\n                    // \"foo\" + (\"bar\" + x) ---> \"foobar\" + x\n                    if (self.left instanceof AST_Constant\n                        && self.right instanceof AST_Binary\n                        && self.right.operator == \"+\"\n                        && self.right.left instanceof AST_Constant\n                        && self.right.is_string(compressor)) {\n                        self = make_node(AST_Binary, self, {\n                            operator: \"+\",\n                            left: make_node(AST_String, self.left, {\n                                value: \"\" + self.left.value + self.right.left.value,\n                                start: self.left.start,\n                                end: self.right.left.end,\n                            }),\n                            right: self.right.right,\n                        });\n                    }\n                    // (x + \"foo\") + \"bar\" ---> x + \"foobar\"\n                    if (self.right instanceof AST_Constant\n                        && self.left instanceof AST_Binary\n                        && self.left.operator == \"+\"\n                        && self.left.right instanceof AST_Constant\n                        && self.left.is_string(compressor)) {\n                        self = make_node(AST_Binary, self, {\n                            operator: \"+\",\n                            left: self.left.left,\n                            right: make_node(AST_String, self.right, {\n                                value: \"\" + self.left.right.value + self.right.value,\n                                start: self.left.right.start,\n                                end: self.right.end,\n                            }),\n                        });\n                    }\n                    // a + -b ---> a - b\n                    if (self.right instanceof AST_UnaryPrefix\n                        && self.right.operator == \"-\"\n                        && self.left.is_number(compressor)) {\n                        self = make_node(AST_Binary, self, {\n                            operator: \"-\",\n                            left: self.left,\n                            right: self.right.expression,\n                        });\n                        break;\n                    }\n                    // -a + b ---> b - a\n                    if (self.left instanceof AST_UnaryPrefix\n                        && self.left.operator == \"-\"\n                        && reversible()\n                        && self.right.is_number(compressor)) {\n                        self = make_node(AST_Binary, self, {\n                            operator: \"-\",\n                            left: self.right,\n                            right: self.left.expression,\n                        });\n                        break;\n                    }\n                    // (a + b) + 3 ---> 3 + (a + b)\n                    if (compressor.option(\"unsafe_math\")\n                        && self.left instanceof AST_Binary\n                        && PRECEDENCE[self.left.operator] == PRECEDENCE[self.operator]\n                        && self.right.is_constant()\n                        && (self.right.is_boolean(compressor) || self.right.is_number(compressor))\n                        && self.left.is_number(compressor)\n                        && !self.left.right.is_constant()\n                        && (self.left.left.is_boolean(compressor) || self.left.left.is_number(compressor))) {\n                        self = make_node(AST_Binary, self, {\n                            operator: self.left.operator,\n                            left: make_node(AST_Binary, self, {\n                                operator: self.operator,\n                                left: self.right,\n                                right: self.left.left,\n                            }),\n                            right: self.left.right,\n                        });\n                        break;\n                    }\n                  case \"-\":\n                    // a - -b ---> a + b\n                    if (self.right instanceof AST_UnaryPrefix\n                        && self.right.operator == \"-\"\n                        && self.left.is_number(compressor)\n                        && self.right.expression.is_number(compressor)) {\n                        self = make_node(AST_Binary, self, {\n                            operator: \"+\",\n                            left: self.left,\n                            right: self.right.expression,\n                        });\n                        break;\n                    }\n                  case \"*\":\n                  case \"/\":\n                    associative = compressor.option(\"unsafe_math\");\n                    // +a - b ---> a - b\n                    // a - +b ---> a - b\n                    if (self.operator != \"+\") [ \"left\", \"right\" ].forEach(function(operand) {\n                        var node = self[operand];\n                        if (node instanceof AST_UnaryPrefix && node.operator == \"+\") {\n                            var exp = node.expression;\n                            if (exp.is_boolean(compressor) || exp.is_number(compressor) || exp.is_string(compressor)) {\n                                self[operand] = exp;\n                            }\n                        }\n                    });\n                  case \"&\":\n                  case \"|\":\n                  case \"^\":\n                    // a + +b ---> +b + a\n                    if (self.operator != \"-\"\n                        && self.operator != \"/\"\n                        && (self.left.is_boolean(compressor) || self.left.is_number(compressor))\n                        && (self.right.is_boolean(compressor) || self.right.is_number(compressor))\n                        && reversible()\n                        && !(self.left instanceof AST_Binary\n                            && self.left.operator != self.operator\n                            && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {\n                        self = best_of(compressor, self, make_node(AST_Binary, self, {\n                            operator: self.operator,\n                            left: self.right,\n                            right: self.left,\n                        }), self.right instanceof AST_Constant && !(self.left instanceof AST_Constant));\n                    }\n                    if (!associative || !self.is_number(compressor)) break;\n                    // a + (b + c) ---> (a + b) + c\n                    if (self.right instanceof AST_Binary\n                        && self.right.operator != \"%\"\n                        && PRECEDENCE[self.right.operator] == PRECEDENCE[self.operator]\n                        && self.right.is_number(compressor)\n                        && (self.operator != \"+\"\n                            || self.right.left.is_boolean(compressor)\n                            || self.right.left.is_number(compressor))\n                        && (self.operator != \"-\" || !self.left.is_negative_zero())\n                        && (self.right.left.is_constant_expression()\n                            || !self.right.right.has_side_effects(compressor))\n                        && !is_modify_array(self.right.right)) {\n                        self = make_node(AST_Binary, self, {\n                            operator: align(self.operator, self.right.operator),\n                            left: make_node(AST_Binary, self.left, {\n                                operator: self.operator,\n                                left: self.left,\n                                right: self.right.left,\n                                start: self.left.start,\n                                end: self.right.left.end,\n                            }),\n                            right: self.right.right,\n                        });\n                        if (self.operator == \"+\"\n                            && !self.right.is_boolean(compressor)\n                            && !self.right.is_number(compressor)) {\n                            self.right = make_node(AST_UnaryPrefix, self.right, {\n                                operator: \"+\",\n                                expression: self.right,\n                            });\n                        }\n                    }\n                    // (2 * n) * 3 ---> 6 * n\n                    // (n + 2) + 3 ---> n + 5\n                    if (self.right instanceof AST_Constant\n                        && self.left instanceof AST_Binary\n                        && self.left.operator != \"%\"\n                        && PRECEDENCE[self.left.operator] == PRECEDENCE[self.operator]\n                        && self.left.is_number(compressor)) {\n                        if (self.left.left instanceof AST_Constant) {\n                            var lhs = make_binary(self.operator, self.left.left, self.right, {\n                                start: self.left.left.start,\n                                end: self.right.end,\n                            });\n                            self = make_binary(self.left.operator, try_evaluate(compressor, lhs), self.left.right, self);\n                        } else if (self.left.right instanceof AST_Constant) {\n                            var op = align(self.left.operator, self.operator);\n                            var rhs = try_evaluate(compressor, make_binary(op, self.left.right, self.right, self.left));\n                            if (rhs.is_constant()\n                                && !(self.left.operator == \"-\"\n                                    && self.right.value != 0\n                                    && +rhs.value == 0\n                                    && self.left.left.is_negative_zero())) {\n                                self = make_binary(self.left.operator, self.left.left, rhs, self);\n                            }\n                        }\n                    }\n                    break;\n                  case \"instanceof\":\n                    if (is_lambda(self.right)) return make_sequence(self, [\n                        self,\n                        make_node(AST_False, self),\n                    ]).optimize(compressor);\n                    break;\n                }\n                if (!(parent instanceof AST_UnaryPrefix && parent.operator == \"delete\")) {\n                    if (self.left instanceof AST_Number && !self.right.is_constant()) switch (self.operator) {\n                      // 0 + n ---> n\n                      case \"+\":\n                        if (self.left.value == 0) {\n                            if (self.right.is_boolean(compressor)) return make_node(AST_UnaryPrefix, self, {\n                                operator: \"+\",\n                                expression: self.right,\n                            }).optimize(compressor);\n                            if (self.right.is_number(compressor) && !self.right.is_negative_zero()) return self.right;\n                        }\n                        break;\n                      // 1 * n ---> n\n                      case \"*\":\n                        if (self.left.value == 1) return make_node(AST_UnaryPrefix, self, {\n                            operator: \"+\",\n                            expression: self.right,\n                        }).optimize(compressor);\n                        break;\n                    }\n                    if (self.right instanceof AST_Number && !self.left.is_constant()) switch (self.operator) {\n                      // n + 0 ---> n\n                      case \"+\":\n                        if (self.right.value == 0) {\n                            if (self.left.is_boolean(compressor)) return make_node(AST_UnaryPrefix, self, {\n                                operator: \"+\",\n                                expression: self.left,\n                            }).optimize(compressor);\n                            if (self.left.is_number(compressor) && !self.left.is_negative_zero()) return self.left;\n                        }\n                        break;\n                      // n - 0 ---> n\n                      case \"-\":\n                        if (self.right.value == 0) return make_node(AST_UnaryPrefix, self, {\n                            operator: \"+\",\n                            expression: self.left,\n                        }).optimize(compressor);\n                        break;\n                      // n / 1 ---> n\n                      case \"/\":\n                        if (self.right.value == 1) return make_node(AST_UnaryPrefix, self, {\n                            operator: \"+\",\n                            expression: self.left,\n                        }).optimize(compressor);\n                        break;\n                    }\n                }\n            }\n            if (compressor.option(\"typeofs\")) switch (self.operator) {\n              case \"&&\":\n                mark_locally_defined(self.left, self.right, null);\n                break;\n              case \"||\":\n                mark_locally_defined(self.left, null, self.right);\n                break;\n            }\n            if (compressor.option(\"unsafe\")) {\n                var indexRight = is_indexFn(self.right);\n                if (in_bool\n                    && indexRight\n                    && (self.operator == \"==\" || self.operator == \"!=\")\n                    && self.left instanceof AST_Number\n                    && self.left.value == 0) {\n                    return (self.operator == \"==\" ? make_node(AST_UnaryPrefix, self, {\n                        operator: \"!\",\n                        expression: self.right,\n                    }) : self.right).optimize(compressor);\n                }\n                var indexLeft = is_indexFn(self.left);\n                if (compressor.option(\"comparisons\") && is_indexOf_match_pattern()) {\n                    var node = make_node(AST_UnaryPrefix, self, {\n                        operator: \"!\",\n                        expression: make_node(AST_UnaryPrefix, self, {\n                            operator: \"~\",\n                            expression: indexLeft ? self.left : self.right,\n                        }),\n                    });\n                    switch (self.operator) {\n                      case \"<\":\n                        if (indexLeft) break;\n                      case \"<=\":\n                      case \"!=\":\n                        node = make_node(AST_UnaryPrefix, self, {\n                            operator: \"!\",\n                            expression: node,\n                        });\n                        break;\n                    }\n                    return node.optimize(compressor);\n                }\n            }\n            return try_evaluate(compressor, self);\n\n            function is_modify_array(node) {\n                var found = false;\n                node.walk(new TreeWalker(function(node) {\n                    if (found) return true;\n                    if (node instanceof AST_Assign) {\n                        if (node.left instanceof AST_PropAccess) return found = true;\n                    } else if (node instanceof AST_Unary) {\n                        if (unary_side_effects[node.operator] && node.expression instanceof AST_PropAccess) {\n                            return found = true;\n                        }\n                    }\n                }));\n                return found;\n            }\n\n            function align(ref, op) {\n                switch (ref) {\n                  case \"-\":\n                    return op == \"+\" ? \"-\" : \"+\";\n                  case \"/\":\n                    return op == \"*\" ? \"/\" : \"*\";\n                  default:\n                    return op;\n                }\n            }\n\n            function make_binary(op, left, right, orig) {\n                if (op == \"+\") {\n                    if (!left.is_boolean(compressor) && !left.is_number(compressor)) {\n                        left = make_node(AST_UnaryPrefix, left, {\n                            operator: \"+\",\n                            expression: left,\n                        });\n                    }\n                    if (!right.is_boolean(compressor) && !right.is_number(compressor)) {\n                        right = make_node(AST_UnaryPrefix, right, {\n                            operator: \"+\",\n                            expression: right,\n                        });\n                    }\n                }\n                return make_node(AST_Binary, orig, {\n                    operator: op,\n                    left: left,\n                    right: right,\n                });\n            }\n\n            function is_indexFn(node) {\n                return node.TYPE == \"Call\"\n                    && node.expression instanceof AST_Dot\n                    && indexFns[node.expression.property];\n            }\n\n            function is_indexOf_match_pattern() {\n                switch (self.operator) {\n                  case \"<=\":\n                    // 0 <= array.indexOf(string) ---> !!~array.indexOf(string)\n                    return indexRight && self.left instanceof AST_Number && self.left.value == 0;\n                  case \"<\":\n                    // array.indexOf(string) < 0 ---> !~array.indexOf(string)\n                    if (indexLeft && self.right instanceof AST_Number && self.right.value == 0) return true;\n                    // -1 < array.indexOf(string) ---> !!~array.indexOf(string)\n                  case \"==\":\n                  case \"!=\":\n                    // -1 == array.indexOf(string) ---> !~array.indexOf(string)\n                    // -1 != array.indexOf(string) ---> !!~array.indexOf(string)\n                    if (!indexRight) return false;\n                    return self.left instanceof AST_Number && self.left.value == -1\n                        || self.left instanceof AST_UnaryPrefix && self.left.operator == \"-\"\n                            && self.left.expression instanceof AST_Number && self.left.expression.value == 1;\n                }\n            }\n\n            function reversible() {\n                return self.left.is_constant()\n                    || self.right.is_constant()\n                    || !self.left.has_side_effects(compressor)\n                        && !self.right.has_side_effects(compressor);\n            }\n\n            function reverse(op) {\n                if (reversible()) {\n                    if (op) self.operator = op;\n                    var tmp = self.left;\n                    self.left = self.right;\n                    self.right = tmp;\n                }\n            }\n        });\n\n        OPT(AST_SymbolExport, function(self) {\n            return self;\n        });\n\n        function recursive_ref(compressor, def, fn) {\n            var level = 0, node = compressor.self();\n            do {\n                if (node === fn) return node;\n                if (is_lambda(node) && node.name && node.name.definition() === def) return node;\n            } while (node = compressor.parent(level++));\n        }\n\n        function same_scope(def) {\n            var scope = def.scope.resolve();\n            return all(def.references, function(ref) {\n                return scope === ref.scope.resolve();\n            });\n        }\n\n        OPT(AST_SymbolRef, function(self, compressor) {\n            if (!compressor.option(\"ie\")\n                && is_undeclared_ref(self)\n                // testing against `self.scope.uses_with` is an optimization\n                && !(self.scope.resolve().uses_with && compressor.find_parent(AST_With))) {\n                switch (self.name) {\n                  case \"undefined\":\n                    return make_node(AST_Undefined, self).optimize(compressor);\n                  case \"NaN\":\n                    return make_node(AST_NaN, self).optimize(compressor);\n                  case \"Infinity\":\n                    return make_node(AST_Infinity, self).optimize(compressor);\n                }\n            }\n            var parent = compressor.parent();\n            if (compressor.option(\"reduce_vars\") && is_lhs(compressor.self(), parent) !== compressor.self()) {\n                var def = self.definition();\n                var fixed = self.fixed_value();\n                var single_use = def.single_use && !(parent instanceof AST_Call && parent.is_expr_pure(compressor));\n                if (single_use) {\n                    if (is_lambda(fixed)) {\n                        if ((def.scope !== self.scope.resolve(true) || def.in_loop)\n                            && (!compressor.option(\"reduce_funcs\") || def.escaped.depth == 1 || fixed.inlined)) {\n                            single_use = false;\n                        } else if (def.redefined()) {\n                            single_use = false;\n                        } else if (recursive_ref(compressor, def, fixed)) {\n                            single_use = false;\n                        } else if (fixed.name && fixed.name.definition() !== def) {\n                            single_use = false;\n                        } else if (fixed.parent_scope !== self.scope || is_funarg(def)) {\n                            if (!safe_from_strict_mode(fixed, compressor)) {\n                                single_use = false;\n                            } else if ((single_use = fixed.is_constant_expression(self.scope)) == \"f\") {\n                                var scope = self.scope;\n                                do {\n                                    if (scope instanceof AST_LambdaDefinition || scope instanceof AST_LambdaExpression) {\n                                        scope.inlined = true;\n                                    }\n                                } while (scope = scope.parent_scope);\n                            }\n                        } else if (fixed.name && (fixed.name.name == \"await\" && is_async(fixed)\n                            || fixed.name.name == \"yield\" && is_generator(fixed))) {\n                            single_use = false;\n                        } else if (fixed.has_side_effects(compressor)) {\n                            single_use = false;\n                        } else if (compressor.option(\"ie\") && fixed instanceof AST_Class) {\n                            single_use = false;\n                        }\n                        if (single_use) fixed.parent_scope = self.scope;\n                    } else if (!fixed\n                        || def.recursive_refs > 0\n                        || !fixed.is_constant_expression()\n                        || fixed.drop_side_effect_free(compressor)) {\n                        single_use = false;\n                    }\n                }\n                if (single_use) {\n                    def.single_use = false;\n                    fixed._squeezed = true;\n                    fixed.single_use = true;\n                    if (fixed instanceof AST_DefClass) fixed = to_class_expr(fixed);\n                    if (fixed instanceof AST_LambdaDefinition) fixed = to_func_expr(fixed);\n                    if (is_lambda(fixed)) {\n                        var scopes = [];\n                        var scope = self.scope;\n                        do {\n                            scopes.push(scope);\n                            if (scope === def.scope) break;\n                        } while (scope = scope.parent_scope);\n                        fixed.enclosed.forEach(function(def) {\n                            if (fixed.variables.has(def.name)) return;\n                            for (var i = 0; i < scopes.length; i++) {\n                                var scope = scopes[i];\n                                if (!push_uniq(scope.enclosed, def)) return;\n                                scope.var_names().set(def.name, true);\n                            }\n                        });\n                    }\n                    var value;\n                    if (def.recursive_refs > 0) {\n                        value = fixed.clone(true);\n                        var defun_def = value.name.definition();\n                        var lambda_def = value.variables.get(value.name.name);\n                        var name = lambda_def && lambda_def.orig[0];\n                        var def_fn_name, symbol_type;\n                        if (value instanceof AST_Class) {\n                            def_fn_name = \"def_function\";\n                            symbol_type = AST_SymbolClass;\n                        } else {\n                            def_fn_name = \"def_variable\";\n                            symbol_type = AST_SymbolLambda;\n                        }\n                        if (!(name instanceof symbol_type)) {\n                            name = make_node(symbol_type, value.name);\n                            name.scope = value;\n                            value.name = name;\n                            lambda_def = value[def_fn_name](name);\n                            lambda_def.recursive_refs = def.recursive_refs;\n                        }\n                        value.walk(new TreeWalker(function(node) {\n                            if (node instanceof AST_SymbolDeclaration) {\n                                if (node !== name) {\n                                    var def = node.definition();\n                                    def.orig.push(node);\n                                    def.eliminated++;\n                                }\n                                return;\n                            }\n                            if (!(node instanceof AST_SymbolRef)) return;\n                            var def = node.definition();\n                            if (def === defun_def) {\n                                node.thedef = def = lambda_def;\n                            } else {\n                                def.single_use = false;\n                                var fn = node.fixed_value();\n                                if (is_lambda(fn)\n                                    && fn.name\n                                    && fn.name.definition() === def\n                                    && def.scope === fn.name.scope\n                                    && fixed.variables.get(fn.name.name) === def) {\n                                    fn.name = fn.name.clone();\n                                    node.thedef = def = value.variables.get(fn.name.name) || value[def_fn_name](fn.name);\n                                }\n                            }\n                            def.references.push(node);\n                        }));\n                    } else {\n                        if (fixed instanceof AST_Scope) {\n                            compressor.push(fixed);\n                            value = fixed.optimize(compressor);\n                            compressor.pop();\n                        } else {\n                            value = fixed.optimize(compressor);\n                        }\n                        value = value.transform(new TreeTransformer(function(node, descend) {\n                            if (node instanceof AST_Scope) return node;\n                            node = node.clone();\n                            descend(node, this);\n                            return node;\n                        }));\n                    }\n                    def.replaced++;\n                    return value;\n                }\n                var state;\n                if (fixed && (state = self.fixed || def.fixed).should_replace !== false) {\n                    var ev, init;\n                    if (fixed instanceof AST_This) {\n                        if (!is_funarg(def) && same_scope(def) && !cross_class(def)) init = fixed;\n                    } else if ((ev = fixed.evaluate(compressor, true)) !== fixed\n                        && typeof ev != \"function\"\n                        && (ev === null\n                            || typeof ev != \"object\"\n                            || compressor.option(\"unsafe_regexp\")\n                                && ev instanceof RegExp && !def.cross_loop && same_scope(def))) {\n                        init = make_node_from_constant(ev, fixed);\n                    }\n                    if (init) {\n                        if (state.should_replace === undefined) {\n                            var value_length = init.optimize(compressor).print_to_string().length;\n                            if (!has_symbol_ref(fixed)) {\n                                value_length = Math.min(value_length, fixed.print_to_string().length);\n                            }\n                            var name_length = def.name.length;\n                            if (compressor.option(\"unused\") && !compressor.exposed(def)) {\n                                var refs = def.references.length - def.replaced - def.assignments;\n                                refs = Math.min(refs, def.references.filter(function(ref) {\n                                    return ref.fixed === state;\n                                }).length);\n                                name_length += (name_length + 2 + value_length) / Math.max(1, refs);\n                            }\n                            state.should_replace = value_length - Math.floor(name_length) < compressor.eval_threshold;\n                        }\n                        if (state.should_replace) {\n                            var value;\n                            if (has_symbol_ref(fixed)) {\n                                value = init.optimize(compressor);\n                                if (value === init) value = value.clone(true);\n                            } else {\n                                value = best_of_expression(init.optimize(compressor), fixed);\n                                if (value === init || value === fixed) value = value.clone(true);\n                            }\n                            def.replaced++;\n                            return value;\n                        }\n                    }\n                }\n            }\n            return self;\n\n            function cross_class(def) {\n                var scope = self.scope;\n                while (scope !== def.scope) {\n                    if (scope instanceof AST_Class) return true;\n                    scope = scope.parent_scope;\n                }\n            }\n\n            function has_symbol_ref(value) {\n                var found;\n                value.walk(new TreeWalker(function(node) {\n                    if (node instanceof AST_SymbolRef) found = true;\n                    if (found) return true;\n                }));\n                return found;\n            }\n        });\n\n        function is_raw_tag(compressor, tag) {\n            return compressor.option(\"unsafe\")\n                && tag instanceof AST_Dot\n                && tag.property == \"raw\"\n                && is_undeclared_ref(tag.expression)\n                && tag.expression.name == \"String\";\n        }\n\n        function decode_template(str) {\n            var malformed = false;\n            str = str.replace(/\\\\(u\\{[^{}]*\\}?|u[\\s\\S]{0,4}|x[\\s\\S]{0,2}|[0-9]+|[\\s\\S])/g, function(match, seq) {\n                var ch = decode_escape_sequence(seq);\n                if (typeof ch == \"string\") return ch;\n                malformed = true;\n            });\n            if (!malformed) return str;\n        }\n\n        OPT(AST_Template, function(self, compressor) {\n            if (!compressor.option(\"templates\")) return self;\n            var tag = self.tag;\n            if (!tag || is_raw_tag(compressor, tag)) {\n                var exprs = [];\n                var strs = [];\n                for (var i = 0, status; i < self.strings.length; i++) {\n                    var str = self.strings[i];\n                    if (!tag) {\n                        var trimmed = decode_template(str);\n                        if (trimmed) str = escape_literal(trimmed);\n                    }\n                    if (i > 0) {\n                        var node = self.expressions[i - 1];\n                        var value = should_join(node);\n                        if (value) {\n                            var prev = strs[strs.length - 1];\n                            var joined = prev + value + str;\n                            var decoded;\n                            if (tag || typeof (decoded = decode_template(joined)) == status) {\n                                strs[strs.length - 1] = decoded ? escape_literal(decoded) : joined;\n                                continue;\n                            }\n                        }\n                        exprs.push(node);\n                    }\n                    strs.push(str);\n                    if (!tag) status = typeof trimmed;\n                }\n                if (!tag && strs.length > 1) {\n                    if (strs[strs.length - 1] == \"\") return make_node(AST_Binary, self, {\n                        operator: \"+\",\n                        left: make_node(AST_Template, self, {\n                            expressions: exprs.slice(0, -1),\n                            strings: strs.slice(0, -1),\n                        }).transform(compressor),\n                        right: exprs[exprs.length - 1],\n                    }).optimize(compressor);\n                    if (strs[0] == \"\") {\n                        var left = make_node(AST_Binary, self, {\n                            operator: \"+\",\n                            left: make_node(AST_String, self, { value: \"\" }),\n                            right: exprs[0],\n                        });\n                        for (var i = 1; strs[i] == \"\" && i < exprs.length; i++) {\n                            left = make_node(AST_Binary, self, {\n                                operator: \"+\",\n                                left: left,\n                                right: exprs[i],\n                            });\n                        }\n                        return best_of(compressor, self, make_node(AST_Binary, self, {\n                            operator: \"+\",\n                            left: left.transform(compressor),\n                            right: make_node(AST_Template, self, {\n                                expressions: exprs.slice(i),\n                                strings: strs.slice(i),\n                            }).transform(compressor),\n                        }).optimize(compressor));\n                    }\n                }\n                self.expressions = exprs;\n                self.strings = strs;\n            }\n            return try_evaluate(compressor, self);\n\n            function escape_literal(str) {\n                return str.replace(/\\r|\\\\|`|\\${/g, function(s) {\n                    return \"\\\\\" + (s == \"\\r\" ? \"r\" : s);\n                });\n            }\n\n            function should_join(node) {\n                var ev = node.evaluate(compressor);\n                if (ev === node) return;\n                if (tag && /\\r|\\\\|`/.test(ev)) return;\n                ev = escape_literal(\"\" + ev);\n                if (ev.length > node.print_to_string().length + \"${}\".length) return;\n                return ev;\n            }\n        });\n\n        function is_atomic(lhs, self) {\n            return lhs instanceof AST_SymbolRef || lhs.TYPE === self.TYPE;\n        }\n\n        OPT(AST_Undefined, function(self, compressor) {\n            if (compressor.option(\"unsafe_undefined\")) {\n                var undef = find_scope(compressor).find_variable(\"undefined\");\n                if (undef) {\n                    var ref = make_node(AST_SymbolRef, self, {\n                        name: \"undefined\",\n                        scope: undef.scope,\n                        thedef: undef,\n                    });\n                    ref.is_undefined = true;\n                    return ref;\n                }\n            }\n            var lhs = is_lhs(compressor.self(), compressor.parent());\n            if (lhs && is_atomic(lhs, self)) return self;\n            return make_node(AST_UnaryPrefix, self, {\n                operator: \"void\",\n                expression: make_node(AST_Number, self, { value: 0 }),\n            });\n        });\n\n        OPT(AST_Infinity, function(self, compressor) {\n            var lhs = is_lhs(compressor.self(), compressor.parent());\n            if (lhs && is_atomic(lhs, self)) return self;\n            if (compressor.option(\"keep_infinity\") && !lhs && !find_scope(compressor).find_variable(\"Infinity\")) {\n                return self;\n            }\n            return make_node(AST_Binary, self, {\n                operator: \"/\",\n                left: make_node(AST_Number, self, { value: 1 }),\n                right: make_node(AST_Number, self, { value: 0 }),\n            });\n        });\n\n        OPT(AST_NaN, function(self, compressor) {\n            var lhs = is_lhs(compressor.self(), compressor.parent());\n            if (lhs && is_atomic(lhs, self)) return self;\n            if (!lhs && !find_scope(compressor).find_variable(\"NaN\")) return self;\n            return make_node(AST_Binary, self, {\n                operator: \"/\",\n                left: make_node(AST_Number, self, { value: 0 }),\n                right: make_node(AST_Number, self, { value: 0 }),\n            });\n        });\n\n        function is_reachable(self, defs) {\n            var reachable = false;\n            var find_ref = new TreeWalker(function(node) {\n                if (reachable) return true;\n                if (node instanceof AST_SymbolRef && member(node.definition(), defs)) return reachable = true;\n            });\n            var scan_scope = new TreeWalker(function(node) {\n                if (reachable) return true;\n                if (node instanceof AST_Lambda && node !== self) {\n                    if (!(node.name || is_async(node) || is_generator(node))) {\n                        var parent = scan_scope.parent();\n                        if (parent instanceof AST_Call && parent.expression === node) return;\n                    }\n                    node.walk(find_ref);\n                    return true;\n                }\n            });\n            self.walk(scan_scope);\n            return reachable;\n        }\n\n        var ASSIGN_OPS = makePredicate(\"+ - * / % >> << >>> | ^ &\");\n        var ASSIGN_OPS_COMMUTATIVE = makePredicate(\"* | ^ &\");\n        OPT(AST_Assign, function(self, compressor) {\n            if (compressor.option(\"dead_code\")) {\n                if (self.left instanceof AST_PropAccess) {\n                    if (self.operator == \"=\") {\n                        if (self.redundant) {\n                            var exprs = [ self.left.expression ];\n                            if (self.left instanceof AST_Sub) exprs.push(self.left.property);\n                            exprs.push(self.right);\n                            return make_sequence(self, exprs).optimize(compressor);\n                        }\n                        if (self.left.equals(self.right) && !self.left.has_side_effects(compressor)) {\n                            return self.right;\n                        }\n                        var exp = self.left.expression;\n                        if (exp instanceof AST_Lambda\n                            || !compressor.has_directive(\"use strict\")\n                                && exp instanceof AST_Constant\n                                && !exp.may_throw_on_access(compressor)) {\n                            return self.left instanceof AST_Dot ? self.right : make_sequence(self, [\n                                self.left.property,\n                                self.right\n                            ]).optimize(compressor);\n                        }\n                    }\n                } else if (self.left instanceof AST_SymbolRef && can_drop_symbol(self.left, compressor)) {\n                    var parent;\n                    if (self.operator == \"=\" && self.left.equals(self.right)\n                        && !((parent = compressor.parent()) instanceof AST_UnaryPrefix && parent.operator == \"delete\")) {\n                        return self.right;\n                    }\n                    if (self.left.is_immutable()) return strip_assignment();\n                    var def = self.left.definition();\n                    var scope = def.scope.resolve();\n                    var local = scope === compressor.find_parent(AST_Lambda);\n                    var level = 0, node;\n                    parent = compressor.self();\n                    if (!(scope.uses_arguments && is_funarg(def)) || compressor.has_directive(\"use strict\")) do {\n                        node = parent;\n                        parent = compressor.parent(level++);\n                        if (parent instanceof AST_Assign) {\n                            if (parent.left instanceof AST_SymbolRef && parent.left.definition() === def) {\n                                if (in_try(level, parent, !local)) break;\n                                return strip_assignment(def);\n                            }\n                            if (parent.left.match_symbol(function(node) {\n                                if (node instanceof AST_PropAccess) return true;\n                            })) break;\n                            continue;\n                        }\n                        if (parent instanceof AST_Exit) {\n                            if (!local) break;\n                            if (in_try(level, parent)) break;\n                            if (is_reachable(scope, [ def ])) break;\n                            return strip_assignment(def);\n                        }\n                        if (parent instanceof AST_SimpleStatement) {\n                            if (!local) break;\n                            if (is_reachable(scope, [ def ])) break;\n                            var stat;\n                            do {\n                                stat = parent;\n                                parent = compressor.parent(level++);\n                                if (parent === scope && is_last_statement(parent.body, stat)) return strip_assignment(def);\n                            } while (is_tail_block(stat, parent));\n                            break;\n                        }\n                        if (parent instanceof AST_VarDef) {\n                            if (!(parent.name instanceof AST_SymbolDeclaration)) continue;\n                            if (parent.name.definition() !== def) continue;\n                            if (in_try(level, parent)) break;\n                            return strip_assignment(def);\n                        }\n                    } while (is_tail(node, parent));\n                }\n            }\n            if (compressor.option(\"sequences\")) {\n                var seq = self.lift_sequences(compressor);\n                if (seq !== self) return seq.optimize(compressor);\n            }\n            if (compressor.option(\"assignments\")) {\n                if (self.operator == \"=\" && self.left instanceof AST_SymbolRef && self.right instanceof AST_Binary) {\n                    // x = expr1 OP expr2\n                    if (self.right.left instanceof AST_SymbolRef\n                        && self.right.left.name == self.left.name\n                        && ASSIGN_OPS[self.right.operator]) {\n                        // x = x - 2 ---> x -= 2\n                        return make_compound(self.right.right);\n                    }\n                    if (self.right.right instanceof AST_SymbolRef\n                        && self.right.right.name == self.left.name\n                        && ASSIGN_OPS_COMMUTATIVE[self.right.operator]\n                        && !self.right.left.has_side_effects(compressor)) {\n                        // x = 2 & x ---> x &= 2\n                        return make_compound(self.right.left);\n                    }\n                }\n                if ((self.operator == \"-=\" || self.operator == \"+=\"\n                        && (self.left.is_boolean(compressor) || self.left.is_number(compressor)))\n                    && self.right instanceof AST_Number\n                    && self.right.value == 1) {\n                    var op = self.operator.slice(0, -1);\n                    return make_node(AST_UnaryPrefix, self, {\n                        operator: op + op,\n                        expression: self.left,\n                    });\n                }\n            }\n            return try_evaluate(compressor, self);\n\n            function is_tail(node, parent) {\n                if (parent instanceof AST_Binary) switch (node) {\n                  case parent.left:\n                    return parent.right.is_constant_expression(scope);\n                  case parent.right:\n                    return true;\n                  default:\n                    return false;\n                }\n                if (parent instanceof AST_Conditional) switch (node) {\n                  case parent.condition:\n                    return parent.consequent.is_constant_expression(scope)\n                        && parent.alternative.is_constant_expression(scope);\n                  case parent.consequent:\n                  case parent.alternative:\n                    return true;\n                  default:\n                    return false;\n                }\n                if (parent instanceof AST_Sequence) {\n                    var exprs = parent.expressions;\n                    var stop = exprs.indexOf(node);\n                    if (stop < 0) return false;\n                    for (var i = exprs.length; --i > stop;) {\n                        if (!exprs[i].is_constant_expression(scope)) return false;\n                    }\n                    return true;\n                }\n                return parent instanceof AST_UnaryPrefix;\n            }\n\n            function is_tail_block(stat, parent) {\n                if (parent instanceof AST_BlockStatement) return is_last_statement(parent.body, stat);\n                if (parent instanceof AST_Catch) return is_last_statement(parent.body, stat);\n                if (parent instanceof AST_Finally) return is_last_statement(parent.body, stat);\n                if (parent instanceof AST_If) return parent.body === stat || parent.alternative === stat;\n                if (parent instanceof AST_Try) return parent.bfinally ? parent.bfinally === stat : parent.bcatch === stat;\n            }\n\n            function in_try(level, node, sync) {\n                var right = self.right;\n                self.right = make_node(AST_Null, right);\n                var may_throw = node.may_throw(compressor);\n                self.right = right;\n                return find_try(compressor, level, node, scope, may_throw, sync);\n            }\n\n            function make_compound(rhs) {\n                var fixed = self.left.fixed;\n                if (fixed) fixed.to_binary = replace_ref(function(node) {\n                    return node.left;\n                }, fixed);\n                return make_node(AST_Assign, self, {\n                    operator: self.right.operator + \"=\",\n                    left: self.left,\n                    right: rhs,\n                });\n            }\n\n            function strip_assignment(def) {\n                if (def) def.fixed = false;\n                return (self.operator != \"=\" ? make_node(AST_Binary, self, {\n                    operator: self.operator.slice(0, -1),\n                    left: self.left,\n                    right: self.right,\n                }) : maintain_this_binding(compressor.parent(), self, self.right)).optimize(compressor);\n            }\n        });\n\n        OPT(AST_Conditional, function(self, compressor) {\n            if (compressor.option(\"sequences\") && self.condition instanceof AST_Sequence) {\n                var expressions = self.condition.expressions.slice();\n                var node = self.clone();\n                node.condition = expressions.pop();\n                expressions.push(node);\n                return make_sequence(self, expressions).optimize(compressor);\n            }\n            if (!compressor.option(\"conditionals\")) return self;\n            var condition = self.condition;\n            if (compressor.option(\"booleans\") && !condition.has_side_effects(compressor)) {\n                mark_duplicate_condition(compressor, condition);\n            }\n            condition = fuzzy_eval(compressor, condition);\n            if (!condition) {\n                AST_Node.warn(\"Condition always false [{start}]\", self);\n                return make_sequence(self, [ self.condition, self.alternative ]).optimize(compressor);\n            } else if (!(condition instanceof AST_Node)) {\n                AST_Node.warn(\"Condition always true [{start}]\", self);\n                return make_sequence(self, [ self.condition, self.consequent ]).optimize(compressor);\n            }\n            var first = first_in_statement(compressor);\n            var negated = condition.negate(compressor, first);\n            if ((first ? best_of_statement : best_of_expression)(condition, negated) === negated) {\n                self = make_node(AST_Conditional, self, {\n                    condition: negated,\n                    consequent: self.alternative,\n                    alternative: self.consequent,\n                });\n                negated = condition;\n                condition = self.condition;\n            }\n            var consequent = self.consequent;\n            var alternative = self.alternative;\n            var cond_lhs = extract_lhs(condition, compressor);\n            if (repeatable(compressor, cond_lhs)) {\n                // x ? x : y ---> x || y\n                if (cond_lhs.equals(consequent)) return make_node(AST_Binary, self, {\n                    operator: \"||\",\n                    left: condition,\n                    right: alternative,\n                }).optimize(compressor);\n                // x ? y : x ---> x && y\n                if (cond_lhs.equals(alternative)) return make_node(AST_Binary, self, {\n                    operator: \"&&\",\n                    left: condition,\n                    right: consequent,\n                }).optimize(compressor);\n            }\n            // if (foo) exp = something; else exp = something_else;\n            //                   |\n            //                   v\n            // exp = foo ? something : something_else;\n            var seq_tail = consequent.tail_node();\n            if (seq_tail instanceof AST_Assign) {\n                var is_eq = seq_tail.operator == \"=\";\n                var alt_tail = is_eq ? alternative.tail_node() : alternative;\n                if ((is_eq || consequent === seq_tail)\n                    && alt_tail instanceof AST_Assign\n                    && seq_tail.operator == alt_tail.operator\n                    && seq_tail.left.equals(alt_tail.left)\n                    && (is_eq && seq_tail.left instanceof AST_SymbolRef\n                        || !condition.has_side_effects(compressor)\n                            && can_shift_lhs_of_tail(consequent)\n                            && can_shift_lhs_of_tail(alternative))) {\n                    return make_node(AST_Assign, self, {\n                        operator: seq_tail.operator,\n                        left: seq_tail.left,\n                        right: make_node(AST_Conditional, self, {\n                            condition: condition,\n                            consequent: pop_lhs(consequent),\n                            alternative: pop_lhs(alternative),\n                        }),\n                    });\n                }\n            }\n            var alt_tail = alternative.tail_node();\n            // x ? y : y ---> x, y\n            // x ? (a, c) : (b, c) ---> x ? a : b, c\n            if (seq_tail.equals(alt_tail)) return make_sequence(self, consequent.equals(alternative) ? [\n                condition,\n                consequent,\n            ] : [\n                make_node(AST_Conditional, self, {\n                    condition: condition,\n                    consequent: pop_seq(consequent),\n                    alternative: pop_seq(alternative),\n                }),\n                alt_tail,\n            ]).optimize(compressor);\n            // x ? y.p : z.p ---> (x ? y : z).p\n            // x ? y(a) : z(a) ---> (x ? y : z)(a)\n            // x ? y.f(a) : z.f(a) ---> (x ? y : z).f(a)\n            var combined = combine_tail(consequent, alternative, true);\n            if (combined) return combined;\n            // x ? y(a) : y(b) ---> y(x ? a : b)\n            var arg_index;\n            if (consequent instanceof AST_Call\n                && alternative.TYPE == consequent.TYPE\n                && (arg_index = arg_diff(consequent, alternative)) >= 0\n                && consequent.expression.equals(alternative.expression)\n                && !condition.has_side_effects(compressor)\n                && !consequent.expression.has_side_effects(compressor)) {\n                var node = consequent.clone();\n                var arg = consequent.args[arg_index];\n                node.args[arg_index] = arg instanceof AST_Spread ? make_node(AST_Spread, self, {\n                    expression: make_node(AST_Conditional, self, {\n                        condition: condition,\n                        consequent: arg.expression,\n                        alternative: alternative.args[arg_index].expression,\n                    }),\n                }) : make_node(AST_Conditional, self, {\n                    condition: condition,\n                    consequent: arg,\n                    alternative: alternative.args[arg_index],\n                });\n                return node;\n            }\n            // x ? (y ? a : b) : b ---> x && y ? a : b\n            if (seq_tail instanceof AST_Conditional\n                && seq_tail.alternative.equals(alternative)) {\n                return make_node(AST_Conditional, self, {\n                    condition: make_node(AST_Binary, self, {\n                        left: condition,\n                        operator: \"&&\",\n                        right: fuse(consequent, seq_tail, \"condition\"),\n                    }),\n                    consequent: seq_tail.consequent,\n                    alternative: merge_expression(seq_tail.alternative, alternative),\n                });\n            }\n            // x ? (y ? a : b) : a ---> !x || y ? a : b\n            if (seq_tail instanceof AST_Conditional\n                && seq_tail.consequent.equals(alternative)) {\n                return make_node(AST_Conditional, self, {\n                    condition: make_node(AST_Binary, self, {\n                        left: negated,\n                        operator: \"||\",\n                        right: fuse(consequent, seq_tail, \"condition\"),\n                    }),\n                    consequent: merge_expression(seq_tail.consequent, alternative),\n                    alternative: seq_tail.alternative,\n                });\n            }\n            // x ? a : (y ? a : b) ---> x || y ? a : b\n            if (alt_tail instanceof AST_Conditional\n                && consequent.equals(alt_tail.consequent)) {\n                return make_node(AST_Conditional, self, {\n                    condition: make_node(AST_Binary, self, {\n                        left: condition,\n                        operator: \"||\",\n                        right: fuse(alternative, alt_tail, \"condition\"),\n                    }),\n                    consequent: merge_expression(consequent, alt_tail.consequent),\n                    alternative: alt_tail.alternative,\n                });\n            }\n            // x ? b : (y ? a : b) ---> !x && y ? a : b\n            if (alt_tail instanceof AST_Conditional\n                && consequent.equals(alt_tail.alternative)) {\n                return make_node(AST_Conditional, self, {\n                    condition: make_node(AST_Binary, self, {\n                        left: negated,\n                        operator: \"&&\",\n                        right: fuse(alternative, alt_tail, \"condition\"),\n                    }),\n                    consequent: alt_tail.consequent,\n                    alternative: merge_expression(consequent, alt_tail.alternative),\n                });\n            }\n            // x ? y && a : a ---> (!x || y) && a\n            if (seq_tail instanceof AST_Binary\n                && seq_tail.operator == \"&&\"\n                && seq_tail.right.equals(alternative)) {\n                return make_node(AST_Binary, self, {\n                    operator: \"&&\",\n                    left: make_node(AST_Binary, self, {\n                        operator: \"||\",\n                        left: negated,\n                        right: fuse(consequent, seq_tail, \"left\"),\n                    }),\n                    right: merge_expression(seq_tail.right, alternative),\n                }).optimize(compressor);\n            }\n            // x ? y || a : a ---> x && y || a\n            if (seq_tail instanceof AST_Binary\n                && seq_tail.operator == \"||\"\n                && seq_tail.right.equals(alternative)) {\n                return make_node(AST_Binary, self, {\n                    operator: \"||\",\n                    left: make_node(AST_Binary, self, {\n                        operator: \"&&\",\n                        left: condition,\n                        right: fuse(consequent, seq_tail, \"left\"),\n                    }),\n                    right: merge_expression(seq_tail.right, alternative),\n                }).optimize(compressor);\n            }\n            // x ? a : y && a ---> (x || y) && a\n            if (alt_tail instanceof AST_Binary\n                && alt_tail.operator == \"&&\"\n                && alt_tail.right.equals(consequent)) {\n                return make_node(AST_Binary, self, {\n                    operator: \"&&\",\n                    left: make_node(AST_Binary, self, {\n                        operator: \"||\",\n                        left: condition,\n                        right: fuse(alternative, alt_tail, \"left\"),\n                    }),\n                    right: merge_expression(consequent, alt_tail.right),\n                }).optimize(compressor);\n            }\n            // x ? a : y || a ---> !x && y || a\n            if (alt_tail instanceof AST_Binary\n                && alt_tail.operator == \"||\"\n                && alt_tail.right.equals(consequent)) {\n                return make_node(AST_Binary, self, {\n                    operator: \"||\",\n                    left: make_node(AST_Binary, self, {\n                        operator: \"&&\",\n                        left: negated,\n                        right: fuse(alternative, alt_tail, \"left\"),\n                    }),\n                    right: merge_expression(consequent, alt_tail.right),\n                }).optimize(compressor);\n            }\n            var in_bool = compressor.option(\"booleans\") && compressor.in_boolean_context();\n            if (is_true(consequent)) {\n                // c ? true : false ---> !!c\n                if (is_false(alternative)) return booleanize(condition);\n                // c ? true : x ---> !!c || x\n                return make_node(AST_Binary, self, {\n                    operator: \"||\",\n                    left: booleanize(condition),\n                    right: alternative,\n                }).optimize(compressor);\n            }\n            if (is_false(consequent)) {\n                // c ? false : true ---> !c\n                if (is_true(alternative)) return booleanize(condition.negate(compressor));\n                // c ? false : x ---> !c && x\n                return make_node(AST_Binary, self, {\n                    operator: \"&&\",\n                    left: booleanize(condition.negate(compressor)),\n                    right: alternative,\n                }).optimize(compressor);\n            }\n            // c ? x : true ---> !c || x\n            if (is_true(alternative)) return make_node(AST_Binary, self, {\n                operator: \"||\",\n                left: booleanize(condition.negate(compressor)),\n                right: consequent,\n            }).optimize(compressor);\n            // c ? x : false ---> !!c && x\n            if (is_false(alternative)) return make_node(AST_Binary, self, {\n                operator: \"&&\",\n                left: booleanize(condition),\n                right: consequent,\n            }).optimize(compressor);\n            if (compressor.option(\"typeofs\")) mark_locally_defined(condition, consequent, alternative);\n            return self;\n\n            function booleanize(node) {\n                if (node.is_boolean(compressor)) return node;\n                // !!expression\n                return make_node(AST_UnaryPrefix, node, {\n                    operator: \"!\",\n                    expression: node.negate(compressor),\n                });\n            }\n\n            // AST_True or !0\n            function is_true(node) {\n                return node instanceof AST_True\n                    || in_bool\n                        && node instanceof AST_Constant\n                        && node.value\n                    || (node instanceof AST_UnaryPrefix\n                        && node.operator == \"!\"\n                        && node.expression instanceof AST_Constant\n                        && !node.expression.value);\n            }\n            // AST_False or !1 or void 0\n            function is_false(node) {\n                return node instanceof AST_False\n                    || in_bool\n                        && (node instanceof AST_Constant\n                                && !node.value\n                            || node instanceof AST_UnaryPrefix\n                                && node.operator == \"void\"\n                                && !node.expression.has_side_effects(compressor))\n                    || (node instanceof AST_UnaryPrefix\n                        && node.operator == \"!\"\n                        && node.expression instanceof AST_Constant\n                        && node.expression.value);\n            }\n\n            function arg_diff(consequent, alternative) {\n                var a = consequent.args;\n                var b = alternative.args;\n                var len = a.length;\n                if (len != b.length) return -2;\n                for (var i = 0; i < len; i++) {\n                    if (!a[i].equals(b[i])) {\n                        if (a[i] instanceof AST_Spread !== b[i] instanceof AST_Spread) return -3;\n                        for (var j = i + 1; j < len; j++) {\n                            if (!a[j].equals(b[j])) return -2;\n                        }\n                        return i;\n                    }\n                }\n                return -1;\n            }\n\n            function fuse(node, tail, prop) {\n                if (node === tail) return tail[prop];\n                var exprs = node.expressions.slice(0, -1);\n                exprs.push(tail[prop]);\n                return make_sequence(node, exprs);\n            }\n\n            function is_tail_equivalent(consequent, alternative) {\n                if (consequent.TYPE != alternative.TYPE) return;\n                if (consequent.optional != alternative.optional) return;\n                if (consequent instanceof AST_Call) {\n                    if (arg_diff(consequent, alternative) != -1) return;\n                    return consequent.TYPE != \"Call\"\n                        || !(consequent.expression instanceof AST_PropAccess\n                            || alternative.expression instanceof AST_PropAccess)\n                        || is_tail_equivalent(consequent.expression, alternative.expression);\n                }\n                if (!(consequent instanceof AST_PropAccess)) return;\n                var p = consequent.property;\n                var q = alternative.property;\n                return (p instanceof AST_Node ? p.equals(q) : p == q)\n                    && !(consequent.expression instanceof AST_Super || alternative.expression instanceof AST_Super);\n            }\n\n            function combine_tail(consequent, alternative, top) {\n                var seq_tail = consequent.tail_node();\n                var alt_tail = alternative.tail_node();\n                if (!is_tail_equivalent(seq_tail, alt_tail)) return !top && make_node(AST_Conditional, self, {\n                    condition: condition,\n                    consequent: consequent,\n                    alternative: alternative,\n                });\n                var node = seq_tail.clone();\n                var seq_expr = fuse(consequent, seq_tail, \"expression\");\n                var alt_expr = fuse(alternative, alt_tail, \"expression\");\n                var combined = combine_tail(seq_expr, alt_expr);\n                if (seq_tail.expression instanceof AST_Sequence) {\n                    combined = maintain_this_binding(seq_tail, seq_tail.expression, combined);\n                }\n                node.expression = combined;\n                return node;\n            }\n\n            function can_shift_lhs_of_tail(node) {\n                return node === node.tail_node() || all(node.expressions.slice(0, -1), function(expr) {\n                    return !expr.has_side_effects(compressor);\n                });\n            }\n\n            function pop_lhs(node) {\n                if (!(node instanceof AST_Sequence)) return node.right;\n                var exprs = node.expressions.slice();\n                exprs.push(exprs.pop().right);\n                return make_sequence(node, exprs);\n            }\n\n            function pop_seq(node) {\n                if (!(node instanceof AST_Sequence)) return make_node(AST_Number, node, { value: 0 });\n                return make_sequence(node, node.expressions.slice(0, -1));\n            }\n        });\n\n        OPT(AST_Boolean, function(self, compressor) {\n            if (!compressor.option(\"booleans\")) return self;\n            if (compressor.in_boolean_context()) return make_node(AST_Number, self, { value: +self.value });\n            var p = compressor.parent();\n            if (p instanceof AST_Binary && (p.operator == \"==\" || p.operator == \"!=\")) {\n                AST_Node.warn(\"Non-strict equality against boolean: {operator} {value} [{start}]\", {\n                    operator: p.operator,\n                    value: self.value,\n                    start: p.start,\n                });\n                return make_node(AST_Number, self, { value: +self.value });\n            }\n            return make_node(AST_UnaryPrefix, self, {\n                operator: \"!\",\n                expression: make_node(AST_Number, self, { value: 1 - self.value }),\n            });\n        });\n\n        OPT(AST_Spread, function(self, compressor) {\n            var exp = self.expression;\n            if (compressor.option(\"spreads\") && exp instanceof AST_Array && !(compressor.parent() instanceof AST_Object)) {\n                return List.splice(exp.elements.map(function(node) {\n                    return node instanceof AST_Hole ? make_node(AST_Undefined, node).optimize(compressor) : node;\n                }));\n            }\n            return self;\n        });\n\n        function safe_to_flatten(value, compressor) {\n            if (!value) return false;\n            var parent = compressor.parent();\n            if (parent.TYPE != \"Call\") return true;\n            if (parent.expression !== compressor.self()) return true;\n            if (value instanceof AST_SymbolRef) {\n                value = value.fixed_value();\n                if (!value) return false;\n            }\n            return value instanceof AST_Lambda && !value.contains_this();\n        }\n\n        OPT(AST_Sub, function(self, compressor) {\n            var expr = self.expression;\n            var prop = self.property;\n            var terminated = trim_optional_chain(self, compressor);\n            if (terminated) return terminated;\n            if (compressor.option(\"properties\")) {\n                var key = prop.evaluate(compressor);\n                if (key !== prop) {\n                    if (typeof key == \"string\") {\n                        if (key == \"undefined\") {\n                            key = undefined;\n                        } else {\n                            var value = parseFloat(key);\n                            if (value.toString() == key) {\n                                key = value;\n                            }\n                        }\n                    }\n                    prop = self.property = best_of_expression(prop, make_node_from_constant(key, prop).transform(compressor));\n                    var property = \"\" + key;\n                    if (is_identifier_string(property)\n                        && property.length <= prop.print_to_string().length + 1) {\n                        return make_node(AST_Dot, self, {\n                            optional: self.optional,\n                            expression: expr,\n                            property: property,\n                            quoted: true,\n                        }).optimize(compressor);\n                    }\n                }\n            }\n            var parent = compressor.parent();\n            var assigned = is_lhs(compressor.self(), parent);\n            var def, fn, fn_parent, index;\n            if (compressor.option(\"arguments\")\n                && expr instanceof AST_SymbolRef\n                && is_arguments(def = expr.definition())\n                && !expr.in_arg\n                && prop instanceof AST_Number\n                && Math.floor(index = prop.value) == index\n                && (fn = def.scope) === find_lambda()\n                && fn.uses_arguments < (assigned ? 2 : 3)) {\n                if (parent instanceof AST_UnaryPrefix && parent.operator == \"delete\") {\n                    if (!def.deleted) def.deleted = [];\n                    def.deleted[index] = true;\n                }\n                var argname = fn.argnames[index];\n                if (def.deleted && def.deleted[index]) {\n                    argname = null;\n                } else if (argname) {\n                    var arg_def;\n                    if (!(argname instanceof AST_SymbolFunarg)\n                        || argname.name == \"await\"\n                        || expr.scope.find_variable(argname.name) !== (arg_def = argname.definition())) {\n                        argname = null;\n                    } else if (compressor.has_directive(\"use strict\")\n                        || fn.name\n                        || fn.rest\n                        || !(fn_parent instanceof AST_Call\n                            && index < fn_parent.args.length\n                            && all(fn_parent.args.slice(0, index + 1), function(arg) {\n                                return !(arg instanceof AST_Spread);\n                            }))\n                        || !all(fn.argnames, function(argname) {\n                            return argname instanceof AST_SymbolFunarg;\n                        })) {\n                        if (has_reassigned() || arg_def.assignments || arg_def.orig.length > 1) argname = null;\n                    }\n                } else if ((assigned || !has_reassigned())\n                    && index < fn.argnames.length + 5\n                    && compressor.drop_fargs(fn, fn_parent)\n                    && !fn.rest) {\n                    while (index >= fn.argnames.length) {\n                        argname = fn.make_var(AST_SymbolFunarg, fn, \"argument_\" + fn.argnames.length);\n                        fn.argnames.push(argname);\n                    }\n                }\n                if (argname && find_if(function(node) {\n                    return node.name === argname.name;\n                }, fn.argnames) === argname) {\n                    if (assigned) def.reassigned--;\n                    var sym = make_node(AST_SymbolRef, argname);\n                    sym.reference();\n                    argname.unused = undefined;\n                    return sym;\n                }\n            }\n            if (assigned) return self;\n            if (compressor.option(\"sequences\")\n                && parent.TYPE != \"Call\"\n                && !(parent instanceof AST_ForEnumeration && parent.init === self)) {\n                var seq = lift_sequence_in_expression(self, compressor);\n                if (seq !== self) return seq.optimize(compressor);\n            }\n            if (key !== prop) {\n                var sub = self.flatten_object(property, compressor);\n                if (sub) {\n                    expr = self.expression = sub.expression;\n                    prop = self.property = sub.property;\n                }\n            }\n            var elements;\n            if (compressor.option(\"properties\")\n                && compressor.option(\"side_effects\")\n                && prop instanceof AST_Number\n                && expr instanceof AST_Array\n                && all(elements = expr.elements, function(value) {\n                    return !(value instanceof AST_Spread);\n                })) {\n                var index = prop.value;\n                var retValue = elements[index];\n                if (safe_to_flatten(retValue, compressor)) {\n                    var is_hole = retValue instanceof AST_Hole;\n                    var flatten = !is_hole;\n                    var values = [];\n                    for (var i = elements.length; --i > index;) {\n                        var value = elements[i].drop_side_effect_free(compressor);\n                        if (value) {\n                            values.unshift(value);\n                            if (flatten && value.has_side_effects(compressor)) flatten = false;\n                        }\n                    }\n                    if (!flatten) values.unshift(retValue);\n                    while (--i >= 0) {\n                        var value = elements[i].drop_side_effect_free(compressor);\n                        if (value) {\n                            values.unshift(value);\n                        } else if (is_hole) {\n                            values.unshift(make_node(AST_Hole, elements[i]));\n                        } else {\n                            index--;\n                        }\n                    }\n                    if (flatten) {\n                        values.push(retValue);\n                        return make_sequence(self, values).optimize(compressor);\n                    }\n                    return make_node(AST_Sub, self, {\n                        expression: make_node(AST_Array, expr, { elements: values }),\n                        property: make_node(AST_Number, prop, { value: index }),\n                    });\n                }\n            }\n            return try_evaluate(compressor, self);\n\n            function find_lambda() {\n                var i = 0, p;\n                while (p = compressor.parent(i++)) {\n                    if (p instanceof AST_Lambda) {\n                        if (p instanceof AST_Accessor) return;\n                        if (is_arrow(p)) continue;\n                        fn_parent = compressor.parent(i);\n                        return p;\n                    }\n                }\n            }\n\n            function has_reassigned() {\n                return !compressor.option(\"reduce_vars\") || def.reassigned;\n            }\n        });\n\n        AST_LambdaExpression.DEFMETHOD(\"contains_super\", function() {\n            var result = false;\n            var self = this;\n            self.walk(new TreeWalker(function(node) {\n                if (result) return true;\n                if (node instanceof AST_Super) return result = true;\n                if (node !== self && node instanceof AST_Scope && !is_arrow(node)) return true;\n            }));\n            return result;\n        });\n\n        // contains_this()\n        // returns false only if context bound by the specified scope (or scope\n        // containing the specified expression) is not referenced by `this`\n        (function(def) {\n            // scope of arrow function cannot bind to any context\n            def(AST_Arrow, return_false);\n            def(AST_AsyncArrow, return_false);\n            def(AST_Node, function() {\n                var result = false;\n                var self = this;\n                self.walk(new TreeWalker(function(node) {\n                    if (result) return true;\n                    if (node instanceof AST_This) return result = true;\n                    if (node !== self && node instanceof AST_Scope && !is_arrow(node)) return true;\n                }));\n                return result;\n            });\n        })(function(node, func) {\n            node.DEFMETHOD(\"contains_this\", func);\n        });\n\n        function can_hoist_property(prop) {\n            return prop instanceof AST_ObjectKeyVal\n                && typeof prop.key == \"string\"\n                && !(prop instanceof AST_ObjectMethod && prop.value.contains_super());\n        }\n\n        AST_PropAccess.DEFMETHOD(\"flatten_object\", function(key, compressor) {\n            if (!compressor.option(\"properties\")) return;\n            if (key === \"__proto__\") return;\n            var self = this;\n            var expr = self.expression;\n            if (!(expr instanceof AST_Object)) return;\n            var props = expr.properties;\n            for (var i = props.length; --i >= 0;) {\n                var prop = props[i];\n                if (prop.key !== key) continue;\n                if (!all(props, can_hoist_property)) return;\n                if (!safe_to_flatten(prop.value, compressor)) return;\n                var call, scope, values = [];\n                for (var j = 0; j < props.length; j++) {\n                    var value = props[j].value;\n                    if (props[j] instanceof AST_ObjectMethod) {\n                        var arrow = !(value.uses_arguments || is_generator(value) || value.contains_this());\n                        if (arrow) {\n                            if (!scope) scope = compressor.find_parent(AST_Scope);\n                            var avoid = avoid_await_yield(compressor, scope);\n                            value.each_argname(function(argname) {\n                                if (avoid[argname.name]) arrow = false;\n                            });\n                        }\n                        var ctor;\n                        if (arrow) {\n                            ctor = is_async(value) ? AST_AsyncArrow : AST_Arrow;\n                        } else if (i != j\n                            || (call = compressor.parent()) instanceof AST_Call && call.expression === self) {\n                            ctor = value.CTOR;\n                        } else {\n                            return;\n                        }\n                        value = make_node(ctor, value);\n                    }\n                    values.push(value);\n                }\n                return make_node(AST_Sub, self, {\n                    expression: make_node(AST_Array, expr, { elements: values }),\n                    property: make_node(AST_Number, self, { value: i }),\n                });\n            }\n        });\n\n        OPT(AST_Dot, function(self, compressor) {\n            if (self.property == \"arguments\" || self.property == \"caller\") {\n                AST_Node.warn(\"Function.prototype.{property} not supported [{start}]\", self);\n            }\n            var parent = compressor.parent();\n            if (is_lhs(compressor.self(), parent)) return self;\n            var terminated = trim_optional_chain(self, compressor);\n            if (terminated) return terminated;\n            if (compressor.option(\"sequences\")\n                && parent.TYPE != \"Call\"\n                && !(parent instanceof AST_ForEnumeration && parent.init === self)) {\n                var seq = lift_sequence_in_expression(self, compressor);\n                if (seq !== self) return seq.optimize(compressor);\n            }\n            if (compressor.option(\"unsafe_proto\")\n                && self.expression instanceof AST_Dot\n                && self.expression.property == \"prototype\") {\n                var exp = self.expression.expression;\n                if (is_undeclared_ref(exp)) switch (exp.name) {\n                  case \"Array\":\n                    self.expression = make_node(AST_Array, self.expression, { elements: [] });\n                    break;\n                  case \"Function\":\n                    self.expression = make_node(AST_Function, self.expression, {\n                        argnames: [],\n                        body: [],\n                    }).init_vars(exp.scope);\n                    break;\n                  case \"Number\":\n                    self.expression = make_node(AST_Number, self.expression, { value: 0 });\n                    break;\n                  case \"Object\":\n                    self.expression = make_node(AST_Object, self.expression, { properties: [] });\n                    break;\n                  case \"RegExp\":\n                    self.expression = make_node(AST_RegExp, self.expression, { value: /t/ });\n                    break;\n                  case \"String\":\n                    self.expression = make_node(AST_String, self.expression, { value: \"\" });\n                    break;\n                }\n            }\n            var sub = self.flatten_object(self.property, compressor);\n            if (sub) return sub.optimize(compressor);\n            return try_evaluate(compressor, self);\n        });\n\n        OPT(AST_DestructuredArray, function(self, compressor) {\n            if (compressor.option(\"rests\") && self.rest instanceof AST_DestructuredArray) {\n                return make_node(AST_DestructuredArray, self, {\n                    elements: self.elements.concat(self.rest.elements),\n                    rest: self.rest.rest,\n                });\n            }\n            return self;\n        });\n\n        OPT(AST_DestructuredKeyVal, function(self, compressor) {\n            if (compressor.option(\"objects\")) {\n                var key = self.key;\n                if (key instanceof AST_Node) {\n                    key = key.evaluate(compressor);\n                    if (key !== self.key) self.key = \"\" + key;\n                }\n            }\n            return self;\n        });\n\n        OPT(AST_Object, function(self, compressor) {\n            if (!compressor.option(\"objects\")) return self;\n            var changed = false;\n            var found = false;\n            var generated = false;\n            var keep_duplicate = compressor.has_directive(\"use strict\");\n            var keys = [];\n            var map = new Dictionary();\n            var values = [];\n            self.properties.forEach(function(prop) {\n                if (!(prop instanceof AST_Spread)) return process(prop);\n                found = true;\n                var exp = prop.expression;\n                if (compressor.option(\"spreads\") && exp instanceof AST_Object && all(exp.properties, function(prop) {\n                    if (prop instanceof AST_ObjectGetter) return false;\n                    if (prop instanceof AST_Spread) return false;\n                    if (prop.key !== \"__proto__\") return true;\n                    if (prop instanceof AST_ObjectSetter) return true;\n                    return !prop.value.has_side_effects(compressor);\n                })) {\n                    changed = true;\n                    exp.properties.forEach(function(prop) {\n                        var key = prop.key;\n                        var setter = prop instanceof AST_ObjectSetter;\n                        if (key === \"__proto__\") {\n                            if (!setter) return;\n                            key = make_node_from_constant(key, prop);\n                        }\n                        process(setter ? make_node(AST_ObjectKeyVal, prop, {\n                            key: key,\n                            value: make_node(AST_Undefined, prop).optimize(compressor),\n                        }) : prop);\n                    });\n                } else {\n                    generated = true;\n                    flush();\n                    values.push(prop);\n                }\n            });\n            flush();\n            if (!changed) return self;\n            if (found && generated && values.length == 1) {\n                var value = values[0];\n                if (value instanceof AST_ObjectProperty && value.key instanceof AST_Number) {\n                    value.key = \"\" + value.key.value;\n                }\n            }\n            return make_node(AST_Object, self, { properties: values });\n\n            function flush() {\n                keys.forEach(function(key) {\n                    var props = map.get(key);\n                    switch (props.length) {\n                      case 0:\n                        return;\n                      case 1:\n                        return values.push(props[0]);\n                    }\n                    changed = true;\n                    var tail = keep_duplicate && !generated && props.pop();\n                    values.push(props.length == 1 ? props[0] : make_node(AST_ObjectKeyVal, self, {\n                        key: props[0].key,\n                        value: make_sequence(self, props.map(function(prop) {\n                            return prop.value;\n                        })),\n                    }));\n                    if (tail) values.push(tail);\n                    props.length = 0;\n                });\n                keys = [];\n                map = new Dictionary();\n            }\n\n            function process(prop) {\n                var key = prop.key;\n                if (key instanceof AST_Node) {\n                    found = true;\n                    key = key.evaluate(compressor);\n                    if (key === prop.key || key === \"__proto__\") {\n                        generated = true;\n                    } else {\n                        key = prop.key = \"\" + key;\n                    }\n                }\n                if (can_hoist_property(prop)) {\n                    if (prop.value.has_side_effects(compressor)) flush();\n                    keys.push(key);\n                    map.add(key, prop);\n                } else {\n                    flush();\n                    values.push(prop);\n                }\n                if (found && !generated && typeof key == \"string\" && RE_POSITIVE_INTEGER.test(key)) {\n                    generated = true;\n                    if (map.has(key)) prop = map.get(key)[0];\n                    prop.key = make_node(AST_Number, prop, { value: +key });\n                }\n            }\n        });\n\n        function flatten_var(name) {\n            var redef = name.definition().redefined();\n            if (redef) {\n                name = name.clone();\n                name.thedef = redef;\n            }\n            return name;\n        }\n\n        function has_arg_refs(fn, node) {\n            var found = false;\n            node.walk(new TreeWalker(function(node) {\n                if (found) return true;\n                if (node instanceof AST_SymbolRef && fn.variables.get(node.name) === node.definition()) {\n                    return found = true;\n                }\n            }));\n            return found;\n        }\n\n        function insert_assign(def, assign) {\n            var visited = [];\n            def.references.forEach(function(ref) {\n                var fixed = ref.fixed;\n                if (!fixed || !push_uniq(visited, fixed)) return;\n                if (fixed.assigns) {\n                    fixed.assigns.unshift(assign);\n                } else {\n                    fixed.assigns = [ assign ];\n                }\n            });\n        }\n\n        function init_ref(compressor, name) {\n            var sym = make_node(AST_SymbolRef, name);\n            var assign = make_node(AST_Assign, name, {\n                operator: \"=\",\n                left: sym,\n                right: make_node(AST_Undefined, name).transform(compressor),\n            });\n            var def = name.definition();\n            if (def.fixed) {\n                sym.fixed = function() {\n                    return assign.right;\n                };\n                sym.fixed.assigns = [ assign ];\n                insert_assign(def, assign);\n            }\n            def.assignments++;\n            def.references.push(sym);\n            return assign;\n        }\n\n        (function(def) {\n            def(AST_Node, noop);\n            def(AST_Assign, noop);\n            def(AST_Await, function(compressor, scope, no_return, in_loop) {\n                if (!compressor.option(\"awaits\")) return;\n                var self = this;\n                var inlined = self.expression.try_inline(compressor, scope, no_return, in_loop, true);\n                if (!inlined) return;\n                if (!no_return) scan_local_returns(inlined, function(node) {\n                    node.in_bool = false;\n                    var value = node.value;\n                    if (value instanceof AST_Await) return;\n                    node.value = make_node(AST_Await, self, {\n                        expression: value || make_node(AST_Undefined, node).transform(compressor),\n                    });\n                });\n                return aborts(inlined) ? inlined : make_node(AST_BlockStatement, self, {\n                    body: [ inlined, make_node(AST_SimpleStatement, self, {\n                        body: make_node(AST_Await, self, { expression: make_node(AST_Number, self, { value: 0 })}),\n                    }) ],\n                });\n            });\n            def(AST_Binary, function(compressor, scope, no_return, in_loop, in_await) {\n                if (no_return === undefined) return;\n                var self = this;\n                var op = self.operator;\n                if (!lazy_op[op]) return;\n                var inlined = self.right.try_inline(compressor, scope, no_return, in_loop, in_await);\n                if (!inlined) return;\n                return make_node(AST_If, self, {\n                    condition: make_condition(self.left),\n                    body: inlined,\n                    alternative: no_return ? null : make_node(AST_Return, self, {\n                        value: make_node(AST_Undefined, self).transform(compressor),\n                    }),\n                });\n\n                function make_condition(cond) {\n                    switch (op) {\n                      case \"&&\":\n                        return cond;\n                      case \"||\":\n                        return cond.negate(compressor);\n                      case \"??\":\n                        return make_node(AST_Binary, self, {\n                            operator: \"==\",\n                            left: make_node(AST_Null, self),\n                            right: cond,\n                        });\n                    }\n                }\n            });\n            def(AST_BlockStatement, function(compressor, scope, no_return, in_loop) {\n                if (no_return) return;\n                if (!this.variables) return;\n                var body = this.body;\n                var last = body.length - 1;\n                if (last < 0) return;\n                var inlined = body[last].try_inline(compressor, this, no_return, in_loop);\n                if (!inlined) return;\n                body[last] = inlined;\n                return this;\n            });\n            def(AST_Call, function(compressor, scope, no_return, in_loop, in_await) {\n                if (compressor.option(\"inline\") < 4) return;\n                var call = this;\n                if (call.is_expr_pure(compressor)) return;\n                var fn = call.expression;\n                if (!(fn instanceof AST_LambdaExpression)) return;\n                if (fn.name) return;\n                if (fn.uses_arguments) return;\n                if (fn.pinned()) return;\n                if (is_generator(fn)) return;\n                var arrow = is_arrow(fn);\n                if (arrow && fn.value) return;\n                if (fn.body[0] instanceof AST_Directive) return;\n                if (fn.contains_this()) return;\n                if (!scope) scope = find_scope(compressor);\n                var defined = new Dictionary();\n                defined.set(\"NaN\", true);\n                while (!(scope instanceof AST_Scope)) {\n                    scope.variables.each(function(def) {\n                        defined.set(def.name, true);\n                    });\n                    scope = scope.parent_scope;\n                }\n                if (!member(scope, compressor.stack)) return;\n                if (scope.pinned() && fn.variables.size() > (arrow ? 0 : 1)) return;\n                if (scope instanceof AST_Toplevel) {\n                    if (fn.variables.size() > (arrow ? 0 : 1)) {\n                        if (!compressor.toplevel.vars) return;\n                        if (fn.functions.size() > 0 && !compressor.toplevel.funcs) return;\n                    }\n                    defined.set(\"arguments\", true);\n                }\n                var async = !in_await && is_async(fn);\n                if (async) {\n                    if (!compressor.option(\"awaits\")) return;\n                    if (!is_async(scope)) return;\n                    if (call.may_throw(compressor)) return;\n                }\n                var names = scope.var_names();\n                if (in_loop) in_loop = [];\n                if (!fn.variables.all(function(def, name) {\n                    if (in_loop) in_loop.push(def);\n                    if (!defined.has(name) && !names.has(name)) return true;\n                    return !arrow && name == \"arguments\" && def.orig.length == 1;\n                })) return;\n                if (in_loop && in_loop.length > 0 && is_reachable(fn, in_loop)) return;\n                var simple_argnames = true;\n                if (!all(fn.argnames, function(argname) {\n                    var abort = false;\n                    var tw = new TreeWalker(function(node) {\n                        if (abort) return true;\n                        if (node instanceof AST_DefaultValue) {\n                            if (has_arg_refs(fn, node.value)) return abort = true;\n                            node.name.walk(tw);\n                            return true;\n                        }\n                        if (node instanceof AST_DestructuredKeyVal) {\n                            if (node.key instanceof AST_Node && has_arg_refs(fn, node.key)) return abort = true;\n                            node.value.walk(tw);\n                            return true;\n                        }\n                        if (node instanceof AST_SymbolFunarg && !all(node.definition().orig, function(sym) {\n                            return !(sym instanceof AST_SymbolDefun);\n                        })) return abort = true;\n                    });\n                    argname.walk(tw);\n                    if (abort) return false;\n                    if (!(argname instanceof AST_SymbolFunarg)) simple_argnames = false;\n                    return true;\n                })) return;\n                if (fn.rest) {\n                    if (has_arg_refs(fn, fn.rest)) return;\n                    simple_argnames = false;\n                }\n                var verify_body;\n                if (no_return) {\n                    verify_body = function(stat) {\n                        var abort = false;\n                        stat.walk(new TreeWalker(function(node) {\n                            if (abort) return true;\n                            if (async && (node instanceof AST_Await || node instanceof AST_ForAwaitOf)\n                                || node instanceof AST_Return) {\n                                return abort = true;\n                            }\n                            if (node instanceof AST_Scope) return true;\n                        }));\n                        return !abort;\n                    };\n                } else if (in_await || is_async(fn) || in_async_generator(scope)) {\n                    verify_body = function(stat) {\n                        var abort = false;\n                        var find_return = new TreeWalker(function(node) {\n                            if (abort) return true;\n                            if (node instanceof AST_Return) return abort = true;\n                            if (node instanceof AST_Scope) return true;\n                        });\n                        stat.walk(new TreeWalker(function(node) {\n                            if (abort) return true;\n                            if (node instanceof AST_Try) {\n                                if (node.bfinally && all(node.body, function(stat) {\n                                    stat.walk(find_return);\n                                    return !abort;\n                                }) && node.bcatch) node.bcatch.walk(find_return);\n                                return true;\n                            }\n                            if (node instanceof AST_Scope) return true;\n                        }));\n                        return !abort;\n                    };\n                }\n                if (verify_body && !all(fn.body, verify_body)) return;\n                if (!safe_from_await_yield(fn, avoid_await_yield(compressor, scope))) return;\n                fn.functions.each(function(def, name) {\n                    scope.functions.set(name, def);\n                });\n                var body = [];\n                fn.variables.each(function(def, name) {\n                    if (!arrow && name == \"arguments\" && def.orig.length == 1) return;\n                    names.set(name, true);\n                    scope.enclosed.push(def);\n                    scope.variables.set(name, def);\n                    def.single_use = false;\n                    if (!in_loop) return;\n                    if (def.references.length == def.replaced) return;\n                    if (def.orig.length == def.eliminated) return;\n                    if (def.orig.length == 1 && fn.functions.has(name)) return;\n                    if (!all(def.orig, function(sym) {\n                        if (sym instanceof AST_SymbolConst) return false;\n                        if (sym instanceof AST_SymbolFunarg) return !sym.unused && def.scope.resolve() !== fn;\n                        if (sym instanceof AST_SymbolLet) return false;\n                        return true;\n                    })) return;\n                    var sym = def.orig[0];\n                    if (sym instanceof AST_SymbolCatch) return;\n                    body.push(make_node(AST_SimpleStatement, sym, { body: init_ref(compressor, flatten_var(sym)) }));\n                });\n                var defs = Object.create(null), syms = new Dictionary();\n                if (simple_argnames && all(call.args, function(arg) {\n                    return !(arg instanceof AST_Spread);\n                })) {\n                    var values = call.args.slice();\n                    fn.argnames.forEach(function(argname) {\n                        var value = values.shift();\n                        if (argname.unused) {\n                            if (value) body.push(make_node(AST_SimpleStatement, call, { body: value }));\n                            return;\n                        }\n                        var defn = make_node(AST_VarDef, call, {\n                            name: argname.convert_symbol(AST_SymbolVar, process),\n                            value: value || make_node(AST_Undefined, call).transform(compressor),\n                        });\n                        if (argname instanceof AST_SymbolFunarg) insert_assign(argname.definition(), defn);\n                        body.push(make_node(AST_Var, call, { definitions: [ defn ] }));\n                    });\n                    if (values.length) body.push(make_node(AST_SimpleStatement, call, {\n                        body: make_sequence(call, values),\n                    }));\n                } else {\n                    body.push(make_node(AST_Var, call, {\n                        definitions: [ make_node(AST_VarDef, call, {\n                            name: make_node(AST_DestructuredArray, call, {\n                                elements: fn.argnames.map(function(argname) {\n                                    if (argname.unused) return make_node(AST_Hole, argname);\n                                    return argname.convert_symbol(AST_SymbolVar, process);\n                                }),\n                                rest: fn.rest && fn.rest.convert_symbol(AST_SymbolVar, process),\n                            }),\n                            value: make_node(AST_Array, call, { elements: call.args.slice() }),\n                        }) ],\n                    }));\n                }\n                syms.each(function(orig, id) {\n                    var def = defs[id];\n                    [].unshift.apply(def.orig, orig);\n                    def.eliminated += orig.length;\n                });\n                [].push.apply(body, in_loop ? fn.body.filter(function(stat) {\n                    if (!(stat instanceof AST_LambdaDefinition)) return true;\n                    var name = make_node(AST_SymbolVar, flatten_var(stat.name));\n                    var def = name.definition();\n                    def.fixed = false;\n                    def.orig.push(name);\n                    def.eliminated++;\n                    body.push(make_node(AST_Var, stat, {\n                        definitions: [ make_node(AST_VarDef, stat, {\n                            name: name,\n                            value: to_func_expr(stat, true),\n                        }) ],\n                    }));\n                    return false;\n                }) : fn.body);\n                var inlined = make_node(AST_BlockStatement, call, { body: body });\n                if (!no_return) {\n                    if (async) scan_local_returns(inlined, function(node) {\n                        var value = node.value;\n                        if (is_undefined(value)) return;\n                        node.value = make_node(AST_Await, call, { expression: value });\n                    });\n                    body.push(make_node(AST_Return, call, {\n                        value: in_async_generator(scope) ? make_node(AST_Undefined, call).transform(compressor) : null,\n                    }));\n                }\n                return inlined;\n\n                function process(sym, argname) {\n                    var def = argname.definition();\n                    defs[def.id] = def;\n                    syms.add(def.id, sym);\n                }\n            });\n            def(AST_Conditional, function(compressor, scope, no_return, in_loop, in_await) {\n                var self = this;\n                var body = self.consequent.try_inline(compressor, scope, no_return, in_loop, in_await);\n                var alt = self.alternative.try_inline(compressor, scope, no_return, in_loop, in_await);\n                if (!body && !alt) return;\n                return make_node(AST_If, self, {\n                    condition: self.condition,\n                    body: body || make_body(self.consequent),\n                    alternative: alt || make_body(self.alternative),\n                });\n\n                function make_body(value) {\n                    if (no_return) return make_node(AST_SimpleStatement, value, { body: value });\n                    return make_node(AST_Return, value, { value: value });\n                }\n            });\n            def(AST_For, function(compressor, scope, no_return, in_loop) {\n                var body = this.body.try_inline(compressor, scope, true, true);\n                if (body) this.body = body;\n                var inlined = this.init;\n                if (inlined) {\n                    inlined = inlined.try_inline(compressor, scope, true, in_loop);\n                    if (inlined) {\n                        this.init = null;\n                        if (inlined instanceof AST_BlockStatement) {\n                            inlined.body.push(this);\n                            return inlined;\n                        }\n                        return make_node(AST_BlockStatement, inlined, { body: [ inlined, this ] });\n                    }\n                }\n                return body && this;\n            });\n            def(AST_ForEnumeration, function(compressor, scope, no_return, in_loop) {\n                var body = this.body.try_inline(compressor, scope, true, true);\n                if (body) this.body = body;\n                var obj = this.object;\n                if (obj instanceof AST_Sequence) {\n                    var inlined = inline_sequence(compressor, scope, true, in_loop, false, obj, 1);\n                    if (inlined) {\n                        this.object = obj.tail_node();\n                        inlined.body.push(this);\n                        return inlined;\n                    }\n                }\n                return body && this;\n            });\n            def(AST_If, function(compressor, scope, no_return, in_loop) {\n                var body = this.body.try_inline(compressor, scope, no_return, in_loop);\n                if (body) this.body = body;\n                var alt = this.alternative;\n                if (alt) {\n                    alt = alt.try_inline(compressor, scope, no_return, in_loop);\n                    if (alt) this.alternative = alt;\n                }\n                var cond = this.condition;\n                if (cond instanceof AST_Sequence) {\n                    var inlined = inline_sequence(compressor, scope, true, in_loop, false, cond, 1);\n                    if (inlined) {\n                        this.condition = cond.tail_node();\n                        inlined.body.push(this);\n                        return inlined;\n                    }\n                }\n                return (body || alt) && this;\n            });\n            def(AST_IterationStatement, function(compressor, scope, no_return, in_loop) {\n                var body = this.body.try_inline(compressor, scope, true, true);\n                if (!body) return;\n                this.body = body;\n                return this;\n            });\n            def(AST_LabeledStatement, function(compressor, scope, no_return, in_loop) {\n                var body = this.body.try_inline(compressor, scope, no_return, in_loop);\n                if (!body) return;\n                if (this.body instanceof AST_IterationStatement && body instanceof AST_BlockStatement) {\n                    var loop = body.body.pop();\n                    this.body = loop;\n                    body.body.push(this);\n                    return body;\n                }\n                this.body = body;\n                return this;\n            });\n            def(AST_New, noop);\n            def(AST_Return, function(compressor, scope, no_return, in_loop) {\n                var value = this.value;\n                return value && value.try_inline(compressor, scope, undefined, in_loop === \"try\");\n            });\n            function inline_sequence(compressor, scope, no_return, in_loop, in_await, node, skip) {\n                var body = [], exprs = node.expressions, no_ret = no_return;\n                for (var i = exprs.length - (skip || 0), j = i; --i >= 0; no_ret = true, in_await = false) {\n                    var inlined = exprs[i].try_inline(compressor, scope, no_ret, in_loop, in_await);\n                    if (!inlined) continue;\n                    flush();\n                    body.push(inlined);\n                }\n                if (body.length == 0) return;\n                flush();\n                if (!no_return && body[0] instanceof AST_SimpleStatement) {\n                    body[0] = make_node(AST_Return, node, { value: body[0].body });\n                }\n                return make_node(AST_BlockStatement, node, { body: body.reverse() });\n\n                function flush() {\n                    if (j > i + 1) body.push(make_node(AST_SimpleStatement, node, {\n                        body: make_sequence(node, exprs.slice(i + 1, j)),\n                    }));\n                    j = i;\n                }\n            }\n            def(AST_Sequence, function(compressor, scope, no_return, in_loop, in_await) {\n                return inline_sequence(compressor, scope, no_return, in_loop, in_await, this);\n            });\n            def(AST_SimpleStatement, function(compressor, scope, no_return, in_loop) {\n                var body = this.body;\n                while (body instanceof AST_UnaryPrefix) {\n                    var op = body.operator;\n                    if (unary_side_effects[op]) break;\n                    if (op == \"void\") break;\n                    body = body.expression;\n                }\n                if (!no_return && !is_undefined(body)) body = make_node(AST_UnaryPrefix, this, {\n                    operator: \"void\",\n                    expression: body,\n                });\n                return body.try_inline(compressor, scope, no_return || false, in_loop);\n            });\n            def(AST_UnaryPrefix, function(compressor, scope, no_return, in_loop, in_await) {\n                var self = this;\n                var op = self.operator;\n                if (unary_side_effects[op]) return;\n                if (!no_return && op == \"void\") no_return = false;\n                var inlined = self.expression.try_inline(compressor, scope, no_return, in_loop, in_await);\n                if (!inlined) return;\n                if (!no_return) scan_local_returns(inlined, function(node) {\n                    node.in_bool = false;\n                    var value = node.value;\n                    if (op == \"void\" && is_undefined(value)) return;\n                    node.value = make_node(AST_UnaryPrefix, self, {\n                        operator: op,\n                        expression: value || make_node(AST_Undefined, node).transform(compressor),\n                    });\n                });\n                return inlined;\n            });\n            def(AST_With, function(compressor, scope, no_return, in_loop) {\n                var body = this.body.try_inline(compressor, scope, no_return, in_loop);\n                if (body) this.body = body;\n                var exp = this.expression;\n                if (exp instanceof AST_Sequence) {\n                    var inlined = inline_sequence(compressor, scope, true, in_loop, false, exp, 1);\n                    if (inlined) {\n                        this.expression = exp.tail_node();\n                        inlined.body.push(this);\n                        return inlined;\n                    }\n                }\n                return body && this;\n            });\n            def(AST_Yield, function(compressor, scope, no_return, in_loop) {\n                if (!compressor.option(\"yields\")) return;\n                if (!this.nested) return;\n                var call = this.expression;\n                if (call.TYPE != \"Call\") return;\n                var fn = call.expression;\n                switch (fn.CTOR) {\n                  case AST_AsyncGeneratorFunction:\n                    fn = make_node(AST_AsyncFunction, fn);\n                    break;\n                  case AST_GeneratorFunction:\n                    fn = make_node(AST_Function, fn);\n                    break;\n                  default:\n                    return;\n                }\n                call = call.clone();\n                call.expression = fn;\n                return call.try_inline(compressor, scope, no_return, in_loop);\n            });\n        })(function(node, func) {\n            node.DEFMETHOD(\"try_inline\", func);\n        });\n\n        OPT(AST_Return, function(self, compressor) {\n            var value = self.value;\n            if (value && compressor.option(\"side_effects\")\n                && is_undefined(value, compressor)\n                && !in_async_generator(compressor.find_parent(AST_Scope))) {\n                self.value = null;\n            }\n            return self;\n        });\n    })(function(node, optimizer) {\n        node.DEFMETHOD(\"optimize\", function(compressor) {\n            var self = this;\n            if (self._optimized) return self;\n            if (compressor.has_directive(\"use asm\")) return self;\n            var opt = optimizer(self, compressor);\n            opt._optimized = true;\n            return opt;\n        });\n    });\n\n    return {\n        Compressor\n    }\n})"]}