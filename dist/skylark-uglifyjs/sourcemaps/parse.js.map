{"version":3,"sources":["parse.js"],"names":["define","m_utils","m_ast","characters","defaults","find_if","makePredicate","set_annotation","configure_error_stack","HOP","all","AST_Accessor","AST_Array","AST_Arrow","AST_Assign","AST_Await","AST_BigInt","AST_Binary","AST_BlockStatement","AST_Break","AST_Call","AST_Case","AST_Catch","AST_Chain","AST_ClassExpression","AST_ClassGetter","AST_ClassInit","AST_ClassMethod","AST_ClassPrivateProperty","AST_ClassProperty","AST_ClassStaticBlock","AST_ClassSetter","AST_ConciseMethod","AST_PrivateIn","AST_PrivateGetter","AST_PrivateMethod","AST_PrivateSetter","AST_Conditional","AST_Const","AST_Continue","AST_Debugger","AST_Default","AST_DefaultAssign","AST_DefaultValue","AST_DefClass","AST_Definitions","AST_Defun","AST_Destructured","AST_DestructuredArray","AST_DestructuredKeyVal","AST_DestructuredObject","AST_Destructuring","AST_Directive","AST_Do","AST_Dot","AST_DotHash","AST_EmptyStatement","AST_Expansion","AST_Export","AST_ExportDeclaration","AST_False","AST_Finally","AST_For","AST_ForIn","AST_ForOf","AST_Function","AST_Hole","AST_If","AST_Import","AST_ImportMeta","AST_IterationStatement","AST_Label","AST_LabeledStatement","AST_LabelRef","AST_Let","AST_NameMapping","AST_New","AST_NewTarget","AST_Node","AST_Null","AST_Number","AST_Object","AST_ObjectGetter","AST_ObjectKeyVal","AST_ObjectMethod","AST_ObjectProperty","AST_ObjectSetter","AST_PrefixedTemplateString","AST_PropAccess","AST_RegExp","AST_Return","AST_Sequence","AST_SimpleStatement","AST_Spread","AST_String","AST_Sub","AST_Super","AST_Switch","AST_SymbolCatch","AST_SymbolClass","AST_SymbolClassProperty","AST_SymbolConst","AST_SymbolDeclaration","AST_SymbolDefClass","AST_SymbolDefun","AST_SymbolExport","AST_SymbolExportForeign","AST_SymbolFunarg","AST_SymbolImport","AST_SymbolImportForeign","AST_SymbolLambda","AST_SymbolLet","AST_SymbolMethod","AST_SymbolRef","AST_SymbolVar","AST_Template","AST_TemplateSegment","AST_TemplateString","AST_This","AST_SymbolPrivateProperty","AST_Throw","AST_Token","AST_Toplevel","AST_True","AST_Try","AST_TryBlock","AST_UnaryPostfix","AST_UnaryPrefix","AST_Var","AST_VarDef","AST_While","AST_With","AST_Yield","_INLINE","_NOINLINE","_PURE","_KEY","_MANGLEPROP","KEYWORDS","KEYWORDS_ATOM","RESERVED_WORDS","join","KEYWORDS_BEFORE_EXPRESSION","RE_BIN_NUMBER","RE_HEX_NUMBER","RE_OCT_NUMBER","OPERATORS","NEWLINE_CHARS","OPERATOR_CHARS","PUNC_AFTER_EXPRESSION","PUNC_SEPARATORS","PUNC_BEFORE_EXPRESSION","PUNC_OPENERS","PUNC_CHARS","WHITESPACE_CHARS","NON_IDENTIFIER_CHARS","is_digit","code","is_identifier_char","ch","is_identifier_string","str","test","JS_Parse_Error","message","filename","line","col","pos","this","js_error","is_token","token","type","val","value","prototype","Object","create","Error","constructor","name","EX_EOF","tokenizer","$TEXT","html5_comments","shebang","S","text","tokpos","tokline","tokcol","newline_before","regex_allowed","comments_before","directives","read_template","with_eof_error","strings","s","read","push","peek","next","prev_was_dot","charAt","signal_eof","in_string","forward","i","looking_at","substr","length","start_token","is_comment","UNARY_POSTFIX","ret","endline","endcol","endpos","nlb","file","raw","substring","comments_after","skip_whitespace","parse_error","err","is_octal","num","read_num","prefix","has_e","after_e","has_x","has_dot","pred","read_while","next_token","has_directive","replace","valid","match","exec","parseInt","parseFloat","parse_js_number","isNaN","toLowerCase","read_escaped_char","seq","p","String","fromCharCode","read_octal_escape_sequence","slice","decode_escape_sequence","read_string","quote_char","quote","tok","skip_line_comment","find_eol","skip_multiline_comment","what","indexOf","find","read_name","backslash","escaped","charCodeAt","hex","toString","toUpperCase","read_regexp","source","prev_backslash","in_class","mods","regexp","RegExp","raw_source","e","read_operator","grow","op","bigger","handle_slash","eof_error","cont","x","ex","force_regexp","word","context","nc","add_directive","directive","push_directives_stack","pop_directives_stack","getPrototypeOf","UNARY_PREFIX","ASSIGNMENT","PRECEDENCE","a","b","j","ATOMIC_START_TOKEN","parse","options","bare_returns","expression","module","strict","toplevel","input","in_async","in_directives","in_funarg","in_function","in_generator","in_loop","labels","peeked","prev","is","croak","msg","ctx","token_error","token_to_string","undefined","unexpected","expect_token","expect","punc","has_newline_before","comment","can_insert_semicolon","semicolon","optional","parenthesized","exp","embed_tokens","parser","start","expr","apply","arguments","end","handle_regexp","statement","dir","body","simple_statement","function_","AST_AsyncGeneratorDefun","AST_AsyncDefun","key","alias","is_alias","AST_ExportForeign","aliases","make_string","keys","path","as_path","map","AST_ExportReferences","properties","index","sym","_make_symbol","maybe_named","AST_AsyncGeneratorFunction","AST_AsyncFunction","class_","AST_GeneratorDefun","AST_GeneratorFunction","export_default_decl","AST_ExportDefault","export_decl","export_","def","as_symbol","props","default","import_","is_vardefs","node","let_","label","l","stat","pop","references","forEach","ref","labeled_statement","block_","break_cont","const_","condition","await_token","init","ctor","var_","AST_ForAwaitOf","definitions","is_assignable","to_destructured","obj","object","for_enum","step","regular_for","for_","cond","alt","alternative","if_","switch_body_","bcatch","bfinally","maybe_destructured","argname","try_","ldef","thedef","TYPE","has_modifier","no_nlb","was_async","was_gen","parent","expr_atom","fixed","async","internal","as_property_key","gen_start","gen","static","private","AST_ClassInitBlock","func_start","func","maybe_assign","create_accessor","AST_ClassField","extends","to_funarg","rest","elements","left","right","prop","arrow","exprs","was_funarg","argnames","loop","is_strict","AST_AsyncArrow","each_argname","strict_verify_symbol","expr_list","maybe_default","branch","cur","default_branch","tmp","vardefs","no_in","allow_calls","call","args","subscripts","new_","template","len","unshift","comments_before_length","expressions","array_","object_","clazz","isFinite","AST_Infinity","operator","as_atom_node","closing","allow_trailing_comma","allow_empty","first","is_gen","no_error","key_start","tag","property","terminal","pure","comments","maybe_unary","nested","make_unary","expr_op","min_precision","precision","maybe_conditional","expr_ops","yes","consequent","maybe_arrow","concat","is_surrogate_pair_head","is_surrogate_pair_tail"],"mappings":";;;;;;;AAAAA,QACI,UACA,SACF,SAASC,EAAQC,GA6Cf,aAEA,MAAMC,WACFA,EAAUC,SACVA,EAAQC,QACRA,EAAOC,cACPA,EAAaC,eACbA,EAAcC,sBACdA,EAAqBC,IACrBA,EAAGC,IACHA,GACAT,GAEEU,aACFA,EAAYC,UACZA,EAASC,UACTA,EAASC,WACTA,EAAUC,UACVA,EAASC,WACTA,EAAUC,WACVA,EAAUC,mBACVA,EAAkBC,UAClBA,EAASC,SACTA,EAAQC,SACRA,EAAQC,UACRA,EAASC,UACTA,EAASC,oBACTA,EAAmBC,gBACnBA,EAAeC,cACfA,EAAaC,gBACbA,EAAeC,yBACfA,EAAwBC,kBACxBA,EAAiBC,qBACjBA,EAAoBC,gBACpBA,EAAeC,kBACfA,EAAiBC,cACjBA,EAAaC,kBACbA,EAAiBC,kBACjBA,EAAiBC,kBACjBA,EAAiBC,gBACjBA,EAAeC,UACfA,EAASC,aACTA,EAAYC,aACZA,EAAYC,YACZA,EAAWC,kBACXA,EAAiBC,iBACjBA,EAAgBC,aAChBA,EAAYC,gBACZA,EAAeC,UACfA,EAASC,iBACTA,EAAgBC,sBAChBA,EAAqBC,uBACrBA,EAAsBC,uBACtBA,EAAsBC,kBACtBA,EAAiBC,cACjBA,EAAaC,OACbA,EAAMC,QACNA,EAAOC,YACPA,GAAWC,mBACXA,GAAkBC,cAClBA,GAAaC,WACbA,GAAUC,sBACVA,GAAqBC,UACrBA,GAASC,YACTA,GAAWC,QACXA,GAAOC,UACPA,GAASC,UACTA,GAASC,aACTA,GAAYC,SACZA,GAAQC,OACRA,GAAMC,WACNA,GAAUC,eACVA,GAAcC,uBACdA,GAAsBC,UACtBA,GAASC,qBACTA,GAAoBC,aACpBA,GAAYC,QACZA,GAAOC,gBACPA,GAAeC,QACfA,GAAOC,cACPA,GAAaC,SACbA,GAAQC,SACRA,GAAQC,WACRA,GAAUC,WACVA,GAAUC,iBACVA,GAAgBC,iBAChBA,GAAgBC,iBAChBA,GAAgBC,mBAChBA,GAAkBC,iBAClBA,GAAgBC,2BAChBA,GAA0BC,eAC1BA,GAAcC,WACdA,GAAUC,WACVA,GAAUC,aACVA,GAAYC,oBACZA,GAAmBC,WACnBA,GAAUC,WACVA,GAAUC,QACVA,GAAOC,UACPA,GAASC,WACTA,GAAUC,gBACVA,GAAeC,gBACfA,GAAeC,wBACfA,GAAuBC,gBACvBA,GAAeC,sBACfA,GAAqBC,mBACrBA,GAAkBC,gBAClBA,GAAeC,iBACfA,GAAgBC,wBAChBA,GAAuBC,iBACvBA,GAAgBC,iBAChBA,GAAgBC,wBAChBA,GAAuBC,iBACvBA,GAAgBC,cAChBA,GAAaC,iBACbA,GAAgBC,cAChBA,GAAaC,cACbA,GAAaC,aACbA,GAAYC,oBACZA,GAAmBC,mBACnBA,GAAkBC,SAClBA,GAAQC,0BACRA,GAAyBC,UACzBA,GAASC,UACTA,GAASC,aACTA,GAAYC,SACZA,GAAQC,QACRA,GAAOC,aACPA,GAAYC,iBACZA,GAAgBC,gBAChBA,GAAeC,QACfA,GAAOC,WACPA,GAAUC,UACVA,GAASC,SACTA,GAAQC,UACRA,GAASC,QACTA,GAAOC,UACPA,GAASC,MACTA,GAAKC,KACLA,GAAIC,YACJA,IACAvI,EAEJ,IAAIwI,GAAW,6KACXC,GAAgB,kBAChBC,IACA,mOACAD,GACAD,IACFG,KAAK,KACHC,GAA6B,oCAEjCJ,GAAWpI,EAAcoI,IACzBE,GAAiBtI,EAAcsI,IAC/BE,GAA6BxI,EAAcwI,IAC3CH,GAAgBrI,EAAcqI,IAE9B,IAAII,GAAgB,eAChBC,GAAgB,mBAChBC,GAAgB,iBAEhBC,GAAY5I,GACZ,KACA,aACA,SACA,MACA,OACA,SACA,KACA,KACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KACA,KACA,KACA,MACA,IACA,IACA,KACA,KACA,KACA,MACA,KACA,MACA,IACA,IACA,KACA,KACA,KACA,KACA,KACA,MACA,MACA,MACA,OACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,MACA,QAGA6I,GAAgB,mBAChBC,GAAiB,gBAIjBC,GAAwBC,SACxBC,GAAyBC,SACzBC,GAAaF,GAAyB,OACtCG,GAAmBP,GAAgB,gCACnCQ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","file":"../parse.js","sourcesContent":["define([\n    \"./utils\",\n    \"./ast\"\n],function(m_utils,m_ast){\n    /***********************************************************************\n\n      A JavaScript tokenizer / parser / beautifier / compressor.\n      https://github.com/mishoo/UglifyJS\n\n      -------------------------------- (C) ---------------------------------\n\n                               Author: Mihai Bazon\n                             <mihai.bazon@gmail.com>\n                           http://mihai.bazon.net/blog\n\n      Distributed under the BSD license:\n\n        Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n        Parser based on parse-js (http://marijn.haverbeke.nl/parse-js/).\n\n        Redistribution and use in source and binary forms, with or without\n        modification, are permitted provided that the following conditions\n        are met:\n\n            * Redistributions of source code must retain the above\n              copyright notice, this list of conditions and the following\n              disclaimer.\n\n            * Redistributions in binary form must reproduce the above\n              copyright notice, this list of conditions and the following\n              disclaimer in the documentation and/or other materials\n              provided with the distribution.\n\n        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n        EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n        IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n        PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n        LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n        OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n        PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n        PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n        THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n        TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n        THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n        SUCH DAMAGE.\n\n     ***********************************************************************/\n\n    \"use strict\";\n\n    const {\n        characters,\n        defaults,\n        find_if,\n        makePredicate,\n        set_annotation,\n        configure_error_stack,\n        HOP,\n        all\n    } = m_utils;\n\n    const {\n        AST_Accessor,\n        AST_Array,\n        AST_Arrow,\n        AST_Assign,\n        AST_Await,\n        AST_BigInt,\n        AST_Binary,\n        AST_BlockStatement,\n        AST_Break,\n        AST_Call,\n        AST_Case,\n        AST_Catch,\n        AST_Chain,\n        AST_ClassExpression,\n        AST_ClassGetter,\n        AST_ClassInit,\n        AST_ClassMethod,\n        AST_ClassPrivateProperty,\n        AST_ClassProperty,\n        AST_ClassStaticBlock,\n        AST_ClassSetter,\n        AST_ConciseMethod,\n        AST_PrivateIn,\n        AST_PrivateGetter,\n        AST_PrivateMethod,\n        AST_PrivateSetter,\n        AST_Conditional,\n        AST_Const,\n        AST_Continue,\n        AST_Debugger,\n        AST_Default,\n        AST_DefaultAssign,\n        AST_DefaultValue,\n        AST_DefClass,\n        AST_Definitions,\n        AST_Defun,\n        AST_Destructured,\n        AST_DestructuredArray,\n        AST_DestructuredKeyVal,\n        AST_DestructuredObject,\n        AST_Destructuring,\n        AST_Directive,\n        AST_Do,\n        AST_Dot,\n        AST_DotHash,\n        AST_EmptyStatement,\n        AST_Expansion,\n        AST_Export,\n        AST_ExportDeclaration,\n        AST_False,\n        AST_Finally,\n        AST_For,\n        AST_ForIn,\n        AST_ForOf,\n        AST_Function,\n        AST_Hole,\n        AST_If,\n        AST_Import,\n        AST_ImportMeta,\n        AST_IterationStatement,\n        AST_Label,\n        AST_LabeledStatement,\n        AST_LabelRef,\n        AST_Let,\n        AST_NameMapping,\n        AST_New,\n        AST_NewTarget,\n        AST_Node,\n        AST_Null,\n        AST_Number,\n        AST_Object,\n        AST_ObjectGetter,\n        AST_ObjectKeyVal,\n        AST_ObjectMethod,\n        AST_ObjectProperty,\n        AST_ObjectSetter,\n        AST_PrefixedTemplateString,\n        AST_PropAccess,\n        AST_RegExp,\n        AST_Return,\n        AST_Sequence,\n        AST_SimpleStatement,\n        AST_Spread,\n        AST_String,\n        AST_Sub,\n        AST_Super,\n        AST_Switch,\n        AST_SymbolCatch,\n        AST_SymbolClass,\n        AST_SymbolClassProperty,\n        AST_SymbolConst,\n        AST_SymbolDeclaration,\n        AST_SymbolDefClass,\n        AST_SymbolDefun,\n        AST_SymbolExport,\n        AST_SymbolExportForeign,\n        AST_SymbolFunarg,\n        AST_SymbolImport,\n        AST_SymbolImportForeign,\n        AST_SymbolLambda,\n        AST_SymbolLet,\n        AST_SymbolMethod,\n        AST_SymbolRef,\n        AST_SymbolVar,\n        AST_Template,\n        AST_TemplateSegment,\n        AST_TemplateString,\n        AST_This,\n        AST_SymbolPrivateProperty,\n        AST_Throw,\n        AST_Token,\n        AST_Toplevel,\n        AST_True,\n        AST_Try,\n        AST_TryBlock,\n        AST_UnaryPostfix,\n        AST_UnaryPrefix,\n        AST_Var,\n        AST_VarDef,\n        AST_While,\n        AST_With,\n        AST_Yield,\n        _INLINE,\n        _NOINLINE,\n        _PURE,\n        _KEY,\n        _MANGLEPROP,\n    } = m_ast;\n\n    var KEYWORDS = \"break case catch class const continue debugger default delete do else extends finally for function if in instanceof new return switch throw try typeof var void while with\";\n    var KEYWORDS_ATOM = \"false null true\";\n    var RESERVED_WORDS = [\n        \"abstract async await boolean byte char double enum export final float goto implements import int interface let long native package private protected public short static super synchronized this throws transient volatile yield\",\n        KEYWORDS_ATOM,\n        KEYWORDS,\n    ].join(\" \");\n    var KEYWORDS_BEFORE_EXPRESSION = \"return new delete throw else case\";\n\n    KEYWORDS = makePredicate(KEYWORDS);\n    RESERVED_WORDS = makePredicate(RESERVED_WORDS);\n    KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);\n    KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);\n\n    var RE_BIN_NUMBER = /^0b([01]+)$/i;\n    var RE_HEX_NUMBER = /^0x([0-9a-f]+)$/i;\n    var RE_OCT_NUMBER = /^0o?([0-7]+)$/i;\n\n    var OPERATORS = makePredicate([\n        \"in\",\n        \"instanceof\",\n        \"typeof\",\n        \"new\",\n        \"void\",\n        \"delete\",\n        \"++\",\n        \"--\",\n        \"+\",\n        \"-\",\n        \"!\",\n        \"~\",\n        \"&\",\n        \"|\",\n        \"^\",\n        \"*\",\n        \"/\",\n        \"%\",\n        \"**\",\n        \">>\",\n        \"<<\",\n        \">>>\",\n        \"<\",\n        \">\",\n        \"<=\",\n        \">=\",\n        \"==\",\n        \"===\",\n        \"!=\",\n        \"!==\",\n        \"?\",\n        \"=\",\n        \"+=\",\n        \"-=\",\n        \"/=\",\n        \"*=\",\n        \"%=\",\n        \"**=\",\n        \">>=\",\n        \"<<=\",\n        \">>>=\",\n        \"&=\",\n        \"|=\",\n        \"^=\",\n        \"&&\",\n        \"||\",\n        \"??\",\n        \"&&=\",\n        \"||=\",\n        \"??=\",\n    ]);\n\n    var NEWLINE_CHARS = \"\\n\\r\\u2028\\u2029\";\n    var OPERATOR_CHARS = \"+-*&%=<>!?|~^\";\n    var PUNC_OPENERS = \"[{(\";\n    var PUNC_SEPARATORS = \",;:\";\n    var PUNC_CLOSERS = \")}]\";\n    var PUNC_AFTER_EXPRESSION = PUNC_SEPARATORS + PUNC_CLOSERS;\n    var PUNC_BEFORE_EXPRESSION = PUNC_OPENERS + PUNC_SEPARATORS;\n    var PUNC_CHARS = PUNC_BEFORE_EXPRESSION + \"`\" + PUNC_CLOSERS;\n    var WHITESPACE_CHARS = NEWLINE_CHARS + \" \\u00a0\\t\\f\\u000b\\u200b\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\uFEFF\";\n    var NON_IDENTIFIER_CHARS = makePredicate(characters(\"./'\\\"#\" + OPERATOR_CHARS + PUNC_CHARS + WHITESPACE_CHARS));\n\n    NEWLINE_CHARS = makePredicate(characters(NEWLINE_CHARS));\n    OPERATOR_CHARS = makePredicate(characters(OPERATOR_CHARS));\n    PUNC_AFTER_EXPRESSION = makePredicate(characters(PUNC_AFTER_EXPRESSION));\n    PUNC_BEFORE_EXPRESSION = makePredicate(characters(PUNC_BEFORE_EXPRESSION));\n    PUNC_CHARS = makePredicate(characters(PUNC_CHARS));\n    WHITESPACE_CHARS = makePredicate(characters(WHITESPACE_CHARS));\n\n    /* -----[ Tokenizer ]----- */\n\n    function is_surrogate_pair_head(code) {\n        return code >= 0xd800 && code <= 0xdbff;\n    }\n\n    function is_surrogate_pair_tail(code) {\n        return code >= 0xdc00 && code <= 0xdfff;\n    }\n\n    function is_digit(code) {\n        return code >= 48 && code <= 57;\n    }\n\n    function is_identifier_char(ch) {\n        return !NON_IDENTIFIER_CHARS[ch];\n    }\n\n    function is_identifier_string(str) {\n        return /^[a-z_$][a-z0-9_$]*$/i.test(str);\n    }\n\n    function decode_escape_sequence(seq) {\n        switch (seq[0]) {\n          case \"b\": return \"\\b\";\n          case \"f\": return \"\\f\";\n          case \"n\": return \"\\n\";\n          case \"r\": return \"\\r\";\n          case \"t\": return \"\\t\";\n          case \"u\":\n            var code;\n            if (seq[1] == \"{\" && seq.slice(-1) == \"}\") {\n                code = seq.slice(2, -1);\n            } else if (seq.length == 5) {\n                code = seq.slice(1);\n            } else {\n                return;\n            }\n            var num = parseInt(code, 16);\n            if (num < 0 || isNaN(num)) return;\n            if (num < 0x10000) return String.fromCharCode(num);\n            if (num > 0x10ffff) return;\n            return String.fromCharCode((num >> 10) + 0xd7c0) + String.fromCharCode((num & 0x03ff) + 0xdc00);\n          case \"v\": return \"\\u000b\";\n          case \"x\":\n            if (seq.length != 3) return;\n            var num = parseInt(seq.slice(1), 16);\n            if (num < 0 || isNaN(num)) return;\n            return String.fromCharCode(num);\n          case \"\\r\":\n          case \"\\n\":\n            return \"\";\n          default:\n            if (seq == \"0\") return \"\\0\";\n            if (seq[0] >= \"0\" && seq[0] <= \"9\") return;\n            return seq;\n        }\n    }\n\n    function parse_js_number(num) {\n        var match;\n        if (match = RE_BIN_NUMBER.exec(num)) return parseInt(match[1], 2);\n        if (match = RE_HEX_NUMBER.exec(num)) return parseInt(match[1], 16);\n        if (match = RE_OCT_NUMBER.exec(num)) return parseInt(match[1], 8);\n        var val = parseFloat(num);\n        if (val == num) return val;\n    }\n\n    function JS_Parse_Error(message, filename, line, col, pos) {\n        this.message = message;\n        this.filename = filename;\n        this.line = line;\n        this.col = col;\n        this.pos = pos;\n    }\n    JS_Parse_Error.prototype = Object.create(Error.prototype);\n    JS_Parse_Error.prototype.constructor = JS_Parse_Error;\n    JS_Parse_Error.prototype.name = \"SyntaxError\";\n    configure_error_stack(JS_Parse_Error);\n\n    function js_error(message, filename, line, col, pos) {\n        throw new JS_Parse_Error(message, filename, line, col, pos);\n    }\n\n    function is_token(token, type, val) {\n        return token.type == type && (val == null || token.value == val);\n    }\n\n    var EX_EOF = {};\n\n    function tokenizer($TEXT, filename, html5_comments, shebang) {\n\n        var S = {\n            text            : $TEXT,\n            filename        : filename,\n            pos             : 0,\n            tokpos          : 0,\n            line            : 1,\n            tokline         : 0,\n            col             : 0,\n            tokcol          : 0,\n            newline_before  : false,\n            regex_allowed   : false,\n            comments_before : [],\n            directives      : Object.create(null),\n            read_template   : with_eof_error(\"Unterminated template literal\", function(strings) {\n                var s = \"\";\n                for (;;) {\n                    var ch = read();\n                    switch (ch) {\n                      case \"\\\\\":\n                        ch += read();\n                        break;\n                      case \"`\":\n                        strings.push(s);\n                        return;\n                      case \"$\":\n                        if (peek() == \"{\") {\n                            next();\n                            strings.push(s);\n                            S.regex_allowed = true;\n                            return true;\n                        }\n                    }\n                    s += ch;\n                }\n\n                function read() {\n                    var ch = next(true, true);\n                    return ch == \"\\r\" ? \"\\n\" : ch;\n                }\n            }),\n        };\n        var prev_was_dot = false;\n\n        function peek() {\n            return S.text.charAt(S.pos);\n        }\n\n        function next(signal_eof, in_string) {\n            var ch = S.text.charAt(S.pos++);\n            if (signal_eof && !ch)\n                throw EX_EOF;\n            if (NEWLINE_CHARS[ch]) {\n                S.col = 0;\n                S.line++;\n                if (!in_string) S.newline_before = true;\n                if (ch == \"\\r\" && peek() == \"\\n\") {\n                    // treat `\\r\\n` as `\\n`\n                    S.pos++;\n                    ch = \"\\n\";\n                }\n            } else {\n                S.col++;\n            }\n            return ch;\n        }\n\n        function forward(i) {\n            while (i-- > 0) next();\n        }\n\n        function looking_at(str) {\n            return S.text.substr(S.pos, str.length) == str;\n        }\n\n        function find_eol() {\n            var text = S.text;\n            for (var i = S.pos; i < S.text.length; ++i) {\n                if (NEWLINE_CHARS[text[i]]) return i;\n            }\n            return -1;\n        }\n\n        function find(what, signal_eof) {\n            var pos = S.text.indexOf(what, S.pos);\n            if (signal_eof && pos == -1) throw EX_EOF;\n            return pos;\n        }\n\n        function start_token() {\n            S.tokline = S.line;\n            S.tokcol = S.col;\n            S.tokpos = S.pos;\n        }\n\n        function token(type, value, is_comment) {\n            S.regex_allowed = type == \"operator\" && !UNARY_POSTFIX[value]\n                || type == \"keyword\" && KEYWORDS_BEFORE_EXPRESSION[value]\n                || type == \"punc\" && PUNC_BEFORE_EXPRESSION[value];\n            if (type == \"punc\" && value == \".\") prev_was_dot = true;\n            else if (!is_comment) prev_was_dot = false;\n            var ret = {\n                type    : type,\n                value   : value,\n                line    : S.tokline,\n                col     : S.tokcol,\n                pos     : S.tokpos,\n                endline : S.line,\n                endcol  : S.col,\n                endpos  : S.pos,\n                nlb     : S.newline_before,\n                file    : filename\n            };\n            if (/^(?:num|string|regexp)$/i.test(type)) {\n                ret.raw = $TEXT.substring(ret.pos, ret.endpos);\n            }\n            if (!is_comment) {\n                ret.comments_before = S.comments_before;\n                ret.comments_after = S.comments_before = [];\n            }\n            S.newline_before = false;\n            return new AST_Token(ret);\n        }\n\n        function skip_whitespace() {\n            while (WHITESPACE_CHARS[peek()])\n                next();\n        }\n\n        function read_while(pred) {\n            var ret = \"\", ch;\n            while ((ch = peek()) && pred(ch, ret)) ret += next();\n            return ret;\n        }\n\n        function parse_error(err) {\n            js_error(err, filename, S.tokline, S.tokcol, S.tokpos);\n        }\n\n        function is_octal(num) {\n            return /^0[0-7_]+$/.test(num);\n        }\n\n        function read_num(prefix) {\n            var has_e = false, after_e = false, has_x = false, has_dot = prefix == \".\";\n            var num = read_while(function(ch, str) {\n                switch (ch) {\n                  case \"x\": case \"X\":\n                    return has_x ? false : (has_x = true);\n                  case \"e\": case \"E\":\n                    return has_x ? true : has_e ? false : (has_e = after_e = true);\n                  case \"+\": case \"-\":\n                    return after_e;\n                  case (after_e = false, \".\"):\n                    return has_dot || has_e || has_x || is_octal(str) ? false : (has_dot = true);\n                }\n                return /[_0-9a-dfo]/i.test(ch);\n            });\n            if (prefix) num = prefix + num;\n            if (is_octal(num)) {\n                if (next_token.has_directive(\"use strict\")) parse_error(\"Legacy octal literals are not allowed in strict mode\");\n            } else {\n                num = num.replace(has_x ? /([1-9a-f]|.0)_(?=[0-9a-f])/gi : /([1-9]|.0)_(?=[0-9])/gi, \"$1\");\n            }\n            var valid = parse_js_number(num);\n            if (isNaN(valid)) parse_error(\"Invalid syntax: \" + num);\n            if (has_dot || has_e || peek() != \"n\") return token(\"num\", valid);\n            return token(\"bigint\", num.toLowerCase() + next());\n        }\n\n        function read_escaped_char(in_string) {\n            var seq = next(true, in_string);\n            if (seq >= \"0\" && seq <= \"7\") return read_octal_escape_sequence(seq);\n            if (seq == \"u\") {\n                var ch = next(true, in_string);\n                seq += ch;\n                if (ch != \"{\") {\n                    seq += next(true, in_string) + next(true, in_string) + next(true, in_string);\n                } else do {\n                    ch = next(true, in_string);\n                    seq += ch;\n                } while (ch != \"}\");\n            } else if (seq == \"x\") {\n                seq += next(true, in_string) + next(true, in_string);\n            }\n            var str = decode_escape_sequence(seq);\n            if (typeof str != \"string\") parse_error(\"Invalid escape sequence: \\\\\" + seq);\n            return str;\n        }\n\n        function read_octal_escape_sequence(ch) {\n            // Read\n            var p = peek();\n            if (p >= \"0\" && p <= \"7\") {\n                ch += next(true);\n                if (ch[0] <= \"3\" && (p = peek()) >= \"0\" && p <= \"7\")\n                    ch += next(true);\n            }\n\n            // Parse\n            if (ch === \"0\") return \"\\0\";\n            if (ch.length > 0 && next_token.has_directive(\"use strict\"))\n                parse_error(\"Legacy octal escape sequences are not allowed in strict mode\");\n            return String.fromCharCode(parseInt(ch, 8));\n        }\n\n        var read_string = with_eof_error(\"Unterminated string constant\", function(quote_char) {\n            var quote = next(), ret = \"\";\n            for (;;) {\n                var ch = next(true, true);\n                if (ch == \"\\\\\") ch = read_escaped_char(true);\n                else if (NEWLINE_CHARS[ch]) parse_error(\"Unterminated string constant\");\n                else if (ch == quote) break;\n                ret += ch;\n            }\n            var tok = token(\"string\", ret);\n            tok.quote = quote_char;\n            return tok;\n        });\n\n        function skip_line_comment(type) {\n            var regex_allowed = S.regex_allowed;\n            var i = find_eol(), ret;\n            if (i == -1) {\n                ret = S.text.substr(S.pos);\n                S.pos = S.text.length;\n            } else {\n                ret = S.text.substring(S.pos, i);\n                S.pos = i;\n            }\n            S.col = S.tokcol + (S.pos - S.tokpos);\n            S.comments_before.push(token(type, ret, true));\n            S.regex_allowed = regex_allowed;\n            return next_token;\n        }\n\n        var skip_multiline_comment = with_eof_error(\"Unterminated multiline comment\", function() {\n            var regex_allowed = S.regex_allowed;\n            var i = find(\"*/\", true);\n            var text = S.text.substring(S.pos, i).replace(/\\r\\n|\\r|\\u2028|\\u2029/g, \"\\n\");\n            // update stream position\n            forward(text.length /* doesn't count \\r\\n as 2 char while S.pos - i does */ + 2);\n            S.comments_before.push(token(\"comment2\", text, true));\n            S.regex_allowed = regex_allowed;\n            return next_token;\n        });\n\n        function read_name() {\n            var backslash = false, ch, escaped = false, name = peek() == \"#\" ? next() : \"\";\n            while (ch = peek()) {\n                if (!backslash) {\n                    if (ch == \"\\\\\") escaped = backslash = true, next();\n                    else if (is_identifier_char(ch)) name += next();\n                    else break;\n                } else {\n                    if (ch != \"u\") parse_error(\"Expecting UnicodeEscapeSequence -- uXXXX\");\n                    ch = read_escaped_char();\n                    if (!is_identifier_char(ch)) parse_error(\"Unicode char: \" + ch.charCodeAt(0) + \" is not valid in identifier\");\n                    name += ch;\n                    backslash = false;\n                }\n            }\n            if (KEYWORDS[name] && escaped) {\n                var hex = name.charCodeAt(0).toString(16).toUpperCase();\n                name = \"\\\\u\" + \"0000\".substr(hex.length) + hex + name.slice(1);\n            }\n            return name;\n        }\n\n        var read_regexp = with_eof_error(\"Unterminated regular expression\", function(source) {\n            var prev_backslash = false, ch, in_class = false;\n            while ((ch = next(true))) if (NEWLINE_CHARS[ch]) {\n                parse_error(\"Unexpected line terminator\");\n            } else if (prev_backslash) {\n                source += \"\\\\\" + ch;\n                prev_backslash = false;\n            } else if (ch == \"[\") {\n                in_class = true;\n                source += ch;\n            } else if (ch == \"]\" && in_class) {\n                in_class = false;\n                source += ch;\n            } else if (ch == \"/\" && !in_class) {\n                break;\n            } else if (ch == \"\\\\\") {\n                prev_backslash = true;\n            } else {\n                source += ch;\n            }\n            var mods = read_name();\n            try {\n                var regexp = new RegExp(source, mods);\n                regexp.raw_source = source;\n                return token(\"regexp\", regexp);\n            } catch (e) {\n                parse_error(e.message);\n            }\n        });\n\n        function read_operator(prefix) {\n            function grow(op) {\n                if (!peek()) return op;\n                var bigger = op + peek();\n                if (OPERATORS[bigger]) {\n                    next();\n                    return grow(bigger);\n                } else {\n                    return op;\n                }\n            }\n            return token(\"operator\", grow(prefix || next()));\n        }\n\n        function handle_slash() {\n            next();\n            switch (peek()) {\n              case \"/\":\n                next();\n                return skip_line_comment(\"comment1\");\n              case \"*\":\n                next();\n                return skip_multiline_comment();\n            }\n            return S.regex_allowed ? read_regexp(\"\") : read_operator(\"/\");\n        }\n\n        function handle_dot() {\n            next();\n            if (looking_at(\"..\")) return token(\"operator\", \".\" + next() + next());\n            return is_digit(peek().charCodeAt(0)) ? read_num(\".\") : token(\"punc\", \".\");\n        }\n\n        function read_word() {\n            var word = read_name();\n            if (prev_was_dot) return token(\"name\", word);\n            return KEYWORDS_ATOM[word] ? token(\"atom\", word)\n                : !KEYWORDS[word] ? token(\"name\", word)\n                : OPERATORS[word] ? token(\"operator\", word)\n                : token(\"keyword\", word);\n        }\n\n        function with_eof_error(eof_error, cont) {\n            return function(x) {\n                try {\n                    return cont(x);\n                } catch (ex) {\n                    if (ex === EX_EOF) parse_error(eof_error);\n                    else throw ex;\n                }\n            };\n        }\n\n        function next_token(force_regexp) {\n            if (force_regexp != null)\n                return read_regexp(force_regexp);\n            if (shebang && S.pos == 0 && looking_at(\"#!\")) {\n                start_token();\n                forward(2);\n                skip_line_comment(\"comment5\");\n            }\n            for (;;) {\n                skip_whitespace();\n                start_token();\n                if (html5_comments) {\n                    if (looking_at(\"<!--\")) {\n                        forward(4);\n                        skip_line_comment(\"comment3\");\n                        continue;\n                    }\n                    if (looking_at(\"-->\") && S.newline_before) {\n                        forward(3);\n                        skip_line_comment(\"comment4\");\n                        continue;\n                    }\n                }\n                var ch = peek();\n                if (!ch) return token(\"eof\");\n                var code = ch.charCodeAt(0);\n                switch (code) {\n                  case 34: case 39: return read_string(ch);\n                  case 46: return handle_dot();\n                  case 47:\n                    var tok = handle_slash();\n                    if (tok === next_token) continue;\n                    return tok;\n                }\n                if (is_digit(code)) return read_num();\n                if (PUNC_CHARS[ch]) return token(\"punc\", next());\n                if (looking_at(\"=>\")) return token(\"punc\", next() + next());\n                if (OPERATOR_CHARS[ch]) return read_operator();\n                if (code == 35 || code == 92 || !NON_IDENTIFIER_CHARS[ch]) return read_word();\n                break;\n            }\n            parse_error(\"Unexpected character '\" + ch + \"'\");\n        }\n\n        next_token.context = function(nc) {\n            if (nc) S = nc;\n            return S;\n        };\n\n        next_token.add_directive = function(directive) {\n            S.directives[directive] = true;\n        }\n\n        next_token.push_directives_stack = function() {\n            S.directives = Object.create(S.directives);\n        }\n\n        next_token.pop_directives_stack = function() {\n            S.directives = Object.getPrototypeOf(S.directives);\n        }\n\n        next_token.has_directive = function(directive) {\n            return !!S.directives[directive];\n        }\n\n        return next_token;\n    }\n\n    /* -----[ Parser (constants) ]----- */\n\n    var UNARY_PREFIX = makePredicate(\"typeof void delete -- ++ ! ~ - +\");\n\n    var UNARY_POSTFIX = makePredicate(\"-- ++\");\n\n    var ASSIGNMENT = makePredicate(\"= += -= /= *= %= **= >>= <<= >>>= &= |= ^= &&= ||= ??=\");\n\n    var PRECEDENCE = function(a, ret) {\n        for (var i = 0; i < a.length;) {\n            var b = a[i++];\n            for (var j = 0; j < b.length; j++) {\n                ret[b[j]] = i;\n            }\n        }\n        return ret;\n    }([\n        [\"??\"],\n        [\"||\"],\n        [\"&&\"],\n        [\"|\"],\n        [\"^\"],\n        [\"&\"],\n        [\"==\", \"===\", \"!=\", \"!==\"],\n        [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n        [\">>\", \"<<\", \">>>\"],\n        [\"+\", \"-\"],\n        [\"*\", \"/\", \"%\"],\n        [\"**\"],\n    ], {});\n\n    var ATOMIC_START_TOKEN = makePredicate(\"atom bigint num regexp string\");\n\n    /* -----[ Parser ]----- */\n\n    function parse($TEXT, options) {\n        options = defaults(options, {\n            bare_returns   : false,\n            expression     : false,\n            filename       : null,\n            html5_comments : true,\n            module         : false,\n            shebang        : true,\n            strict         : false,\n            toplevel       : null,\n        }, true);\n\n        var S = {\n            input         : typeof $TEXT == \"string\"\n                            ? tokenizer($TEXT, options.filename, options.html5_comments, options.shebang)\n                            : $TEXT,\n            in_async      : false,\n            in_directives : true,\n            in_funarg     : -1,\n            in_function   : 0,\n            in_generator  : false,\n            in_loop       : 0,\n            labels        : [],\n            peeked        : null,\n            prev          : null,\n            token         : null,\n        };\n\n        S.token = next();\n\n        function is(type, value) {\n            return is_token(S.token, type, value);\n        }\n\n        function peek() {\n            return S.peeked || (S.peeked = S.input());\n        }\n\n        function next() {\n            S.prev = S.token;\n            if (S.peeked) {\n                S.token = S.peeked;\n                S.peeked = null;\n            } else {\n                S.token = S.input();\n            }\n            S.in_directives = S.in_directives && (\n                S.token.type == \"string\" || is(\"punc\", \";\")\n            );\n            return S.token;\n        }\n\n        function prev() {\n            return S.prev;\n        }\n\n        function croak(msg, line, col, pos) {\n            var ctx = S.input.context();\n            js_error(msg,\n                     ctx.filename,\n                     line != null ? line : ctx.tokline,\n                     col != null ? col : ctx.tokcol,\n                     pos != null ? pos : ctx.tokpos);\n        }\n\n        function token_error(token, msg) {\n            croak(msg, token.line, token.col);\n        }\n\n        function token_to_string(type, value) {\n            return type + (value === undefined ? \"\" : \" «\" + value + \"»\");\n        }\n\n        function unexpected(token) {\n            if (token == null) token = S.token;\n            token_error(token, \"Unexpected token: \" + token_to_string(token.type, token.value));\n        }\n\n        function expect_token(type, val) {\n            if (is(type, val)) return next();\n            token_error(S.token, \"Unexpected token: \" + token_to_string(S.token.type, S.token.value) + \", expected: \" + token_to_string(type, val));\n        }\n\n        function expect(punc) {\n            return expect_token(\"punc\", punc);\n        }\n\n        function has_newline_before(token) {\n            return token.nlb || !all(token.comments_before, function(comment) {\n                return !comment.nlb;\n            });\n        }\n\n        function can_insert_semicolon() {\n            return !options.strict\n                && (is(\"eof\") || is(\"punc\", \"}\") || has_newline_before(S.token));\n        }\n\n        function semicolon(optional) {\n            if (is(\"punc\", \";\")) next();\n            else if (!optional && !can_insert_semicolon()) expect(\";\");\n        }\n\n        function parenthesized() {\n            expect(\"(\");\n            var exp = expression();\n            expect(\")\");\n            return exp;\n        }\n\n        function embed_tokens(parser) {\n            return function() {\n                var start = S.token;\n                var expr = parser.apply(null, arguments);\n                var end = prev();\n                expr.start = start;\n                expr.end = end;\n                return expr;\n            };\n        }\n\n        function handle_regexp() {\n            if (is(\"operator\", \"/\") || is(\"operator\", \"/=\")) {\n                S.peeked = null;\n                S.token = S.input(S.token.value.substr(1)); // force regexp\n            }\n        }\n\n        var statement = embed_tokens(function(toplevel) {\n            handle_regexp();\n            switch (S.token.type) {\n              case \"string\":\n                var dir = S.in_directives;\n                var body = expression();\n                if (dir) {\n                    if (body instanceof AST_String) {\n                        var value = body.start.raw.slice(1, -1);\n                        S.input.add_directive(value);\n                        body.value = value;\n                    } else {\n                        S.in_directives = dir = false;\n                    }\n                }\n                semicolon();\n                return dir ? new AST_Directive(body) : new AST_SimpleStatement({ body: body });\n              case \"num\":\n              case \"bigint\":\n              case \"regexp\":\n              case \"operator\":\n              case \"atom\":\n                return simple_statement();\n\n              case \"name\":\n                switch (S.token.value) {\n                  case \"async\":\n                    if (is_token(peek(), \"keyword\", \"function\")) {\n                        next();\n                        next();\n                        if (!is(\"operator\", \"*\")) return function_(AST_AsyncDefun);\n                        next();\n                        return function_(AST_AsyncGeneratorDefun);\n                    }\n                    break;\n                  case \"await\":\n                    if (S.in_async) return simple_statement();\n                    break;\n                  case \"export\":\n                    if (!toplevel && options.module !== \"\") unexpected();\n                    next();\n                    return export_();\n                  case \"import\":\n                    var token = peek();\n                    if (token.type == \"punc\" && /^[(.]$/.test(token.value)) break;\n                    if (!toplevel && options.module !== \"\") unexpected();\n                    next();\n                    return import_();\n                  case \"let\":\n                    if (is_vardefs()) {\n                        next();\n                        var node = let_();\n                        semicolon();\n                        return node;\n                    }\n                    break;\n                  case \"yield\":\n                    if (S.in_generator) return simple_statement();\n                    break;\n                }\n                return is_token(peek(), \"punc\", \":\")\n                    ? labeled_statement()\n                    : simple_statement();\n\n              case \"punc\":\n                switch (S.token.value) {\n                  case \"{\":\n                    return new AST_BlockStatement({\n                        start : S.token,\n                        body  : block_(),\n                        end   : prev()\n                    });\n                  case \"[\":\n                  case \"(\":\n                  case \"`\":\n                    return simple_statement();\n                  case \";\":\n                    S.in_directives = false;\n                    next();\n                    return new AST_EmptyStatement();\n                  default:\n                    unexpected();\n                }\n\n              case \"keyword\":\n                switch (S.token.value) {\n                  case \"break\":\n                    next();\n                    return break_cont(AST_Break);\n\n                  case \"class\":\n                    next();\n                    return class_(AST_DefClass);\n\n                  case \"const\":\n                    next();\n                    var node = const_();\n                    semicolon();\n                    return node;\n\n                  case \"continue\":\n                    next();\n                    return break_cont(AST_Continue);\n\n                  case \"debugger\":\n                    next();\n                    semicolon();\n                    return new AST_Debugger();\n\n                  case \"do\":\n                    next();\n                    var body = in_loop(statement);\n                    expect_token(\"keyword\", \"while\");\n                    var condition = parenthesized();\n                    semicolon(true);\n                    return new AST_Do({\n                        body      : body,\n                        condition : condition,\n                    });\n\n                  case \"while\":\n                    next();\n                    return new AST_While({\n                        condition : parenthesized(),\n                        body      : in_loop(statement),\n                    });\n\n                  case \"for\":\n                    next();\n                    return for_();\n\n                  case \"function\":\n                    next();\n                    if (!is(\"operator\", \"*\")) return function_(AST_Defun);\n                    next();\n                    return function_(AST_GeneratorDefun);\n\n                  case \"if\":\n                    next();\n                    return if_();\n\n                  case \"return\":\n                    if (S.in_function == 0 && !options.bare_returns)\n                        croak(\"'return' outside of function\");\n                    next();\n                    var value = null;\n                    if (is(\"punc\", \";\")) {\n                        next();\n                    } else if (!can_insert_semicolon()) {\n                        value = expression();\n                        semicolon();\n                    }\n                    return new AST_Return({ value: value });\n\n                  case \"switch\":\n                    next();\n                    return new AST_Switch({\n                        expression : parenthesized(),\n                        body       : in_loop(switch_body_),\n                    });\n\n                  case \"throw\":\n                    next();\n                    if (has_newline_before(S.token))\n                        croak(\"Illegal newline after 'throw'\");\n                    var value = expression();\n                    semicolon();\n                    return new AST_Throw({ value: value });\n\n                  case \"try\":\n                    next();\n                    return try_();\n\n                  case \"var\":\n                    next();\n                    var node = var_();\n                    semicolon();\n                    return node;\n\n                  case \"with\":\n                    if (S.input.has_directive(\"use strict\")) {\n                        croak(\"Strict mode may not include a with statement\");\n                    }\n                    next();\n                    return new AST_With({\n                        expression : parenthesized(),\n                        body       : statement(),\n                    });\n                }\n            }\n            unexpected();\n        });\n\n        function labeled_statement() {\n            var label = as_symbol(AST_Label);\n            if (!all(S.labels, function(l) {\n                return l.name != label.name;\n            })) {\n                // ECMA-262, 12.12: An ECMAScript program is considered\n                // syntactically incorrect if it contains a\n                // LabelledStatement that is enclosed by a\n                // LabelledStatement with the same Identifier as label.\n                croak(\"Label \" + label.name + \" defined twice\");\n            }\n            expect(\":\");\n            S.labels.push(label);\n            var stat = statement();\n            S.labels.pop();\n            if (!(stat instanceof AST_IterationStatement)) {\n                // check for `continue` that refers to this label.\n                // those should be reported as syntax errors.\n                // https://github.com/mishoo/UglifyJS/issues/287\n                label.references.forEach(function(ref) {\n                    if (ref instanceof AST_Continue) {\n                        token_error(ref.label.start, \"Continue label `\" + label.name + \"` must refer to IterationStatement\");\n                    }\n                });\n            }\n            return new AST_LabeledStatement({ body: stat, label: label });\n        }\n\n        function simple_statement() {\n            var body = expression();\n            semicolon();\n            return new AST_SimpleStatement({ body: body });\n        }\n\n        function break_cont(type) {\n            var label = null, ldef;\n            if (!can_insert_semicolon()) {\n                label = as_symbol(AST_LabelRef, true);\n            }\n            if (label != null) {\n                ldef = find_if(function(l) {\n                    return l.name == label.name;\n                }, S.labels);\n                if (!ldef) token_error(label.start, \"Undefined label \" + label.name);\n                label.thedef = ldef;\n            } else if (S.in_loop == 0) croak(type.TYPE + \" not inside a loop or switch\");\n            semicolon();\n            var stat = new type({ label: label });\n            if (ldef) ldef.references.push(stat);\n            return stat;\n        }\n\n        function has_modifier(name, no_nlb) {\n            if (!is(\"name\", name)) return;\n            var token = peek();\n            if (!token) return;\n            if (is_token(token, \"operator\", \"=\")) return;\n            if (token.type == \"punc\" && /^[(;}]$/.test(token.value)) return;\n            if (no_nlb && has_newline_before(token)) return;\n            return next();\n        }\n\n        function class_(ctor) {\n            var was_async = S.in_async;\n            var was_gen = S.in_generator;\n            S.input.push_directives_stack();\n            S.input.add_directive(\"use strict\");\n            var name;\n            if (ctor === AST_DefClass) {\n                name = as_symbol(AST_SymbolDefClass);\n            } else {\n                name = as_symbol(AST_SymbolClass, true);\n            }\n            var parent = null;\n            if (is(\"keyword\", \"extends\")) {\n                next();\n                handle_regexp();\n                parent = expr_atom(true);\n            }\n            expect(\"{\");\n            var props = [];\n            while (!is(\"punc\", \"}\")) {\n                if (is(\"punc\", \";\")) {\n                    next();\n                    continue;\n                }\n                var start = S.token;\n                var fixed = !!has_modifier(\"static\");\n                var async = has_modifier(\"async\", true);\n                if (is(\"operator\", \"*\")) {\n                    next();\n                    var internal = is(\"name\") && /^#/.test(S.token.value);\n                    var key = as_property_key();\n                    var gen_start = S.token;\n                    var gen = function_(async ? AST_AsyncGeneratorFunction : AST_GeneratorFunction);\n                    gen.start = gen_start;\n                    gen.end = prev();\n                    props.push(new AST_ClassMethod({\n                        start: start,\n                        static: fixed,\n                        private: internal,\n                        key: key,\n                        value: gen,\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                if (fixed && is(\"punc\", \"{\")) {\n                    props.push(new AST_ClassInit({\n                        start: start,\n                        value: new AST_ClassInitBlock({\n                            start: start,\n                            body: block_(),\n                            end: prev(),\n                        }),\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                var internal = is(\"name\") && /^#/.test(S.token.value);\n                var key = as_property_key();\n                if (is(\"punc\", \"(\")) {\n                    var func_start = S.token;\n                    var func = function_(async ? AST_AsyncFunction : AST_Function);\n                    func.start = func_start;\n                    func.end = prev();\n                    props.push(new AST_ClassMethod({\n                        start: start,\n                        static: fixed,\n                        private: internal,\n                        key: key,\n                        value: func,\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                if (async) unexpected(async);\n                var value = null;\n                if (is(\"operator\", \"=\")) {\n                    next();\n                    S.in_async = false;\n                    S.in_generator = false;\n                    value = maybe_assign();\n                    S.in_generator = was_gen;\n                    S.in_async = was_async;\n                } else if (!(is(\"punc\", \";\") || is(\"punc\", \"}\"))) {\n                    var type = null;\n                    switch (key) {\n                      case \"get\":\n                        type = AST_ClassGetter;\n                        break;\n                      case \"set\":\n                        type = AST_ClassSetter;\n                        break;\n                    }\n                    if (type) {\n                        props.push(new type({\n                            start: start,\n                            static: fixed,\n                            private: is(\"name\") && /^#/.test(S.token.value),\n                            key: as_property_key(),\n                            value: create_accessor(),\n                            end: prev(),\n                        }));\n                        continue;\n                    }\n                }\n                semicolon();\n                props.push(new AST_ClassField({\n                    start: start,\n                    static: fixed,\n                    private: internal,\n                    key: key,\n                    value: value,\n                    end: prev(),\n                }));\n            }\n            next();\n            S.input.pop_directives_stack();\n            S.in_generator = was_gen;\n            S.in_async = was_async;\n            return new ctor({\n                extends: parent,\n                name: name,\n                properties: props,\n            });\n        }\n\n        function for_() {\n            var await_token = is(\"name\", \"await\") && next();\n            expect(\"(\");\n            var init = null;\n            if (await_token || !is(\"punc\", \";\")) {\n                init = is(\"keyword\", \"const\")\n                    ? (next(), const_(true))\n                    : is(\"name\", \"let\") && is_vardefs()\n                    ? (next(), let_(true))\n                    : is(\"keyword\", \"var\")\n                    ? (next(), var_(true))\n                    : expression(true);\n                var ctor;\n                if (await_token) {\n                    expect_token(\"name\", \"of\");\n                    ctor = AST_ForAwaitOf;\n                } else if (is(\"operator\", \"in\")) {\n                    next();\n                    ctor = AST_ForIn;\n                } else if (is(\"name\", \"of\")) {\n                    next();\n                    ctor = AST_ForOf;\n                }\n                if (ctor) {\n                    if (init instanceof AST_Definitions) {\n                        if (init.definitions.length > 1) {\n                            token_error(init.start, \"Only one variable declaration allowed in for..in/of loop\");\n                        }\n                        if (ctor !== AST_ForIn && init.definitions[0].value) {\n                            token_error(init.definitions[0].value.start, \"No initializers allowed in for..of loop\");\n                        }\n                    } else if (!(is_assignable(init) || (init = to_destructured(init)) instanceof AST_Destructured)) {\n                        token_error(init.start, \"Invalid left-hand side in for..in/of loop\");\n                    }\n                    return for_enum(ctor, init);\n                }\n            }\n            return regular_for(init);\n        }\n\n        function regular_for(init) {\n            expect(\";\");\n            var test = is(\"punc\", \";\") ? null : expression();\n            expect(\";\");\n            var step = is(\"punc\", \")\") ? null : expression();\n            expect(\")\");\n            return new AST_For({\n                init      : init,\n                condition : test,\n                step      : step,\n                body      : in_loop(statement)\n            });\n        }\n\n        function for_enum(ctor, init) {\n            handle_regexp();\n            var obj = expression();\n            expect(\")\");\n            return new ctor({\n                init   : init,\n                object : obj,\n                body   : in_loop(statement)\n            });\n        }\n\n        function to_funarg(node) {\n            if (node instanceof AST_Array) {\n                var rest = null;\n                if (node.elements[node.elements.length - 1] instanceof AST_Spread) {\n                    rest = to_funarg(node.elements.pop().expression);\n                }\n                return new AST_DestructuredArray({\n                    start: node.start,\n                    elements: node.elements.map(to_funarg),\n                    rest: rest,\n                    end: node.end,\n                });\n            }\n            if (node instanceof AST_Assign) return new AST_DefaultValue({\n                start: node.start,\n                name: to_funarg(node.left),\n                value: node.right,\n                end: node.end,\n            });\n            if (node instanceof AST_DefaultValue) {\n                node.name = to_funarg(node.name);\n                return node;\n            }\n            if (node instanceof AST_DestructuredArray) {\n                node.elements = node.elements.map(to_funarg);\n                if (node.rest) node.rest = to_funarg(node.rest);\n                return node;\n            }\n            if (node instanceof AST_DestructuredObject) {\n                node.properties.forEach(function(prop) {\n                    prop.value = to_funarg(prop.value);\n                });\n                if (node.rest) node.rest = to_funarg(node.rest);\n                return node;\n            }\n            if (node instanceof AST_Hole) return node;\n            if (node instanceof AST_Object) {\n                var rest = null;\n                if (node.properties[node.properties.length - 1] instanceof AST_Spread) {\n                    rest = to_funarg(node.properties.pop().expression);\n                }\n                return new AST_DestructuredObject({\n                    start: node.start,\n                    properties: node.properties.map(function(prop) {\n                        if (!(prop instanceof AST_ObjectKeyVal)) token_error(prop.start, \"Invalid destructuring assignment\");\n                        return new AST_DestructuredKeyVal({\n                            start: prop.start,\n                            key: prop.key,\n                            value: to_funarg(prop.value),\n                            end: prop.end,\n                        });\n                    }),\n                    rest: rest,\n                    end: node.end,\n                });\n            }\n            if (node instanceof AST_SymbolFunarg) return node;\n            if (node instanceof AST_SymbolRef) return new AST_SymbolFunarg(node);\n            if (node instanceof AST_Yield) return new AST_SymbolFunarg({\n                start: node.start,\n                name: \"yield\",\n                end: node.end,\n            });\n            token_error(node.start, \"Invalid arrow parameter\");\n        }\n\n        function arrow(exprs, start, async) {\n            var was_async = S.in_async;\n            var was_gen = S.in_generator;\n            S.in_async = async;\n            S.in_generator = false;\n            var was_funarg = S.in_funarg;\n            S.in_funarg = S.in_function;\n            var argnames = exprs.map(to_funarg);\n            var rest = exprs.rest || null;\n            if (rest) rest = to_funarg(rest);\n            S.in_funarg = was_funarg;\n            expect(\"=>\");\n            var body, value;\n            var loop = S.in_loop;\n            var labels = S.labels;\n            ++S.in_function;\n            S.input.push_directives_stack();\n            S.in_loop = 0;\n            S.labels = [];\n            if (is(\"punc\", \"{\")) {\n                S.in_directives = true;\n                body = block_();\n                value = null;\n            } else {\n                body = [];\n                handle_regexp();\n                value = maybe_assign();\n            }\n            var is_strict = S.input.has_directive(\"use strict\");\n            S.input.pop_directives_stack();\n            --S.in_function;\n            S.in_loop = loop;\n            S.labels = labels;\n            S.in_generator = was_gen;\n            S.in_async = was_async;\n            var node = new (async ? AST_AsyncArrow : AST_Arrow)({\n                start: start,\n                argnames: argnames,\n                rest: rest,\n                body: body,\n                value: value,\n                end: prev(),\n            });\n            if (is_strict) node.each_argname(strict_verify_symbol);\n            return node;\n        }\n\n        var function_ = function(ctor) {\n            var was_async = S.in_async;\n            var was_gen = S.in_generator;\n            var name;\n            if (/Defun$/.test(ctor.TYPE)) {\n                name = as_symbol(AST_SymbolDefun);\n                S.in_async = /^Async/.test(ctor.TYPE);\n                S.in_generator = /Generator/.test(ctor.TYPE);\n            } else {\n                S.in_async = /^Async/.test(ctor.TYPE);\n                S.in_generator = /Generator/.test(ctor.TYPE);\n                name = as_symbol(AST_SymbolLambda, true);\n            }\n            if (name && ctor !== AST_Accessor && !(name instanceof AST_SymbolDeclaration))\n                unexpected(prev());\n            expect(\"(\");\n            var was_funarg = S.in_funarg;\n            S.in_funarg = S.in_function;\n            var argnames = expr_list(\")\", !options.strict, false, function() {\n                return maybe_default(AST_SymbolFunarg);\n            });\n            S.in_funarg = was_funarg;\n            var loop = S.in_loop;\n            var labels = S.labels;\n            ++S.in_function;\n            S.in_directives = true;\n            S.input.push_directives_stack();\n            S.in_loop = 0;\n            S.labels = [];\n            var body = block_();\n            var is_strict = S.input.has_directive(\"use strict\");\n            S.input.pop_directives_stack();\n            --S.in_function;\n            S.in_loop = loop;\n            S.labels = labels;\n            S.in_generator = was_gen;\n            S.in_async = was_async;\n            var node = new ctor({\n                name: name,\n                argnames: argnames,\n                rest: argnames.rest || null,\n                body: body,\n            });\n            if (is_strict) {\n                if (name) strict_verify_symbol(name);\n                node.each_argname(strict_verify_symbol);\n            }\n            return node;\n        };\n\n        function if_() {\n            var cond = parenthesized(), body = statement(), alt = null;\n            if (is(\"keyword\", \"else\")) {\n                next();\n                alt = statement();\n            }\n            return new AST_If({\n                condition   : cond,\n                body        : body,\n                alternative : alt,\n            });\n        }\n\n        function is_alias() {\n            return is(\"name\") || is(\"string\") || is_identifier_string(S.token.value);\n        }\n\n        function make_string(token) {\n            return new AST_String({\n                start: token,\n                quote: token.quote,\n                value: token.value,\n                end: token,\n            });\n        }\n\n        function as_path() {\n            var path = S.token;\n            expect_token(\"string\");\n            semicolon();\n            return make_string(path);\n        }\n\n        function export_() {\n            if (is(\"operator\", \"*\")) {\n                var key = S.token;\n                var alias = key;\n                next();\n                if (is(\"name\", \"as\")) {\n                    next();\n                    if (!is_alias()) expect_token(\"name\");\n                    alias = S.token;\n                    next();\n                }\n                expect_token(\"name\", \"from\");\n                return new AST_ExportForeign({\n                    aliases: [ make_string(alias) ],\n                    keys: [ make_string(key) ],\n                    path: as_path(),\n                });\n            }\n            if (is(\"punc\", \"{\")) {\n                next();\n                var aliases = [];\n                var keys = [];\n                while (is_alias()) {\n                    var key = S.token;\n                    next();\n                    keys.push(key);\n                    if (is(\"name\", \"as\")) {\n                        next();\n                        if (!is_alias()) expect_token(\"name\");\n                        aliases.push(S.token);\n                        next();\n                    } else {\n                        aliases.push(key);\n                    }\n                    if (!is(\"punc\", \"}\")) expect(\",\");\n                }\n                expect(\"}\");\n                if (is(\"name\", \"from\")) {\n                    next();\n                    return new AST_ExportForeign({\n                        aliases: aliases.map(make_string),\n                        keys: keys.map(make_string),\n                        path: as_path(),\n                    });\n                }\n                semicolon();\n                return new AST_ExportReferences({\n                    properties: keys.map(function(token, index) {\n                        if (!is_token(token, \"name\")) token_error(token, \"Name expected\");\n                        var sym = _make_symbol(AST_SymbolExport, token);\n                        sym.alias = make_string(aliases[index]);\n                        return sym;\n                    }),\n                });\n            }\n            if (is(\"keyword\", \"default\")) {\n                next();\n                var start = S.token;\n                var body = export_default_decl();\n                if (body) {\n                    body.start = start;\n                    body.end = prev();\n                } else {\n                    handle_regexp();\n                    body = expression();\n                    semicolon();\n                }\n                return new AST_ExportDefault({ body: body });\n            }\n            return new AST_ExportDeclaration({ body: export_decl() });\n        }\n\n        function maybe_named(def, expr) {\n            if (expr.name) {\n                expr = new def(expr);\n                expr.name = new (def === AST_DefClass ? AST_SymbolDefClass : AST_SymbolDefun)(expr.name);\n            }\n            return expr;\n        }\n\n        function export_default_decl() {\n            if (is(\"name\", \"async\")) {\n                if (!is_token(peek(), \"keyword\", \"function\")) return;\n                next();\n                next();\n                if (!is(\"operator\", \"*\")) return maybe_named(AST_AsyncDefun, function_(AST_AsyncFunction));\n                next();\n                return maybe_named(AST_AsyncGeneratorDefun, function_(AST_AsyncGeneratorFunction));\n            } else if (is(\"keyword\")) switch (S.token.value) {\n              case \"class\":\n                next();\n                return maybe_named(AST_DefClass, class_(AST_ClassExpression));\n              case \"function\":\n                next();\n                if (!is(\"operator\", \"*\")) return maybe_named(AST_Defun, function_(AST_Function));\n                next();\n                return maybe_named(AST_GeneratorDefun, function_(AST_GeneratorFunction));\n            }\n        }\n\n        var export_decl = embed_tokens(function() {\n            if (is(\"name\")) switch (S.token.value) {\n              case \"async\":\n                next();\n                expect_token(\"keyword\", \"function\");\n                if (!is(\"operator\", \"*\")) return function_(AST_AsyncDefun);\n                next();\n                return function_(AST_AsyncGeneratorDefun);\n              case \"let\":\n                next();\n                var node = let_();\n                semicolon();\n                return node;\n            } else if (is(\"keyword\")) switch (S.token.value) {\n              case \"class\":\n                next();\n                return class_(AST_DefClass);\n              case \"const\":\n                next();\n                var node = const_();\n                semicolon();\n                return node;\n              case \"function\":\n                next();\n                if (!is(\"operator\", \"*\")) return function_(AST_Defun);\n                next();\n                return function_(AST_GeneratorDefun);\n              case \"var\":\n                next();\n                var node = var_();\n                semicolon();\n                return node;\n            }\n            unexpected();\n        });\n\n        function import_() {\n            var all = null;\n            var def = as_symbol(AST_SymbolImport, true);\n            var props = null;\n            var cont;\n            if (def) {\n                def.key = new AST_String({\n                    start: def.start,\n                    value: \"\",\n                    end: def.end,\n                });\n                if (cont = is(\"punc\", \",\")) next();\n            } else {\n                cont = !is(\"string\");\n            }\n            if (cont) {\n                if (is(\"operator\", \"*\")) {\n                    var key = S.token;\n                    next();\n                    expect_token(\"name\", \"as\");\n                    all = as_symbol(AST_SymbolImport);\n                    all.key = make_string(key);\n                } else {\n                    expect(\"{\");\n                    props = [];\n                    while (is_alias()) {\n                        var alias;\n                        if (is_token(peek(), \"name\", \"as\")) {\n                            var key = S.token;\n                            next();\n                            next();\n                            alias = as_symbol(AST_SymbolImport);\n                            alias.key = make_string(key);\n                        } else {\n                            alias = as_symbol(AST_SymbolImport);\n                            alias.key = new AST_String({\n                                start: alias.start,\n                                value: alias.name,\n                                end: alias.end,\n                            });\n                        }\n                        props.push(alias);\n                        if (!is(\"punc\", \"}\")) expect(\",\");\n                    }\n                    expect(\"}\");\n                }\n            }\n            if (all || def || props) expect_token(\"name\", \"from\");\n            return new AST_Import({\n                all: all,\n                default: def,\n                path: as_path(),\n                properties: props,\n            });\n        }\n\n        function block_() {\n            expect(\"{\");\n            var a = [];\n            while (!is(\"punc\", \"}\")) {\n                if (is(\"eof\")) expect(\"}\");\n                a.push(statement());\n            }\n            next();\n            return a;\n        }\n\n        function switch_body_() {\n            expect(\"{\");\n            var a = [], branch, cur, default_branch, tmp;\n            while (!is(\"punc\", \"}\")) {\n                if (is(\"eof\")) expect(\"}\");\n                if (is(\"keyword\", \"case\")) {\n                    if (branch) branch.end = prev();\n                    cur = [];\n                    branch = new AST_Case({\n                        start      : (tmp = S.token, next(), tmp),\n                        expression : expression(),\n                        body       : cur\n                    });\n                    a.push(branch);\n                    expect(\":\");\n                } else if (is(\"keyword\", \"default\")) {\n                    if (branch) branch.end = prev();\n                    if (default_branch) croak(\"More than one default clause in switch statement\");\n                    cur = [];\n                    branch = new AST_Default({\n                        start : (tmp = S.token, next(), expect(\":\"), tmp),\n                        body  : cur\n                    });\n                    a.push(branch);\n                    default_branch = branch;\n                } else {\n                    if (!cur) unexpected();\n                    cur.push(statement());\n                }\n            }\n            if (branch) branch.end = prev();\n            next();\n            return a;\n        }\n\n        function try_() {\n            var body = block_(), bcatch = null, bfinally = null;\n            if (is(\"keyword\", \"catch\")) {\n                var start = S.token;\n                next();\n                var name = null;\n                if (is(\"punc\", \"(\")) {\n                    next();\n                    name = maybe_destructured(AST_SymbolCatch);\n                    expect(\")\");\n                }\n                bcatch = new AST_Catch({\n                    start   : start,\n                    argname : name,\n                    body    : block_(),\n                    end     : prev()\n                });\n            }\n            if (is(\"keyword\", \"finally\")) {\n                var start = S.token;\n                next();\n                bfinally = new AST_Finally({\n                    start : start,\n                    body  : block_(),\n                    end   : prev()\n                });\n            }\n            if (!bcatch && !bfinally)\n                croak(\"Missing catch/finally blocks\");\n            return new AST_Try({\n                body     : body,\n                bcatch   : bcatch,\n                bfinally : bfinally\n            });\n        }\n\n        function vardefs(type, no_in) {\n            var a = [];\n            for (;;) {\n                var start = S.token;\n                var name = maybe_destructured(type);\n                var value = null;\n                if (is(\"operator\", \"=\")) {\n                    next();\n                    value = maybe_assign(no_in);\n                } else if (!no_in && (type === AST_SymbolConst || name instanceof AST_Destructured)) {\n                    croak(\"Missing initializer in declaration\");\n                }\n                a.push(new AST_VarDef({\n                    start : start,\n                    name  : name,\n                    value : value,\n                    end   : prev()\n                }));\n                if (!is(\"punc\", \",\"))\n                    break;\n                next();\n            }\n            return a;\n        }\n\n        function is_vardefs() {\n            var token = peek();\n            return is_token(token, \"name\") || is_token(token, \"punc\", \"[\") || is_token(token, \"punc\", \"{\");\n        }\n\n        var const_ = function(no_in) {\n            return new AST_Const({\n                start       : prev(),\n                definitions : vardefs(AST_SymbolConst, no_in),\n                end         : prev()\n            });\n        };\n\n        var let_ = function(no_in) {\n            return new AST_Let({\n                start       : prev(),\n                definitions : vardefs(AST_SymbolLet, no_in),\n                end         : prev()\n            });\n        };\n\n        var var_ = function(no_in) {\n            return new AST_Var({\n                start       : prev(),\n                definitions : vardefs(AST_SymbolVar, no_in),\n                end         : prev()\n            });\n        };\n\n        var new_ = function(allow_calls) {\n            var start = S.token;\n            expect_token(\"operator\", \"new\");\n            var call;\n            if (is(\"punc\", \".\") && is_token(peek(), \"name\", \"target\")) {\n                next();\n                next();\n                call = new AST_NewTarget();\n            } else {\n                var exp = expr_atom(false), args;\n                if (is(\"punc\", \"(\")) {\n                    next();\n                    args = expr_list(\")\", !options.strict);\n                } else {\n                    args = [];\n                }\n                call = new AST_New({ expression: exp, args: args });\n            }\n            call.start = start;\n            call.end = prev();\n            return subscripts(call, allow_calls);\n        };\n\n        function as_atom_node() {\n            var ret, tok = S.token, value = tok.value;\n            switch (tok.type) {\n              case \"num\":\n                if (isFinite(value)) {\n                    ret = new AST_Number({ value: value });\n                } else {\n                    ret = new AST_Infinity();\n                    if (value < 0) ret = new AST_UnaryPrefix({ operator: \"-\", expression: ret });\n                }\n                break;\n              case \"bigint\":\n                ret = new AST_BigInt({ value: value });\n                break;\n              case \"string\":\n                ret = new AST_String({ value: value, quote: tok.quote });\n                break;\n              case \"regexp\":\n                ret = new AST_RegExp({ value: value });\n                break;\n              case \"atom\":\n                switch (value) {\n                  case \"false\":\n                    ret = new AST_False();\n                    break;\n                  case \"true\":\n                    ret = new AST_True();\n                    break;\n                  case \"null\":\n                    ret = new AST_Null();\n                    break;\n                  default:\n                    unexpected();\n                }\n                break;\n              default:\n                unexpected();\n            }\n            next();\n            ret.start = ret.end = tok;\n            return ret;\n        }\n\n        var expr_atom = function(allow_calls) {\n            if (is(\"operator\", \"new\")) {\n                return new_(allow_calls);\n            }\n            var start = S.token;\n            if (is(\"punc\")) {\n                switch (start.value) {\n                  case \"`\":\n                    return subscripts(template(null), allow_calls);\n                  case \"(\":\n                    next();\n                    if (is(\"punc\", \")\")) {\n                        next();\n                        return arrow([], start);\n                    }\n                    var ex = expression(false, true);\n                    var len = start.comments_before.length;\n                    [].unshift.apply(ex.start.comments_before, start.comments_before);\n                    start.comments_before.length = 0;\n                    start.comments_before = ex.start.comments_before;\n                    start.comments_before_length = len;\n                    if (len == 0 && start.comments_before.length > 0) {\n                        var comment = start.comments_before[0];\n                        if (!comment.nlb) {\n                            comment.nlb = start.nlb;\n                            start.nlb = false;\n                        }\n                    }\n                    start.comments_after = ex.start.comments_after;\n                    ex.start = start;\n                    expect(\")\");\n                    var end = prev();\n                    end.comments_before = ex.end.comments_before;\n                    end.comments_after.forEach(function(comment) {\n                        ex.end.comments_after.push(comment);\n                        if (comment.nlb) S.token.nlb = true;\n                    });\n                    end.comments_after.length = 0;\n                    end.comments_after = ex.end.comments_after;\n                    ex.end = end;\n                    if (is(\"punc\", \"=>\")) return arrow(ex instanceof AST_Sequence ? ex.expressions : [ ex ], start);\n                    return subscripts(ex, allow_calls);\n                  case \"[\":\n                    return subscripts(array_(), allow_calls);\n                  case \"{\":\n                    return subscripts(object_(), allow_calls);\n                }\n                unexpected();\n            }\n            if (is(\"keyword\")) switch (start.value) {\n              case \"class\":\n                next();\n                var clazz = class_(AST_ClassExpression);\n                clazz.start = start;\n                clazz.end = prev();\n                return subscripts(clazz, allow_calls);\n              case \"function\":\n                next();\n                var func;\n                if (is(\"operator\", \"*\")) {\n                    next();\n                    func = function_(AST_GeneratorFunction);\n                } else {\n                    func = function_(AST_Function);\n                }\n                func.start = start;\n                func.end = prev();\n                return subscripts(func, allow_calls);\n            }\n            if (is(\"name\")) {\n                var sym = _make_symbol(AST_SymbolRef, start);\n                next();\n                if (sym.name == \"async\") {\n                    if (is(\"keyword\", \"function\")) {\n                        next();\n                        var func;\n                        if (is(\"operator\", \"*\")) {\n                            next();\n                            func = function_(AST_AsyncGeneratorFunction);\n                        } else {\n                            func = function_(AST_AsyncFunction);\n                        }\n                        func.start = start;\n                        func.end = prev();\n                        return subscripts(func, allow_calls);\n                    }\n                    if (is(\"name\") && is_token(peek(), \"punc\", \"=>\")) {\n                        start = S.token;\n                        sym = _make_symbol(AST_SymbolRef, start);\n                        next();\n                        return arrow([ sym ], start, true);\n                    }\n                    if (is(\"punc\", \"(\")) {\n                        var call = subscripts(sym, allow_calls);\n                        if (!is(\"punc\", \"=>\")) return call;\n                        var args = call.args;\n                        if (args[args.length - 1] instanceof AST_Spread) {\n                            args.rest = args.pop().expression;\n                        }\n                        return arrow(args, start, true);\n                    }\n                }\n                return is(\"punc\", \"=>\") ? arrow([ sym ], start) : subscripts(sym, allow_calls);\n            }\n            if (ATOMIC_START_TOKEN[S.token.type]) {\n                return subscripts(as_atom_node(), allow_calls);\n            }\n            unexpected();\n        };\n\n        function expr_list(closing, allow_trailing_comma, allow_empty, parser) {\n            if (!parser) parser = maybe_assign;\n            var first = true, a = [];\n            while (!is(\"punc\", closing)) {\n                if (first) first = false; else expect(\",\");\n                if (allow_trailing_comma && is(\"punc\", closing)) break;\n                if (allow_empty && is(\"punc\", \",\")) {\n                    a.push(new AST_Hole({ start: S.token, end: S.token }));\n                } else if (!is(\"operator\", \"...\")) {\n                    a.push(parser());\n                } else if (parser === maybe_assign) {\n                    a.push(new AST_Spread({\n                        start: S.token,\n                        expression: (next(), parser()),\n                        end: prev(),\n                    }));\n                } else {\n                    next();\n                    a.rest = parser();\n                    if (a.rest instanceof AST_DefaultValue) token_error(a.rest.start, \"Invalid rest parameter\");\n                    break;\n                }\n            }\n            expect(closing);\n            return a;\n        }\n\n        var array_ = embed_tokens(function() {\n            expect(\"[\");\n            return new AST_Array({\n                elements: expr_list(\"]\", !options.strict, true)\n            });\n        });\n\n        var create_accessor = embed_tokens(function() {\n            return function_(AST_Accessor);\n        });\n\n        var object_ = embed_tokens(function() {\n            expect(\"{\");\n            var first = true, a = [];\n            while (!is(\"punc\", \"}\")) {\n                if (first) first = false; else expect(\",\");\n                // allow trailing comma\n                if (!options.strict && is(\"punc\", \"}\")) break;\n                var start = S.token;\n                if (is(\"operator\", \"*\")) {\n                    next();\n                    var key = as_property_key();\n                    var gen_start = S.token;\n                    var gen = function_(AST_GeneratorFunction);\n                    gen.start = gen_start;\n                    gen.end = prev();\n                    a.push(new AST_ObjectMethod({\n                        start: start,\n                        key: key,\n                        value: gen,\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                if (is(\"operator\", \"...\")) {\n                    next();\n                    a.push(new AST_Spread({\n                        start: start,\n                        expression: maybe_assign(),\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                if (is_token(peek(), \"operator\", \"=\")) {\n                    var name = as_symbol(AST_SymbolRef);\n                    next();\n                    a.push(new AST_ObjectKeyVal({\n                        start: start,\n                        key: start.value,\n                        value: new AST_Assign({\n                            start: start,\n                            left: name,\n                            operator: \"=\",\n                            right: maybe_assign(),\n                            end: prev(),\n                        }),\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                if (is_token(peek(), \"punc\", \",\") || is_token(peek(), \"punc\", \"}\")) {\n                    a.push(new AST_ObjectKeyVal({\n                        start: start,\n                        key: start.value,\n                        value: as_symbol(AST_SymbolRef),\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                var key = as_property_key();\n                if (is(\"punc\", \"(\")) {\n                    var func_start = S.token;\n                    var func = function_(AST_Function);\n                    func.start = func_start;\n                    func.end = prev();\n                    a.push(new AST_ObjectMethod({\n                        start: start,\n                        key: key,\n                        value: func,\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                if (is(\"punc\", \":\")) {\n                    next();\n                    a.push(new AST_ObjectKeyVal({\n                        start: start,\n                        key: key,\n                        value: maybe_assign(),\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                if (start.type == \"name\") switch (key) {\n                  case \"async\":\n                    var is_gen = is(\"operator\", \"*\") && next();\n                    key = as_property_key();\n                    var func_start = S.token;\n                    var func = function_(is_gen ? AST_AsyncGeneratorFunction : AST_AsyncFunction);\n                    func.start = func_start;\n                    func.end = prev();\n                    a.push(new AST_ObjectMethod({\n                        start: start,\n                        key: key,\n                        value: func,\n                        end: prev(),\n                    }));\n                    continue;\n                  case \"get\":\n                    a.push(new AST_ObjectGetter({\n                        start: start,\n                        key: as_property_key(),\n                        value: create_accessor(),\n                        end: prev(),\n                    }));\n                    continue;\n                  case \"set\":\n                    a.push(new AST_ObjectSetter({\n                        start: start,\n                        key: as_property_key(),\n                        value: create_accessor(),\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                unexpected();\n            }\n            next();\n            return new AST_Object({ properties: a });\n        });\n\n        function as_property_key() {\n            var tmp = S.token;\n            switch (tmp.type) {\n              case \"operator\":\n                if (!KEYWORDS[tmp.value]) unexpected();\n              case \"num\":\n              case \"string\":\n              case \"name\":\n              case \"keyword\":\n              case \"atom\":\n                next();\n                return \"\" + tmp.value;\n              case \"punc\":\n                expect(\"[\");\n                var key = maybe_assign();\n                expect(\"]\");\n                return key;\n              default:\n                unexpected();\n            }\n        }\n\n        function as_name() {\n            var name = S.token.value;\n            expect_token(\"name\");\n            return name;\n        }\n\n        function _make_symbol(type, token) {\n            var name = token.value;\n            switch (name) {\n              case \"await\":\n                if (S.in_async) unexpected(token);\n                break;\n              case \"super\":\n                type = AST_Super;\n                break;\n              case \"this\":\n                type = AST_This;\n                break;\n              case \"yield\":\n                if (S.in_generator) unexpected(token);\n                break;\n            }\n            return new type({\n                name: \"\" + name,\n                start: token,\n                end: token,\n            });\n        }\n\n        function strict_verify_symbol(sym) {\n            if (sym.name == \"arguments\" || sym.name == \"eval\" || sym.name == \"let\")\n                token_error(sym.start, \"Unexpected \" + sym.name + \" in strict mode\");\n        }\n\n        function as_symbol(type, no_error) {\n            if (!is(\"name\")) {\n                if (!no_error) croak(\"Name expected\");\n                return null;\n            }\n            var sym = _make_symbol(type, S.token);\n            if (S.input.has_directive(\"use strict\") && sym instanceof AST_SymbolDeclaration) {\n                strict_verify_symbol(sym);\n            }\n            next();\n            return sym;\n        }\n\n        function maybe_destructured(type) {\n            var start = S.token;\n            if (is(\"punc\", \"[\")) {\n                next();\n                var elements = expr_list(\"]\", !options.strict, true, function() {\n                    return maybe_default(type);\n                });\n                return new AST_DestructuredArray({\n                    start: start,\n                    elements: elements,\n                    rest: elements.rest || null,\n                    end: prev(),\n                });\n            }\n            if (is(\"punc\", \"{\")) {\n                next();\n                var first = true, a = [], rest = null;\n                while (!is(\"punc\", \"}\")) {\n                    if (first) first = false; else expect(\",\");\n                    // allow trailing comma\n                    if (!options.strict && is(\"punc\", \"}\")) break;\n                    var key_start = S.token;\n                    if (is(\"punc\", \"[\") || is_token(peek(), \"punc\", \":\")) {\n                        var key = as_property_key();\n                        expect(\":\");\n                        a.push(new AST_DestructuredKeyVal({\n                            start: key_start,\n                            key: key,\n                            value: maybe_default(type),\n                            end: prev(),\n                        }));\n                        continue;\n                    }\n                    if (is(\"operator\", \"...\")) {\n                        next();\n                        rest = maybe_destructured(type);\n                        break;\n                    }\n                    var name = as_symbol(type);\n                    if (is(\"operator\", \"=\")) {\n                        next();\n                        name = new AST_DefaultValue({\n                            start: name.start,\n                            name: name,\n                            value: maybe_assign(),\n                            end: prev(),\n                        });\n                    }\n                    a.push(new AST_DestructuredKeyVal({\n                        start: key_start,\n                        key: key_start.value,\n                        value: name,\n                        end: prev(),\n                    }));\n                }\n                expect(\"}\");\n                return new AST_DestructuredObject({\n                    start: start,\n                    properties: a,\n                    rest: rest,\n                    end: prev(),\n                });\n            }\n            return as_symbol(type);\n        }\n\n        function maybe_default(type) {\n            var start = S.token;\n            var name = maybe_destructured(type);\n            if (!is(\"operator\", \"=\")) return name;\n            next();\n            return new AST_DefaultValue({\n                start: start,\n                name: name,\n                value: maybe_assign(),\n                end: prev(),\n            });\n        }\n\n        function template(tag) {\n            var start = tag ? tag.start : S.token;\n            var read = S.input.context().read_template;\n            var strings = [];\n            var expressions = [];\n            while (read(strings)) {\n                next();\n                expressions.push(expression());\n                if (!is(\"punc\", \"}\")) unexpected();\n            }\n            next();\n            return new AST_Template({\n                start: start,\n                expressions: expressions,\n                strings: strings,\n                tag: tag,\n                end: prev(),\n            });\n        }\n\n        function subscripts(expr, allow_calls) {\n            var start = expr.start;\n            var optional = null;\n            while (true) {\n                if (is(\"operator\", \"?\") && is_token(peek(), \"punc\", \".\")) {\n                    next();\n                    next();\n                    optional = expr;\n                }\n                if (is(\"punc\", \"[\")) {\n                    next();\n                    var prop = expression();\n                    expect(\"]\");\n                    expr = new AST_Sub({\n                        start: start,\n                        optional: optional === expr,\n                        expression: expr,\n                        property: prop,\n                        end: prev(),\n                    });\n                } else if (allow_calls && is(\"punc\", \"(\")) {\n                    next();\n                    expr = new AST_Call({\n                        start: start,\n                        optional: optional === expr,\n                        expression: expr,\n                        args: expr_list(\")\", !options.strict),\n                        end: prev(),\n                    });\n                } else if (optional === expr || is(\"punc\", \".\")) {\n                    if (optional !== expr) next();\n                    expr = new AST_Dot({\n                        start: start,\n                        optional: optional === expr,\n                        expression: expr,\n                        property: as_name(),\n                        end: prev(),\n                    });\n                } else if (is(\"punc\", \"`\")) {\n                    if (optional) croak(\"Invalid template on optional chain\");\n                    expr = template(expr);\n                } else {\n                    break;\n                }\n            }\n            if (optional) expr.terminal = true;\n            if (expr instanceof AST_Call && !expr.pure) {\n                var start = expr.start;\n                var comments = start.comments_before;\n                var i = HOP(start, \"comments_before_length\") ? start.comments_before_length : comments.length;\n                while (--i >= 0) {\n                    if (/[@#]__PURE__/.test(comments[i].value)) {\n                        expr.pure = true;\n                        break;\n                    }\n                }\n            }\n            return expr;\n        }\n\n        function maybe_unary(no_in) {\n            var start = S.token;\n            if (S.in_async && is(\"name\", \"await\")) {\n                if (S.in_funarg === S.in_function) croak(\"Invalid use of await in function argument\");\n                S.input.context().regex_allowed = true;\n                next();\n                return new AST_Await({\n                    start: start,\n                    expression: maybe_unary(no_in),\n                    end: prev(),\n                });\n            }\n            if (S.in_generator && is(\"name\", \"yield\")) {\n                if (S.in_funarg === S.in_function) croak(\"Invalid use of yield in function argument\");\n                S.input.context().regex_allowed = true;\n                next();\n                var exp = null;\n                var nested = false;\n                if (is(\"operator\", \"*\")) {\n                    next();\n                    exp = maybe_assign(no_in);\n                    nested = true;\n                } else if (is(\"punc\") ? !PUNC_AFTER_EXPRESSION[S.token.value] : !can_insert_semicolon()) {\n                    exp = maybe_assign(no_in);\n                }\n                return new AST_Yield({\n                    start: start,\n                    expression: exp,\n                    nested: nested,\n                    end: prev(),\n                });\n            }\n            if (is(\"operator\") && UNARY_PREFIX[start.value]) {\n                next();\n                handle_regexp();\n                var ex = make_unary(AST_UnaryPrefix, start, maybe_unary(no_in));\n                ex.start = start;\n                ex.end = prev();\n                return ex;\n            }\n            var val = expr_atom(true);\n            while (is(\"operator\") && UNARY_POSTFIX[S.token.value] && !has_newline_before(S.token)) {\n                val = make_unary(AST_UnaryPostfix, S.token, val);\n                val.start = start;\n                val.end = S.token;\n                next();\n            }\n            return val;\n        }\n\n        function make_unary(ctor, token, expr) {\n            var op = token.value;\n            switch (op) {\n              case \"++\":\n              case \"--\":\n                if (!is_assignable(expr))\n                    token_error(token, \"Invalid use of \" + op + \" operator\");\n                break;\n              case \"delete\":\n                if (expr instanceof AST_SymbolRef && S.input.has_directive(\"use strict\"))\n                    token_error(expr.start, \"Calling delete on expression not allowed in strict mode\");\n                break;\n            }\n            return new ctor({ operator: op, expression: expr });\n        }\n\n        var expr_op = function(left, min_precision, no_in) {\n            var op = is(\"operator\") ? S.token.value : null;\n            if (op == \"in\" && no_in) op = null;\n            var precision = op != null ? PRECEDENCE[op] : null;\n            if (precision != null && precision > min_precision) {\n                next();\n                var right = expr_op(maybe_unary(no_in), op == \"**\" ? precision - 1 : precision, no_in);\n                return expr_op(new AST_Binary({\n                    start    : left.start,\n                    left     : left,\n                    operator : op,\n                    right    : right,\n                    end      : right.end,\n                }), min_precision, no_in);\n            }\n            return left;\n        };\n\n        function expr_ops(no_in) {\n            return expr_op(maybe_unary(no_in), 0, no_in);\n        }\n\n        var maybe_conditional = function(no_in) {\n            var start = S.token;\n            var expr = expr_ops(no_in);\n            if (is(\"operator\", \"?\")) {\n                next();\n                var yes = maybe_assign();\n                expect(\":\");\n                return new AST_Conditional({\n                    start       : start,\n                    condition   : expr,\n                    consequent  : yes,\n                    alternative : maybe_assign(no_in),\n                    end         : prev()\n                });\n            }\n            return expr;\n        };\n\n        function is_assignable(expr) {\n            return expr instanceof AST_PropAccess && !expr.optional || expr instanceof AST_SymbolRef;\n        }\n\n        function to_destructured(node) {\n            if (node instanceof AST_Array) {\n                var rest = null;\n                if (node.elements[node.elements.length - 1] instanceof AST_Spread) {\n                    rest = to_destructured(node.elements.pop().expression);\n                    if (!(rest instanceof AST_Destructured || is_assignable(rest))) return node;\n                }\n                var elements = node.elements.map(to_destructured);\n                return all(elements, function(node) {\n                    return node instanceof AST_DefaultValue\n                        || node instanceof AST_Destructured\n                        || node instanceof AST_Hole\n                        || is_assignable(node);\n                }) ? new AST_DestructuredArray({\n                    start: node.start,\n                    elements: elements,\n                    rest: rest,\n                    end: node.end,\n                }) : node;\n            }\n            if (node instanceof AST_Assign) {\n                var name = to_destructured(node.left);\n                return name instanceof AST_Destructured || is_assignable(name) ? new AST_DefaultValue({\n                    start: node.start,\n                    name: name,\n                    value: node.right,\n                    end: node.end,\n                }) : node;\n            }\n            if (!(node instanceof AST_Object)) return node;\n            var rest = null;\n            if (node.properties[node.properties.length - 1] instanceof AST_Spread) {\n                rest = to_destructured(node.properties.pop().expression);\n                if (!(rest instanceof AST_Destructured || is_assignable(rest))) return node;\n            }\n            var props = [];\n            for (var i = 0; i < node.properties.length; i++) {\n                var prop = node.properties[i];\n                if (!(prop instanceof AST_ObjectKeyVal)) return node;\n                var value = to_destructured(prop.value);\n                if (!(value instanceof AST_DefaultValue || value instanceof AST_Destructured || is_assignable(value))) {\n                    return node;\n                }\n                props.push(new AST_DestructuredKeyVal({\n                    start: prop.start,\n                    key: prop.key,\n                    value: value,\n                    end: prop.end,\n                }));\n            }\n            return new AST_DestructuredObject({\n                start: node.start,\n                properties: props,\n                rest: rest,\n                end: node.end,\n            });\n        }\n\n        function maybe_assign(no_in) {\n            var start = S.token;\n            var left = maybe_conditional(no_in), val = S.token.value;\n            if (is(\"operator\") && ASSIGNMENT[val]) {\n                if (is_assignable(left) || val == \"=\" && (left = to_destructured(left)) instanceof AST_Destructured) {\n                    next();\n                    return new AST_Assign({\n                        start    : start,\n                        left     : left,\n                        operator : val,\n                        right    : maybe_assign(no_in),\n                        end      : prev()\n                    });\n                }\n                croak(\"Invalid assignment\");\n            }\n            return left;\n        }\n\n        function expression(no_in, maybe_arrow) {\n            var start = S.token;\n            var exprs = [];\n            while (true) {\n                if (maybe_arrow && is(\"operator\", \"...\")) {\n                    next();\n                    exprs.rest = maybe_destructured(AST_SymbolFunarg);\n                    break;\n                }\n                exprs.push(maybe_assign(no_in));\n                if (!is(\"punc\", \",\")) break;\n                next();\n                if (maybe_arrow && is(\"punc\", \")\") && is_token(peek(), \"punc\", \"=>\")) break;\n            }\n            return exprs.length == 1 && !exprs.rest ? exprs[0] : new AST_Sequence({\n                start: start,\n                expressions: exprs,\n                end: prev(),\n            });\n        }\n\n        function in_loop(cont) {\n            ++S.in_loop;\n            var ret = cont();\n            --S.in_loop;\n            return ret;\n        }\n\n        if (options.expression) {\n            handle_regexp();\n            var exp = expression();\n            expect_token(\"eof\");\n            return exp;\n        }\n\n        return function() {\n            var start = S.token;\n            var body = [];\n            if (options.module) {\n                S.in_async = true;\n                S.input.add_directive(\"use strict\");\n            }\n            S.input.push_directives_stack();\n            while (!is(\"eof\"))\n                body.push(statement(true));\n            S.input.pop_directives_stack();\n            var end = prev() || start;\n            var toplevel = options.toplevel;\n            if (toplevel) {\n                toplevel.body = toplevel.body.concat(body);\n                toplevel.end = end;\n            } else {\n                toplevel = new AST_Toplevel({ start: start, body: body, end: end });\n            }\n            return toplevel;\n        }();\n    }\n\n    m_ast.parse = parse; /// TODO: lwf\n    return {\n        is_identifier_string,\n        is_identifier_char,\n        is_surrogate_pair_head,\n        is_surrogate_pair_tail,\n        tokenizer,\n        parse,\n        KEYWORDS,\n        RESERVED_WORDS,\n        KEYWORDS_BEFORE_EXPRESSION,\n        KEYWORDS_ATOM,\n        UNARY_POSTFIX,\n        PRECEDENCE \n    }\n});"]}