{"version":3,"sources":["parse.js"],"names":["define","m_utils","m_ast","characters","defaults","find_if","makePredicate","set_annotation","configure_error_stack","HOP","all","AST_Accessor","AST_Array","AST_Arrow","AST_Assign","AST_AsyncFunction","AST_AsyncDefun","AST_AsyncArrow","AST_AsyncGeneratorFunction","AST_AsyncGeneratorDefun","AST_Await","AST_BigInt","AST_Binary","AST_BlockStatement","AST_Break","AST_Call","AST_Case","AST_Catch","AST_Chain","AST_ClassExpression","AST_ClassGetter","AST_ClassInit","AST_ClassMethod","AST_ClassPrivateProperty","AST_ClassProperty","AST_ClassStaticBlock","AST_ClassSetter","AST_ConciseMethod","AST_PrivateIn","AST_PrivateGetter","AST_PrivateMethod","AST_PrivateSetter","AST_Conditional","AST_Const","AST_Continue","AST_Debugger","AST_Default","AST_DefaultAssign","AST_DefaultValue","AST_DefClass","AST_Definitions","AST_Defun","AST_Destructured","AST_DestructuredArray","AST_DestructuredKeyVal","AST_DestructuredObject","AST_Destructuring","AST_Directive","AST_Do","AST_Dot","AST_DotHash","AST_EmptyStatement","AST_Expansion","AST_Export","AST_ExportDeclaration","AST_False","AST_Finally","AST_For","AST_ForIn","AST_ForOf","AST_Function","AST_Hole","AST_If","AST_Import","AST_ImportMeta","AST_IterationStatement","AST_Label","AST_LabeledStatement","AST_LabelRef","AST_Let","AST_NameMapping","AST_New","AST_NewTarget","AST_Node","AST_Null","AST_Number","AST_Object","AST_ObjectGetter","AST_ObjectKeyVal","AST_ObjectMethod","AST_ObjectProperty","AST_ObjectSetter","AST_PrefixedTemplateString","AST_PropAccess","AST_RegExp","AST_Return","AST_Sequence","AST_SimpleStatement","AST_Spread","AST_String","AST_Sub","AST_Super","AST_Switch","AST_SymbolCatch","AST_SymbolClass","AST_SymbolClassProperty","AST_SymbolConst","AST_SymbolDeclaration","AST_SymbolDefClass","AST_SymbolDefun","AST_SymbolExport","AST_SymbolExportForeign","AST_SymbolFunarg","AST_SymbolImport","AST_SymbolImportForeign","AST_SymbolLambda","AST_SymbolLet","AST_SymbolMethod","AST_SymbolRef","AST_SymbolVar","AST_Template","AST_TemplateSegment","AST_TemplateString","AST_This","AST_SymbolPrivateProperty","AST_Throw","AST_Token","AST_Toplevel","AST_True","AST_Try","AST_TryBlock","AST_UnaryPostfix","AST_UnaryPrefix","AST_Var","AST_VarDef","AST_While","AST_With","AST_Yield","_INLINE","_NOINLINE","_PURE","_KEY","_MANGLEPROP","KEYWORDS","KEYWORDS_ATOM","RESERVED_WORDS","join","KEYWORDS_BEFORE_EXPRESSION","RE_BIN_NUMBER","RE_HEX_NUMBER","RE_OCT_NUMBER","OPERATORS","NEWLINE_CHARS","OPERATOR_CHARS","PUNC_AFTER_EXPRESSION","PUNC_SEPARATORS","PUNC_BEFORE_EXPRESSION","PUNC_OPENERS","PUNC_CHARS","WHITESPACE_CHARS","NON_IDENTIFIER_CHARS","is_digit","code","is_identifier_char","ch","is_identifier_string","str","test","decode_escape_sequence","seq","slice","length","num","parseInt","isNaN","String","fromCharCode","JS_Parse_Error","message","filename","line","col","pos","this","js_error","is_token","token","type","val","value","prototype","Object","create","Error","constructor","name","EX_EOF","tokenizer","$TEXT","html5_comments","shebang","S","text","tokpos","tokline","tokcol","newline_before","regex_allowed","comments_before","directives","read_template","with_eof_error","strings","s","read","push","peek","next","prev_was_dot","charAt","signal_eof","in_string","forward","i","looking_at","substr","start_token","is_comment","UNARY_POSTFIX","ret","endline","endcol","endpos","nlb","file","raw","substring","comments_after","skip_whitespace","parse_error","err","is_octal","read_num","prefix","has_e","after_e","has_x","has_dot","pred","read_while","next_token","has_directive","replace","valid","match","exec","parseFloat","parse_js_number","toLowerCase","read_escaped_char","p","read_octal_escape_sequence","read_string","quote_char","quote","tok","skip_line_comment","find_eol","skip_multiline_comment","what","indexOf","find","read_name","backslash","escaped","charCodeAt","hex","toString","toUpperCase","read_regexp","source","prev_backslash","in_class","mods","regexp","RegExp","raw_source","e","read_operator","grow","op","bigger","handle_slash","eof_error","cont","x","ex","force_regexp","word","context","nc","add_directive","directive","push_directives_stack","pop_directives_stack","getPrototypeOf","UNARY_PREFIX","ASSIGNMENT","PRECEDENCE","a","b","j","ATOMIC_START_TOKEN","parse","options","bare_returns","expression","module","strict","toplevel","input","in_async","in_directives","in_funarg","in_function","in_generator","in_loop","labels","peeked","prev","is","croak","msg","ctx","token_error","token_to_string","undefined","unexpected","expect_token","expect","punc","has_newline_before","comment","can_insert_semicolon","semicolon","optional","parenthesized","exp","embed_tokens","parser","start","expr","apply","arguments","end","handle_regexp","statement","dir","body","simple_statement","function_","key","alias","is_alias","AST_ExportForeign","aliases","make_string","keys","path","as_path","map","AST_ExportReferences","properties","index","sym","_make_symbol","maybe_named","class_","AST_GeneratorDefun","AST_GeneratorFunction","export_default_decl","AST_ExportDefault","export_decl","export_","def","as_symbol","props","default","import_","is_vardefs","node","let_","label","l","stat","pop","references","forEach","ref","labeled_statement","block_","break_cont","const_","condition","await_token","init","ctor","var_","AST_ForAwaitOf","definitions","is_assignable","to_destructured","obj","object","for_enum","step","regular_for","for_","cond","alt","alternative","if_","switch_body_","bcatch","bfinally","maybe_destructured","argname","try_","ldef","thedef","TYPE","has_modifier","no_nlb","was_async","was_gen","parent","expr_atom","fixed","async","internal","as_property_key","gen_start","gen","static","private","AST_ClassInitBlock","func_start","func","maybe_assign","create_accessor","AST_ClassField","extends","to_funarg","rest","elements","left","right","prop","arrow","exprs","was_funarg","argnames","loop","is_strict","each_argname","strict_verify_symbol","expr_list","maybe_default","branch","cur","default_branch","tmp","vardefs","no_in","allow_calls","call","args","subscripts","new_","template","len","unshift","comments_before_length","expressions","array_","object_","clazz","isFinite","AST_Infinity","operator","as_atom_node","closing","allow_trailing_comma","allow_empty","first","is_gen","no_error","key_start","tag","property","terminal","pure","comments","maybe_unary","nested","make_unary","expr_op","min_precision","precision","maybe_conditional","expr_ops","yes","consequent","maybe_arrow","concat","is_surrogate_pair_head","is_surrogate_pair_tail"],"mappings":";;;;;;;AAAAA,QACI,UACA,SACF,SAASC,EAAQC,GA6Cf,aAEA,MAAMC,WACFA,EAAUC,SACVA,EAAQC,QACRA,EAAOC,cACPA,EAAaC,eACbA,EAAcC,sBACdA,EAAqBC,IACrBA,EAAGC,IACHA,GACAT,GAEEU,aACFA,EAAYC,UACZA,EAASC,UACTA,EAASC,WACTA,EAAUC,kBACVA,EAAiBC,eACjBA,EAAcC,eACdA,EAAcC,2BACdA,EAA0BC,wBAC1BA,EAAuBC,UACvBA,EAASC,WACTA,EAAUC,WACVA,EAAUC,mBACVA,EAAkBC,UAClBA,EAASC,SACTA,EAAQC,SACRA,EAAQC,UACRA,EAASC,UACTA,EAASC,oBACTA,EAAmBC,gBACnBA,EAAeC,cACfA,EAAaC,gBACbA,EAAeC,yBACfA,EAAwBC,kBACxBA,EAAiBC,qBACjBA,EAAoBC,gBACpBA,EAAeC,kBACfA,EAAiBC,cACjBA,EAAaC,kBACbA,EAAiBC,kBACjBA,EAAiBC,kBACjBA,EAAiBC,gBACjBA,EAAeC,UACfA,EAASC,aACTA,EAAYC,aACZA,EAAYC,YACZA,EAAWC,kBACXA,EAAiBC,iBACjBA,EAAgBC,aAChBA,EAAYC,gBACZA,EAAeC,UACfA,EAASC,iBACTA,EAAgBC,sBAChBA,EAAqBC,uBACrBA,EAAsBC,uBACtBA,GAAsBC,kBACtBA,GAAiBC,cACjBA,GAAaC,OACbA,GAAMC,QACNA,GAAOC,YACPA,GAAWC,mBACXA,GAAkBC,cAClBA,GAAaC,WACbA,GAAUC,sBACVA,GAAqBC,UACrBA,GAASC,YACTA,GAAWC,QACXA,GAAOC,UACPA,GAASC,UACTA,GAASC,aACTA,GAAYC,SACZA,GAAQC,OACRA,GAAMC,WACNA,GAAUC,eACVA,GAAcC,uBACdA,GAAsBC,UACtBA,GAASC,qBACTA,GAAoBC,aACpBA,GAAYC,QACZA,GAAOC,gBACPA,GAAeC,QACfA,GAAOC,cACPA,GAAaC,SACbA,GAAQC,SACRA,GAAQC,WACRA,GAAUC,WACVA,GAAUC,iBACVA,GAAgBC,iBAChBA,GAAgBC,iBAChBA,GAAgBC,mBAChBA,GAAkBC,iBAClBA,GAAgBC,2BAChBA,GAA0BC,eAC1BA,GAAcC,WACdA,GAAUC,WACVA,GAAUC,aACVA,GAAYC,oBACZA,GAAmBC,WACnBA,GAAUC,WACVA,GAAUC,QACVA,GAAOC,UACPA,GAASC,WACTA,GAAUC,gBACVA,GAAeC,gBACfA,GAAeC,wBACfA,GAAuBC,gBACvBA,GAAeC,sBACfA,GAAqBC,mBACrBA,GAAkBC,gBAClBA,GAAeC,iBACfA,GAAgBC,wBAChBA,GAAuBC,iBACvBA,GAAgBC,iBAChBA,GAAgBC,wBAChBA,GAAuBC,iBACvBA,GAAgBC,cAChBA,GAAaC,iBACbA,GAAgBC,cAChBA,GAAaC,cACbA,GAAaC,aACbA,GAAYC,oBACZA,GAAmBC,mBACnBA,GAAkBC,SAClBA,GAAQC,0BACRA,GAAyBC,UACzBA,GAASC,UACTA,GAASC,aACTA,GAAYC,SACZA,GAAQC,QACRA,GAAOC,aACPA,GAAYC,iBACZA,GAAgBC,gBAChBA,GAAeC,QACfA,GAAOC,WACPA,GAAUC,UACVA,GAASC,SACTA,GAAQC,UACRA,GAASC,QACTA,GAAOC,UACPA,GAASC,MACTA,GAAKC,KACLA,GAAIC,YACJA,IACA5I,EAEJ,IAAI6I,GAAW,6KACXC,GAAgB,kBAChBC,IACA,mOACAD,GACAD,IACFG,KAAK,KACHC,GAA6B,oCAEjCJ,GAAWzI,EAAcyI,IACzBE,GAAiB3I,EAAc2I,IAC/BE,GAA6B7I,EAAc6I,IAC3CH,GAAgB1I,EAAc0I,IAE9B,IAAII,GAAgB,eAChBC,GAAgB,mBAChBC,GAAgB,iBAEhBC,GAAYjJ,GACZ,KACA,aACA,SACA,MACA,OACA,SACA,KACA,KACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KACA,KACA,KACA,MACA,IACA,IACA,KACA,KACA,KACA,MACA,KACA,MACA,IACA,IACA,KACA,KACA,KACA,KACA,KACA,MACA,MACA,MACA,OACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,MACA,QAGAkJ,GAAgB,mBAChBC,GAAiB,gBAIjB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","file":"../parse.js","sourcesContent":["define([\n    \"./utils\",\n    \"./ast\"\n],function(m_utils,m_ast){\n    /***********************************************************************\n\n      A JavaScript tokenizer / parser / beautifier / compressor.\n      https://github.com/mishoo/UglifyJS\n\n      -------------------------------- (C) ---------------------------------\n\n                               Author: Mihai Bazon\n                             <mihai.bazon@gmail.com>\n                           http://mihai.bazon.net/blog\n\n      Distributed under the BSD license:\n\n        Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n        Parser based on parse-js (http://marijn.haverbeke.nl/parse-js/).\n\n        Redistribution and use in source and binary forms, with or without\n        modification, are permitted provided that the following conditions\n        are met:\n\n            * Redistributions of source code must retain the above\n              copyright notice, this list of conditions and the following\n              disclaimer.\n\n            * Redistributions in binary form must reproduce the above\n              copyright notice, this list of conditions and the following\n              disclaimer in the documentation and/or other materials\n              provided with the distribution.\n\n        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n        EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n        IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n        PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n        LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n        OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n        PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n        PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n        THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n        TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n        THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n        SUCH DAMAGE.\n\n     ***********************************************************************/\n\n    \"use strict\";\n\n    const {\n        characters,\n        defaults,\n        find_if,\n        makePredicate,\n        set_annotation,\n        configure_error_stack,\n        HOP,\n        all\n    } = m_utils;\n\n    const {\n        AST_Accessor,\n        AST_Array,\n        AST_Arrow,\n        AST_Assign,\n        AST_AsyncFunction,\n        AST_AsyncDefun,\n        AST_AsyncArrow,\n        AST_AsyncGeneratorFunction,\n        AST_AsyncGeneratorDefun,\n        AST_Await,\n        AST_BigInt,\n        AST_Binary,\n        AST_BlockStatement,\n        AST_Break,\n        AST_Call,\n        AST_Case,\n        AST_Catch,\n        AST_Chain,\n        AST_ClassExpression,\n        AST_ClassGetter,\n        AST_ClassInit,\n        AST_ClassMethod,\n        AST_ClassPrivateProperty,\n        AST_ClassProperty,\n        AST_ClassStaticBlock,\n        AST_ClassSetter,\n        AST_ConciseMethod,\n        AST_PrivateIn,\n        AST_PrivateGetter,\n        AST_PrivateMethod,\n        AST_PrivateSetter,\n        AST_Conditional,\n        AST_Const,\n        AST_Continue,\n        AST_Debugger,\n        AST_Default,\n        AST_DefaultAssign,\n        AST_DefaultValue,\n        AST_DefClass,\n        AST_Definitions,\n        AST_Defun,\n        AST_Destructured,\n        AST_DestructuredArray,\n        AST_DestructuredKeyVal,\n        AST_DestructuredObject,\n        AST_Destructuring,\n        AST_Directive,\n        AST_Do,\n        AST_Dot,\n        AST_DotHash,\n        AST_EmptyStatement,\n        AST_Expansion,\n        AST_Export,\n        AST_ExportDeclaration,\n        AST_False,\n        AST_Finally,\n        AST_For,\n        AST_ForIn,\n        AST_ForOf,\n        AST_Function,\n        AST_Hole,\n        AST_If,\n        AST_Import,\n        AST_ImportMeta,\n        AST_IterationStatement,\n        AST_Label,\n        AST_LabeledStatement,\n        AST_LabelRef,\n        AST_Let,\n        AST_NameMapping,\n        AST_New,\n        AST_NewTarget,\n        AST_Node,\n        AST_Null,\n        AST_Number,\n        AST_Object,\n        AST_ObjectGetter,\n        AST_ObjectKeyVal,\n        AST_ObjectMethod,\n        AST_ObjectProperty,\n        AST_ObjectSetter,\n        AST_PrefixedTemplateString,\n        AST_PropAccess,\n        AST_RegExp,\n        AST_Return,\n        AST_Sequence,\n        AST_SimpleStatement,\n        AST_Spread,\n        AST_String,\n        AST_Sub,\n        AST_Super,\n        AST_Switch,\n        AST_SymbolCatch,\n        AST_SymbolClass,\n        AST_SymbolClassProperty,\n        AST_SymbolConst,\n        AST_SymbolDeclaration,\n        AST_SymbolDefClass,\n        AST_SymbolDefun,\n        AST_SymbolExport,\n        AST_SymbolExportForeign,\n        AST_SymbolFunarg,\n        AST_SymbolImport,\n        AST_SymbolImportForeign,\n        AST_SymbolLambda,\n        AST_SymbolLet,\n        AST_SymbolMethod,\n        AST_SymbolRef,\n        AST_SymbolVar,\n        AST_Template,\n        AST_TemplateSegment,\n        AST_TemplateString,\n        AST_This,\n        AST_SymbolPrivateProperty,\n        AST_Throw,\n        AST_Token,\n        AST_Toplevel,\n        AST_True,\n        AST_Try,\n        AST_TryBlock,\n        AST_UnaryPostfix,\n        AST_UnaryPrefix,\n        AST_Var,\n        AST_VarDef,\n        AST_While,\n        AST_With,\n        AST_Yield,\n        _INLINE,\n        _NOINLINE,\n        _PURE,\n        _KEY,\n        _MANGLEPROP,\n    } = m_ast;\n\n    var KEYWORDS = \"break case catch class const continue debugger default delete do else extends finally for function if in instanceof new return switch throw try typeof var void while with\";\n    var KEYWORDS_ATOM = \"false null true\";\n    var RESERVED_WORDS = [\n        \"abstract async await boolean byte char double enum export final float goto implements import int interface let long native package private protected public short static super synchronized this throws transient volatile yield\",\n        KEYWORDS_ATOM,\n        KEYWORDS,\n    ].join(\" \");\n    var KEYWORDS_BEFORE_EXPRESSION = \"return new delete throw else case\";\n\n    KEYWORDS = makePredicate(KEYWORDS);\n    RESERVED_WORDS = makePredicate(RESERVED_WORDS);\n    KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);\n    KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);\n\n    var RE_BIN_NUMBER = /^0b([01]+)$/i;\n    var RE_HEX_NUMBER = /^0x([0-9a-f]+)$/i;\n    var RE_OCT_NUMBER = /^0o?([0-7]+)$/i;\n\n    var OPERATORS = makePredicate([\n        \"in\",\n        \"instanceof\",\n        \"typeof\",\n        \"new\",\n        \"void\",\n        \"delete\",\n        \"++\",\n        \"--\",\n        \"+\",\n        \"-\",\n        \"!\",\n        \"~\",\n        \"&\",\n        \"|\",\n        \"^\",\n        \"*\",\n        \"/\",\n        \"%\",\n        \"**\",\n        \">>\",\n        \"<<\",\n        \">>>\",\n        \"<\",\n        \">\",\n        \"<=\",\n        \">=\",\n        \"==\",\n        \"===\",\n        \"!=\",\n        \"!==\",\n        \"?\",\n        \"=\",\n        \"+=\",\n        \"-=\",\n        \"/=\",\n        \"*=\",\n        \"%=\",\n        \"**=\",\n        \">>=\",\n        \"<<=\",\n        \">>>=\",\n        \"&=\",\n        \"|=\",\n        \"^=\",\n        \"&&\",\n        \"||\",\n        \"??\",\n        \"&&=\",\n        \"||=\",\n        \"??=\",\n    ]);\n\n    var NEWLINE_CHARS = \"\\n\\r\\u2028\\u2029\";\n    var OPERATOR_CHARS = \"+-*&%=<>!?|~^\";\n    var PUNC_OPENERS = \"[{(\";\n    var PUNC_SEPARATORS = \",;:\";\n    var PUNC_CLOSERS = \")}]\";\n    var PUNC_AFTER_EXPRESSION = PUNC_SEPARATORS + PUNC_CLOSERS;\n    var PUNC_BEFORE_EXPRESSION = PUNC_OPENERS + PUNC_SEPARATORS;\n    var PUNC_CHARS = PUNC_BEFORE_EXPRESSION + \"`\" + PUNC_CLOSERS;\n    var WHITESPACE_CHARS = NEWLINE_CHARS + \" \\u00a0\\t\\f\\u000b\\u200b\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\uFEFF\";\n    var NON_IDENTIFIER_CHARS = makePredicate(characters(\"./'\\\"#\" + OPERATOR_CHARS + PUNC_CHARS + WHITESPACE_CHARS));\n\n    NEWLINE_CHARS = makePredicate(characters(NEWLINE_CHARS));\n    OPERATOR_CHARS = makePredicate(characters(OPERATOR_CHARS));\n    PUNC_AFTER_EXPRESSION = makePredicate(characters(PUNC_AFTER_EXPRESSION));\n    PUNC_BEFORE_EXPRESSION = makePredicate(characters(PUNC_BEFORE_EXPRESSION));\n    PUNC_CHARS = makePredicate(characters(PUNC_CHARS));\n    WHITESPACE_CHARS = makePredicate(characters(WHITESPACE_CHARS));\n\n    /* -----[ Tokenizer ]----- */\n\n    function is_surrogate_pair_head(code) {\n        return code >= 0xd800 && code <= 0xdbff;\n    }\n\n    function is_surrogate_pair_tail(code) {\n        return code >= 0xdc00 && code <= 0xdfff;\n    }\n\n    function is_digit(code) {\n        return code >= 48 && code <= 57;\n    }\n\n    function is_identifier_char(ch) {\n        return !NON_IDENTIFIER_CHARS[ch];\n    }\n\n    function is_identifier_string(str) {\n        return /^[a-z_$][a-z0-9_$]*$/i.test(str);\n    }\n\n    function decode_escape_sequence(seq) {\n        switch (seq[0]) {\n          case \"b\": return \"\\b\";\n          case \"f\": return \"\\f\";\n          case \"n\": return \"\\n\";\n          case \"r\": return \"\\r\";\n          case \"t\": return \"\\t\";\n          case \"u\":\n            var code;\n            if (seq[1] == \"{\" && seq.slice(-1) == \"}\") {\n                code = seq.slice(2, -1);\n            } else if (seq.length == 5) {\n                code = seq.slice(1);\n            } else {\n                return;\n            }\n            var num = parseInt(code, 16);\n            if (num < 0 || isNaN(num)) return;\n            if (num < 0x10000) return String.fromCharCode(num);\n            if (num > 0x10ffff) return;\n            return String.fromCharCode((num >> 10) + 0xd7c0) + String.fromCharCode((num & 0x03ff) + 0xdc00);\n          case \"v\": return \"\\u000b\";\n          case \"x\":\n            if (seq.length != 3) return;\n            var num = parseInt(seq.slice(1), 16);\n            if (num < 0 || isNaN(num)) return;\n            return String.fromCharCode(num);\n          case \"\\r\":\n          case \"\\n\":\n            return \"\";\n          default:\n            if (seq == \"0\") return \"\\0\";\n            if (seq[0] >= \"0\" && seq[0] <= \"9\") return;\n            return seq;\n        }\n    }\n\n    function parse_js_number(num) {\n        var match;\n        if (match = RE_BIN_NUMBER.exec(num)) return parseInt(match[1], 2);\n        if (match = RE_HEX_NUMBER.exec(num)) return parseInt(match[1], 16);\n        if (match = RE_OCT_NUMBER.exec(num)) return parseInt(match[1], 8);\n        var val = parseFloat(num);\n        if (val == num) return val;\n    }\n\n    function JS_Parse_Error(message, filename, line, col, pos) {\n        this.message = message;\n        this.filename = filename;\n        this.line = line;\n        this.col = col;\n        this.pos = pos;\n    }\n    JS_Parse_Error.prototype = Object.create(Error.prototype);\n    JS_Parse_Error.prototype.constructor = JS_Parse_Error;\n    JS_Parse_Error.prototype.name = \"SyntaxError\";\n    configure_error_stack(JS_Parse_Error);\n\n    function js_error(message, filename, line, col, pos) {\n        throw new JS_Parse_Error(message, filename, line, col, pos);\n    }\n\n    function is_token(token, type, val) {\n        return token.type == type && (val == null || token.value == val);\n    }\n\n    var EX_EOF = {};\n\n    function tokenizer($TEXT, filename, html5_comments, shebang) {\n\n        var S = {\n            text            : $TEXT,\n            filename        : filename,\n            pos             : 0,\n            tokpos          : 0,\n            line            : 1,\n            tokline         : 0,\n            col             : 0,\n            tokcol          : 0,\n            newline_before  : false,\n            regex_allowed   : false,\n            comments_before : [],\n            directives      : Object.create(null),\n            read_template   : with_eof_error(\"Unterminated template literal\", function(strings) {\n                var s = \"\";\n                for (;;) {\n                    var ch = read();\n                    switch (ch) {\n                      case \"\\\\\":\n                        ch += read();\n                        break;\n                      case \"`\":\n                        strings.push(s);\n                        return;\n                      case \"$\":\n                        if (peek() == \"{\") {\n                            next();\n                            strings.push(s);\n                            S.regex_allowed = true;\n                            return true;\n                        }\n                    }\n                    s += ch;\n                }\n\n                function read() {\n                    var ch = next(true, true);\n                    return ch == \"\\r\" ? \"\\n\" : ch;\n                }\n            }),\n        };\n        var prev_was_dot = false;\n\n        function peek() {\n            return S.text.charAt(S.pos);\n        }\n\n        function next(signal_eof, in_string) {\n            var ch = S.text.charAt(S.pos++);\n            if (signal_eof && !ch)\n                throw EX_EOF;\n            if (NEWLINE_CHARS[ch]) {\n                S.col = 0;\n                S.line++;\n                if (!in_string) S.newline_before = true;\n                if (ch == \"\\r\" && peek() == \"\\n\") {\n                    // treat `\\r\\n` as `\\n`\n                    S.pos++;\n                    ch = \"\\n\";\n                }\n            } else {\n                S.col++;\n            }\n            return ch;\n        }\n\n        function forward(i) {\n            while (i-- > 0) next();\n        }\n\n        function looking_at(str) {\n            return S.text.substr(S.pos, str.length) == str;\n        }\n\n        function find_eol() {\n            var text = S.text;\n            for (var i = S.pos; i < S.text.length; ++i) {\n                if (NEWLINE_CHARS[text[i]]) return i;\n            }\n            return -1;\n        }\n\n        function find(what, signal_eof) {\n            var pos = S.text.indexOf(what, S.pos);\n            if (signal_eof && pos == -1) throw EX_EOF;\n            return pos;\n        }\n\n        function start_token() {\n            S.tokline = S.line;\n            S.tokcol = S.col;\n            S.tokpos = S.pos;\n        }\n\n        function token(type, value, is_comment) {\n            S.regex_allowed = type == \"operator\" && !UNARY_POSTFIX[value]\n                || type == \"keyword\" && KEYWORDS_BEFORE_EXPRESSION[value]\n                || type == \"punc\" && PUNC_BEFORE_EXPRESSION[value];\n            if (type == \"punc\" && value == \".\") prev_was_dot = true;\n            else if (!is_comment) prev_was_dot = false;\n            var ret = {\n                type    : type,\n                value   : value,\n                line    : S.tokline,\n                col     : S.tokcol,\n                pos     : S.tokpos,\n                endline : S.line,\n                endcol  : S.col,\n                endpos  : S.pos,\n                nlb     : S.newline_before,\n                file    : filename\n            };\n            if (/^(?:num|string|regexp)$/i.test(type)) {\n                ret.raw = $TEXT.substring(ret.pos, ret.endpos);\n            }\n            if (!is_comment) {\n                ret.comments_before = S.comments_before;\n                ret.comments_after = S.comments_before = [];\n            }\n            S.newline_before = false;\n            return new AST_Token(ret);\n        }\n\n        function skip_whitespace() {\n            while (WHITESPACE_CHARS[peek()])\n                next();\n        }\n\n        function read_while(pred) {\n            var ret = \"\", ch;\n            while ((ch = peek()) && pred(ch, ret)) ret += next();\n            return ret;\n        }\n\n        function parse_error(err) {\n            js_error(err, filename, S.tokline, S.tokcol, S.tokpos);\n        }\n\n        function is_octal(num) {\n            return /^0[0-7_]+$/.test(num);\n        }\n\n        function read_num(prefix) {\n            var has_e = false, after_e = false, has_x = false, has_dot = prefix == \".\";\n            var num = read_while(function(ch, str) {\n                switch (ch) {\n                  case \"x\": case \"X\":\n                    return has_x ? false : (has_x = true);\n                  case \"e\": case \"E\":\n                    return has_x ? true : has_e ? false : (has_e = after_e = true);\n                  case \"+\": case \"-\":\n                    return after_e;\n                  case (after_e = false, \".\"):\n                    return has_dot || has_e || has_x || is_octal(str) ? false : (has_dot = true);\n                }\n                return /[_0-9a-dfo]/i.test(ch);\n            });\n            if (prefix) num = prefix + num;\n            if (is_octal(num)) {\n                if (next_token.has_directive(\"use strict\")) parse_error(\"Legacy octal literals are not allowed in strict mode\");\n            } else {\n                num = num.replace(has_x ? /([1-9a-f]|.0)_(?=[0-9a-f])/gi : /([1-9]|.0)_(?=[0-9])/gi, \"$1\");\n            }\n            var valid = parse_js_number(num);\n            if (isNaN(valid)) parse_error(\"Invalid syntax: \" + num);\n            if (has_dot || has_e || peek() != \"n\") return token(\"num\", valid);\n            return token(\"bigint\", num.toLowerCase() + next());\n        }\n\n        function read_escaped_char(in_string) {\n            var seq = next(true, in_string);\n            if (seq >= \"0\" && seq <= \"7\") return read_octal_escape_sequence(seq);\n            if (seq == \"u\") {\n                var ch = next(true, in_string);\n                seq += ch;\n                if (ch != \"{\") {\n                    seq += next(true, in_string) + next(true, in_string) + next(true, in_string);\n                } else do {\n                    ch = next(true, in_string);\n                    seq += ch;\n                } while (ch != \"}\");\n            } else if (seq == \"x\") {\n                seq += next(true, in_string) + next(true, in_string);\n            }\n            var str = decode_escape_sequence(seq);\n            if (typeof str != \"string\") parse_error(\"Invalid escape sequence: \\\\\" + seq);\n            return str;\n        }\n\n        function read_octal_escape_sequence(ch) {\n            // Read\n            var p = peek();\n            if (p >= \"0\" && p <= \"7\") {\n                ch += next(true);\n                if (ch[0] <= \"3\" && (p = peek()) >= \"0\" && p <= \"7\")\n                    ch += next(true);\n            }\n\n            // Parse\n            if (ch === \"0\") return \"\\0\";\n            if (ch.length > 0 && next_token.has_directive(\"use strict\"))\n                parse_error(\"Legacy octal escape sequences are not allowed in strict mode\");\n            return String.fromCharCode(parseInt(ch, 8));\n        }\n\n        var read_string = with_eof_error(\"Unterminated string constant\", function(quote_char) {\n            var quote = next(), ret = \"\";\n            for (;;) {\n                var ch = next(true, true);\n                if (ch == \"\\\\\") ch = read_escaped_char(true);\n                else if (NEWLINE_CHARS[ch]) parse_error(\"Unterminated string constant\");\n                else if (ch == quote) break;\n                ret += ch;\n            }\n            var tok = token(\"string\", ret);\n            tok.quote = quote_char;\n            return tok;\n        });\n\n        function skip_line_comment(type) {\n            var regex_allowed = S.regex_allowed;\n            var i = find_eol(), ret;\n            if (i == -1) {\n                ret = S.text.substr(S.pos);\n                S.pos = S.text.length;\n            } else {\n                ret = S.text.substring(S.pos, i);\n                S.pos = i;\n            }\n            S.col = S.tokcol + (S.pos - S.tokpos);\n            S.comments_before.push(token(type, ret, true));\n            S.regex_allowed = regex_allowed;\n            return next_token;\n        }\n\n        var skip_multiline_comment = with_eof_error(\"Unterminated multiline comment\", function() {\n            var regex_allowed = S.regex_allowed;\n            var i = find(\"*/\", true);\n            var text = S.text.substring(S.pos, i).replace(/\\r\\n|\\r|\\u2028|\\u2029/g, \"\\n\");\n            // update stream position\n            forward(text.length /* doesn't count \\r\\n as 2 char while S.pos - i does */ + 2);\n            S.comments_before.push(token(\"comment2\", text, true));\n            S.regex_allowed = regex_allowed;\n            return next_token;\n        });\n\n        function read_name() {\n            var backslash = false, ch, escaped = false, name = peek() == \"#\" ? next() : \"\";\n            while (ch = peek()) {\n                if (!backslash) {\n                    if (ch == \"\\\\\") escaped = backslash = true, next();\n                    else if (is_identifier_char(ch)) name += next();\n                    else break;\n                } else {\n                    if (ch != \"u\") parse_error(\"Expecting UnicodeEscapeSequence -- uXXXX\");\n                    ch = read_escaped_char();\n                    if (!is_identifier_char(ch)) parse_error(\"Unicode char: \" + ch.charCodeAt(0) + \" is not valid in identifier\");\n                    name += ch;\n                    backslash = false;\n                }\n            }\n            if (KEYWORDS[name] && escaped) {\n                var hex = name.charCodeAt(0).toString(16).toUpperCase();\n                name = \"\\\\u\" + \"0000\".substr(hex.length) + hex + name.slice(1);\n            }\n            return name;\n        }\n\n        var read_regexp = with_eof_error(\"Unterminated regular expression\", function(source) {\n            var prev_backslash = false, ch, in_class = false;\n            while ((ch = next(true))) if (NEWLINE_CHARS[ch]) {\n                parse_error(\"Unexpected line terminator\");\n            } else if (prev_backslash) {\n                source += \"\\\\\" + ch;\n                prev_backslash = false;\n            } else if (ch == \"[\") {\n                in_class = true;\n                source += ch;\n            } else if (ch == \"]\" && in_class) {\n                in_class = false;\n                source += ch;\n            } else if (ch == \"/\" && !in_class) {\n                break;\n            } else if (ch == \"\\\\\") {\n                prev_backslash = true;\n            } else {\n                source += ch;\n            }\n            var mods = read_name();\n            try {\n                var regexp = new RegExp(source, mods);\n                regexp.raw_source = source;\n                return token(\"regexp\", regexp);\n            } catch (e) {\n                parse_error(e.message);\n            }\n        });\n\n        function read_operator(prefix) {\n            function grow(op) {\n                if (!peek()) return op;\n                var bigger = op + peek();\n                if (OPERATORS[bigger]) {\n                    next();\n                    return grow(bigger);\n                } else {\n                    return op;\n                }\n            }\n            return token(\"operator\", grow(prefix || next()));\n        }\n\n        function handle_slash() {\n            next();\n            switch (peek()) {\n              case \"/\":\n                next();\n                return skip_line_comment(\"comment1\");\n              case \"*\":\n                next();\n                return skip_multiline_comment();\n            }\n            return S.regex_allowed ? read_regexp(\"\") : read_operator(\"/\");\n        }\n\n        function handle_dot() {\n            next();\n            if (looking_at(\"..\")) return token(\"operator\", \".\" + next() + next());\n            return is_digit(peek().charCodeAt(0)) ? read_num(\".\") : token(\"punc\", \".\");\n        }\n\n        function read_word() {\n            var word = read_name();\n            if (prev_was_dot) return token(\"name\", word);\n            return KEYWORDS_ATOM[word] ? token(\"atom\", word)\n                : !KEYWORDS[word] ? token(\"name\", word)\n                : OPERATORS[word] ? token(\"operator\", word)\n                : token(\"keyword\", word);\n        }\n\n        function with_eof_error(eof_error, cont) {\n            return function(x) {\n                try {\n                    return cont(x);\n                } catch (ex) {\n                    if (ex === EX_EOF) parse_error(eof_error);\n                    else throw ex;\n                }\n            };\n        }\n\n        function next_token(force_regexp) {\n            if (force_regexp != null)\n                return read_regexp(force_regexp);\n            if (shebang && S.pos == 0 && looking_at(\"#!\")) {\n                start_token();\n                forward(2);\n                skip_line_comment(\"comment5\");\n            }\n            for (;;) {\n                skip_whitespace();\n                start_token();\n                if (html5_comments) {\n                    if (looking_at(\"<!--\")) {\n                        forward(4);\n                        skip_line_comment(\"comment3\");\n                        continue;\n                    }\n                    if (looking_at(\"-->\") && S.newline_before) {\n                        forward(3);\n                        skip_line_comment(\"comment4\");\n                        continue;\n                    }\n                }\n                var ch = peek();\n                if (!ch) return token(\"eof\");\n                var code = ch.charCodeAt(0);\n                switch (code) {\n                  case 34: case 39: return read_string(ch);\n                  case 46: return handle_dot();\n                  case 47:\n                    var tok = handle_slash();\n                    if (tok === next_token) continue;\n                    return tok;\n                }\n                if (is_digit(code)) return read_num();\n                if (PUNC_CHARS[ch]) return token(\"punc\", next());\n                if (looking_at(\"=>\")) return token(\"punc\", next() + next());\n                if (OPERATOR_CHARS[ch]) return read_operator();\n                if (code == 35 || code == 92 || !NON_IDENTIFIER_CHARS[ch]) return read_word();\n                break;\n            }\n            parse_error(\"Unexpected character '\" + ch + \"'\");\n        }\n\n        next_token.context = function(nc) {\n            if (nc) S = nc;\n            return S;\n        };\n\n        next_token.add_directive = function(directive) {\n            S.directives[directive] = true;\n        }\n\n        next_token.push_directives_stack = function() {\n            S.directives = Object.create(S.directives);\n        }\n\n        next_token.pop_directives_stack = function() {\n            S.directives = Object.getPrototypeOf(S.directives);\n        }\n\n        next_token.has_directive = function(directive) {\n            return !!S.directives[directive];\n        }\n\n        return next_token;\n    }\n\n    /* -----[ Parser (constants) ]----- */\n\n    var UNARY_PREFIX = makePredicate(\"typeof void delete -- ++ ! ~ - +\");\n\n    var UNARY_POSTFIX = makePredicate(\"-- ++\");\n\n    var ASSIGNMENT = makePredicate(\"= += -= /= *= %= **= >>= <<= >>>= &= |= ^= &&= ||= ??=\");\n\n    var PRECEDENCE = function(a, ret) {\n        for (var i = 0; i < a.length;) {\n            var b = a[i++];\n            for (var j = 0; j < b.length; j++) {\n                ret[b[j]] = i;\n            }\n        }\n        return ret;\n    }([\n        [\"??\"],\n        [\"||\"],\n        [\"&&\"],\n        [\"|\"],\n        [\"^\"],\n        [\"&\"],\n        [\"==\", \"===\", \"!=\", \"!==\"],\n        [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n        [\">>\", \"<<\", \">>>\"],\n        [\"+\", \"-\"],\n        [\"*\", \"/\", \"%\"],\n        [\"**\"],\n    ], {});\n\n    var ATOMIC_START_TOKEN = makePredicate(\"atom bigint num regexp string\");\n\n    /* -----[ Parser ]----- */\n\n    function parse($TEXT, options) {\n        options = defaults(options, {\n            bare_returns   : false,\n            expression     : false,\n            filename       : null,\n            html5_comments : true,\n            module         : false,\n            shebang        : true,\n            strict         : false,\n            toplevel       : null,\n        }, true);\n\n        var S = {\n            input         : typeof $TEXT == \"string\"\n                            ? tokenizer($TEXT, options.filename, options.html5_comments, options.shebang)\n                            : $TEXT,\n            in_async      : false,\n            in_directives : true,\n            in_funarg     : -1,\n            in_function   : 0,\n            in_generator  : false,\n            in_loop       : 0,\n            labels        : [],\n            peeked        : null,\n            prev          : null,\n            token         : null,\n        };\n\n        S.token = next();\n\n        function is(type, value) {\n            return is_token(S.token, type, value);\n        }\n\n        function peek() {\n            return S.peeked || (S.peeked = S.input());\n        }\n\n        function next() {\n            S.prev = S.token;\n            if (S.peeked) {\n                S.token = S.peeked;\n                S.peeked = null;\n            } else {\n                S.token = S.input();\n            }\n            S.in_directives = S.in_directives && (\n                S.token.type == \"string\" || is(\"punc\", \";\")\n            );\n            return S.token;\n        }\n\n        function prev() {\n            return S.prev;\n        }\n\n        function croak(msg, line, col, pos) {\n            var ctx = S.input.context();\n            js_error(msg,\n                     ctx.filename,\n                     line != null ? line : ctx.tokline,\n                     col != null ? col : ctx.tokcol,\n                     pos != null ? pos : ctx.tokpos);\n        }\n\n        function token_error(token, msg) {\n            croak(msg, token.line, token.col);\n        }\n\n        function token_to_string(type, value) {\n            return type + (value === undefined ? \"\" : \" «\" + value + \"»\");\n        }\n\n        function unexpected(token) {\n            if (token == null) token = S.token;\n            token_error(token, \"Unexpected token: \" + token_to_string(token.type, token.value));\n        }\n\n        function expect_token(type, val) {\n            if (is(type, val)) return next();\n            token_error(S.token, \"Unexpected token: \" + token_to_string(S.token.type, S.token.value) + \", expected: \" + token_to_string(type, val));\n        }\n\n        function expect(punc) {\n            return expect_token(\"punc\", punc);\n        }\n\n        function has_newline_before(token) {\n            return token.nlb || !all(token.comments_before, function(comment) {\n                return !comment.nlb;\n            });\n        }\n\n        function can_insert_semicolon() {\n            return !options.strict\n                && (is(\"eof\") || is(\"punc\", \"}\") || has_newline_before(S.token));\n        }\n\n        function semicolon(optional) {\n            if (is(\"punc\", \";\")) next();\n            else if (!optional && !can_insert_semicolon()) expect(\";\");\n        }\n\n        function parenthesized() {\n            expect(\"(\");\n            var exp = expression();\n            expect(\")\");\n            return exp;\n        }\n\n        function embed_tokens(parser) {\n            return function() {\n                var start = S.token;\n                var expr = parser.apply(null, arguments);\n                var end = prev();\n                expr.start = start;\n                expr.end = end;\n                return expr;\n            };\n        }\n\n        function handle_regexp() {\n            if (is(\"operator\", \"/\") || is(\"operator\", \"/=\")) {\n                S.peeked = null;\n                S.token = S.input(S.token.value.substr(1)); // force regexp\n            }\n        }\n\n        var statement = embed_tokens(function(toplevel) {\n            handle_regexp();\n            switch (S.token.type) {\n              case \"string\":\n                var dir = S.in_directives;\n                var body = expression();\n                if (dir) {\n                    if (body instanceof AST_String) {\n                        var value = body.start.raw.slice(1, -1);\n                        S.input.add_directive(value);\n                        body.value = value;\n                    } else {\n                        S.in_directives = dir = false;\n                    }\n                }\n                semicolon();\n                return dir ? new AST_Directive(body) : new AST_SimpleStatement({ body: body });\n              case \"num\":\n              case \"bigint\":\n              case \"regexp\":\n              case \"operator\":\n              case \"atom\":\n                return simple_statement();\n\n              case \"name\":\n                switch (S.token.value) {\n                  case \"async\":\n                    if (is_token(peek(), \"keyword\", \"function\")) {\n                        next();\n                        next();\n                        if (!is(\"operator\", \"*\")) return function_(AST_AsyncDefun);\n                        next();\n                        return function_(AST_AsyncGeneratorDefun);\n                    }\n                    break;\n                  case \"await\":\n                    if (S.in_async) return simple_statement();\n                    break;\n                  case \"export\":\n                    if (!toplevel && options.module !== \"\") unexpected();\n                    next();\n                    return export_();\n                  case \"import\":\n                    var token = peek();\n                    if (token.type == \"punc\" && /^[(.]$/.test(token.value)) break;\n                    if (!toplevel && options.module !== \"\") unexpected();\n                    next();\n                    return import_();\n                  case \"let\":\n                    if (is_vardefs()) {\n                        next();\n                        var node = let_();\n                        semicolon();\n                        return node;\n                    }\n                    break;\n                  case \"yield\":\n                    if (S.in_generator) return simple_statement();\n                    break;\n                }\n                return is_token(peek(), \"punc\", \":\")\n                    ? labeled_statement()\n                    : simple_statement();\n\n              case \"punc\":\n                switch (S.token.value) {\n                  case \"{\":\n                    return new AST_BlockStatement({\n                        start : S.token,\n                        body  : block_(),\n                        end   : prev()\n                    });\n                  case \"[\":\n                  case \"(\":\n                  case \"`\":\n                    return simple_statement();\n                  case \";\":\n                    S.in_directives = false;\n                    next();\n                    return new AST_EmptyStatement();\n                  default:\n                    unexpected();\n                }\n\n              case \"keyword\":\n                switch (S.token.value) {\n                  case \"break\":\n                    next();\n                    return break_cont(AST_Break);\n\n                  case \"class\":\n                    next();\n                    return class_(AST_DefClass);\n\n                  case \"const\":\n                    next();\n                    var node = const_();\n                    semicolon();\n                    return node;\n\n                  case \"continue\":\n                    next();\n                    return break_cont(AST_Continue);\n\n                  case \"debugger\":\n                    next();\n                    semicolon();\n                    return new AST_Debugger();\n\n                  case \"do\":\n                    next();\n                    var body = in_loop(statement);\n                    expect_token(\"keyword\", \"while\");\n                    var condition = parenthesized();\n                    semicolon(true);\n                    return new AST_Do({\n                        body      : body,\n                        condition : condition,\n                    });\n\n                  case \"while\":\n                    next();\n                    return new AST_While({\n                        condition : parenthesized(),\n                        body      : in_loop(statement),\n                    });\n\n                  case \"for\":\n                    next();\n                    return for_();\n\n                  case \"function\":\n                    next();\n                    if (!is(\"operator\", \"*\")) return function_(AST_Defun);\n                    next();\n                    return function_(AST_GeneratorDefun);\n\n                  case \"if\":\n                    next();\n                    return if_();\n\n                  case \"return\":\n                    if (S.in_function == 0 && !options.bare_returns)\n                        croak(\"'return' outside of function\");\n                    next();\n                    var value = null;\n                    if (is(\"punc\", \";\")) {\n                        next();\n                    } else if (!can_insert_semicolon()) {\n                        value = expression();\n                        semicolon();\n                    }\n                    return new AST_Return({ value: value });\n\n                  case \"switch\":\n                    next();\n                    return new AST_Switch({\n                        expression : parenthesized(),\n                        body       : in_loop(switch_body_),\n                    });\n\n                  case \"throw\":\n                    next();\n                    if (has_newline_before(S.token))\n                        croak(\"Illegal newline after 'throw'\");\n                    var value = expression();\n                    semicolon();\n                    return new AST_Throw({ value: value });\n\n                  case \"try\":\n                    next();\n                    return try_();\n\n                  case \"var\":\n                    next();\n                    var node = var_();\n                    semicolon();\n                    return node;\n\n                  case \"with\":\n                    if (S.input.has_directive(\"use strict\")) {\n                        croak(\"Strict mode may not include a with statement\");\n                    }\n                    next();\n                    return new AST_With({\n                        expression : parenthesized(),\n                        body       : statement(),\n                    });\n                }\n            }\n            unexpected();\n        });\n\n        function labeled_statement() {\n            var label = as_symbol(AST_Label);\n            if (!all(S.labels, function(l) {\n                return l.name != label.name;\n            })) {\n                // ECMA-262, 12.12: An ECMAScript program is considered\n                // syntactically incorrect if it contains a\n                // LabelledStatement that is enclosed by a\n                // LabelledStatement with the same Identifier as label.\n                croak(\"Label \" + label.name + \" defined twice\");\n            }\n            expect(\":\");\n            S.labels.push(label);\n            var stat = statement();\n            S.labels.pop();\n            if (!(stat instanceof AST_IterationStatement)) {\n                // check for `continue` that refers to this label.\n                // those should be reported as syntax errors.\n                // https://github.com/mishoo/UglifyJS/issues/287\n                label.references.forEach(function(ref) {\n                    if (ref instanceof AST_Continue) {\n                        token_error(ref.label.start, \"Continue label `\" + label.name + \"` must refer to IterationStatement\");\n                    }\n                });\n            }\n            return new AST_LabeledStatement({ body: stat, label: label });\n        }\n\n        function simple_statement() {\n            var body = expression();\n            semicolon();\n            return new AST_SimpleStatement({ body: body });\n        }\n\n        function break_cont(type) {\n            var label = null, ldef;\n            if (!can_insert_semicolon()) {\n                label = as_symbol(AST_LabelRef, true);\n            }\n            if (label != null) {\n                ldef = find_if(function(l) {\n                    return l.name == label.name;\n                }, S.labels);\n                if (!ldef) token_error(label.start, \"Undefined label \" + label.name);\n                label.thedef = ldef;\n            } else if (S.in_loop == 0) croak(type.TYPE + \" not inside a loop or switch\");\n            semicolon();\n            var stat = new type({ label: label });\n            if (ldef) ldef.references.push(stat);\n            return stat;\n        }\n\n        function has_modifier(name, no_nlb) {\n            if (!is(\"name\", name)) return;\n            var token = peek();\n            if (!token) return;\n            if (is_token(token, \"operator\", \"=\")) return;\n            if (token.type == \"punc\" && /^[(;}]$/.test(token.value)) return;\n            if (no_nlb && has_newline_before(token)) return;\n            return next();\n        }\n\n        function class_(ctor) {\n            var was_async = S.in_async;\n            var was_gen = S.in_generator;\n            S.input.push_directives_stack();\n            S.input.add_directive(\"use strict\");\n            var name;\n            if (ctor === AST_DefClass) {\n                name = as_symbol(AST_SymbolDefClass);\n            } else {\n                name = as_symbol(AST_SymbolClass, true);\n            }\n            var parent = null;\n            if (is(\"keyword\", \"extends\")) {\n                next();\n                handle_regexp();\n                parent = expr_atom(true);\n            }\n            expect(\"{\");\n            var props = [];\n            while (!is(\"punc\", \"}\")) {\n                if (is(\"punc\", \";\")) {\n                    next();\n                    continue;\n                }\n                var start = S.token;\n                var fixed = !!has_modifier(\"static\");\n                var async = has_modifier(\"async\", true);\n                if (is(\"operator\", \"*\")) {\n                    next();\n                    var internal = is(\"name\") && /^#/.test(S.token.value);\n                    var key = as_property_key();\n                    var gen_start = S.token;\n                    var gen = function_(async ? AST_AsyncGeneratorFunction : AST_GeneratorFunction);\n                    gen.start = gen_start;\n                    gen.end = prev();\n                    props.push(new AST_ClassMethod({\n                        start: start,\n                        static: fixed,\n                        private: internal,\n                        key: key,\n                        value: gen,\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                if (fixed && is(\"punc\", \"{\")) {\n                    props.push(new AST_ClassInit({\n                        start: start,\n                        value: new AST_ClassInitBlock({\n                            start: start,\n                            body: block_(),\n                            end: prev(),\n                        }),\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                var internal = is(\"name\") && /^#/.test(S.token.value);\n                var key = as_property_key();\n                if (is(\"punc\", \"(\")) {\n                    var func_start = S.token;\n                    var func = function_(async ? AST_AsyncFunction : AST_Function);\n                    func.start = func_start;\n                    func.end = prev();\n                    props.push(new AST_ClassMethod({\n                        start: start,\n                        static: fixed,\n                        private: internal,\n                        key: key,\n                        value: func,\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                if (async) unexpected(async);\n                var value = null;\n                if (is(\"operator\", \"=\")) {\n                    next();\n                    S.in_async = false;\n                    S.in_generator = false;\n                    value = maybe_assign();\n                    S.in_generator = was_gen;\n                    S.in_async = was_async;\n                } else if (!(is(\"punc\", \";\") || is(\"punc\", \"}\"))) {\n                    var type = null;\n                    switch (key) {\n                      case \"get\":\n                        type = AST_ClassGetter;\n                        break;\n                      case \"set\":\n                        type = AST_ClassSetter;\n                        break;\n                    }\n                    if (type) {\n                        props.push(new type({\n                            start: start,\n                            static: fixed,\n                            private: is(\"name\") && /^#/.test(S.token.value),\n                            key: as_property_key(),\n                            value: create_accessor(),\n                            end: prev(),\n                        }));\n                        continue;\n                    }\n                }\n                semicolon();\n                props.push(new AST_ClassField({\n                    start: start,\n                    static: fixed,\n                    private: internal,\n                    key: key,\n                    value: value,\n                    end: prev(),\n                }));\n            }\n            next();\n            S.input.pop_directives_stack();\n            S.in_generator = was_gen;\n            S.in_async = was_async;\n            return new ctor({\n                extends: parent,\n                name: name,\n                properties: props,\n            });\n        }\n\n        function for_() {\n            var await_token = is(\"name\", \"await\") && next();\n            expect(\"(\");\n            var init = null;\n            if (await_token || !is(\"punc\", \";\")) {\n                init = is(\"keyword\", \"const\")\n                    ? (next(), const_(true))\n                    : is(\"name\", \"let\") && is_vardefs()\n                    ? (next(), let_(true))\n                    : is(\"keyword\", \"var\")\n                    ? (next(), var_(true))\n                    : expression(true);\n                var ctor;\n                if (await_token) {\n                    expect_token(\"name\", \"of\");\n                    ctor = AST_ForAwaitOf;\n                } else if (is(\"operator\", \"in\")) {\n                    next();\n                    ctor = AST_ForIn;\n                } else if (is(\"name\", \"of\")) {\n                    next();\n                    ctor = AST_ForOf;\n                }\n                if (ctor) {\n                    if (init instanceof AST_Definitions) {\n                        if (init.definitions.length > 1) {\n                            token_error(init.start, \"Only one variable declaration allowed in for..in/of loop\");\n                        }\n                        if (ctor !== AST_ForIn && init.definitions[0].value) {\n                            token_error(init.definitions[0].value.start, \"No initializers allowed in for..of loop\");\n                        }\n                    } else if (!(is_assignable(init) || (init = to_destructured(init)) instanceof AST_Destructured)) {\n                        token_error(init.start, \"Invalid left-hand side in for..in/of loop\");\n                    }\n                    return for_enum(ctor, init);\n                }\n            }\n            return regular_for(init);\n        }\n\n        function regular_for(init) {\n            expect(\";\");\n            var test = is(\"punc\", \";\") ? null : expression();\n            expect(\";\");\n            var step = is(\"punc\", \")\") ? null : expression();\n            expect(\")\");\n            return new AST_For({\n                init      : init,\n                condition : test,\n                step      : step,\n                body      : in_loop(statement)\n            });\n        }\n\n        function for_enum(ctor, init) {\n            handle_regexp();\n            var obj = expression();\n            expect(\")\");\n            return new ctor({\n                init   : init,\n                object : obj,\n                body   : in_loop(statement)\n            });\n        }\n\n        function to_funarg(node) {\n            if (node instanceof AST_Array) {\n                var rest = null;\n                if (node.elements[node.elements.length - 1] instanceof AST_Spread) {\n                    rest = to_funarg(node.elements.pop().expression);\n                }\n                return new AST_DestructuredArray({\n                    start: node.start,\n                    elements: node.elements.map(to_funarg),\n                    rest: rest,\n                    end: node.end,\n                });\n            }\n            if (node instanceof AST_Assign) return new AST_DefaultValue({\n                start: node.start,\n                name: to_funarg(node.left),\n                value: node.right,\n                end: node.end,\n            });\n            if (node instanceof AST_DefaultValue) {\n                node.name = to_funarg(node.name);\n                return node;\n            }\n            if (node instanceof AST_DestructuredArray) {\n                node.elements = node.elements.map(to_funarg);\n                if (node.rest) node.rest = to_funarg(node.rest);\n                return node;\n            }\n            if (node instanceof AST_DestructuredObject) {\n                node.properties.forEach(function(prop) {\n                    prop.value = to_funarg(prop.value);\n                });\n                if (node.rest) node.rest = to_funarg(node.rest);\n                return node;\n            }\n            if (node instanceof AST_Hole) return node;\n            if (node instanceof AST_Object) {\n                var rest = null;\n                if (node.properties[node.properties.length - 1] instanceof AST_Spread) {\n                    rest = to_funarg(node.properties.pop().expression);\n                }\n                return new AST_DestructuredObject({\n                    start: node.start,\n                    properties: node.properties.map(function(prop) {\n                        if (!(prop instanceof AST_ObjectKeyVal)) token_error(prop.start, \"Invalid destructuring assignment\");\n                        return new AST_DestructuredKeyVal({\n                            start: prop.start,\n                            key: prop.key,\n                            value: to_funarg(prop.value),\n                            end: prop.end,\n                        });\n                    }),\n                    rest: rest,\n                    end: node.end,\n                });\n            }\n            if (node instanceof AST_SymbolFunarg) return node;\n            if (node instanceof AST_SymbolRef) return new AST_SymbolFunarg(node);\n            if (node instanceof AST_Yield) return new AST_SymbolFunarg({\n                start: node.start,\n                name: \"yield\",\n                end: node.end,\n            });\n            token_error(node.start, \"Invalid arrow parameter\");\n        }\n\n        function arrow(exprs, start, async) {\n            var was_async = S.in_async;\n            var was_gen = S.in_generator;\n            S.in_async = async;\n            S.in_generator = false;\n            var was_funarg = S.in_funarg;\n            S.in_funarg = S.in_function;\n            var argnames = exprs.map(to_funarg);\n            var rest = exprs.rest || null;\n            if (rest) rest = to_funarg(rest);\n            S.in_funarg = was_funarg;\n            expect(\"=>\");\n            var body, value;\n            var loop = S.in_loop;\n            var labels = S.labels;\n            ++S.in_function;\n            S.input.push_directives_stack();\n            S.in_loop = 0;\n            S.labels = [];\n            if (is(\"punc\", \"{\")) {\n                S.in_directives = true;\n                body = block_();\n                value = null;\n            } else {\n                body = [];\n                handle_regexp();\n                value = maybe_assign();\n            }\n            var is_strict = S.input.has_directive(\"use strict\");\n            S.input.pop_directives_stack();\n            --S.in_function;\n            S.in_loop = loop;\n            S.labels = labels;\n            S.in_generator = was_gen;\n            S.in_async = was_async;\n            var node = new (async ? AST_AsyncArrow : AST_Arrow)({\n                start: start,\n                argnames: argnames,\n                rest: rest,\n                body: body,\n                value: value,\n                end: prev(),\n            });\n            if (is_strict) node.each_argname(strict_verify_symbol);\n            return node;\n        }\n\n        var function_ = function(ctor) {\n            var was_async = S.in_async;\n            var was_gen = S.in_generator;\n            var name;\n            if (/Defun$/.test(ctor.TYPE)) {\n                name = as_symbol(AST_SymbolDefun);\n                S.in_async = /^Async/.test(ctor.TYPE);\n                S.in_generator = /Generator/.test(ctor.TYPE);\n            } else {\n                S.in_async = /^Async/.test(ctor.TYPE);\n                S.in_generator = /Generator/.test(ctor.TYPE);\n                name = as_symbol(AST_SymbolLambda, true);\n            }\n            if (name && ctor !== AST_Accessor && !(name instanceof AST_SymbolDeclaration))\n                unexpected(prev());\n            expect(\"(\");\n            var was_funarg = S.in_funarg;\n            S.in_funarg = S.in_function;\n            var argnames = expr_list(\")\", !options.strict, false, function() {\n                return maybe_default(AST_SymbolFunarg);\n            });\n            S.in_funarg = was_funarg;\n            var loop = S.in_loop;\n            var labels = S.labels;\n            ++S.in_function;\n            S.in_directives = true;\n            S.input.push_directives_stack();\n            S.in_loop = 0;\n            S.labels = [];\n            var body = block_();\n            var is_strict = S.input.has_directive(\"use strict\");\n            S.input.pop_directives_stack();\n            --S.in_function;\n            S.in_loop = loop;\n            S.labels = labels;\n            S.in_generator = was_gen;\n            S.in_async = was_async;\n            var node = new ctor({\n                name: name,\n                argnames: argnames,\n                rest: argnames.rest || null,\n                body: body,\n            });\n            if (is_strict) {\n                if (name) strict_verify_symbol(name);\n                node.each_argname(strict_verify_symbol);\n            }\n            return node;\n        };\n\n        function if_() {\n            var cond = parenthesized(), body = statement(), alt = null;\n            if (is(\"keyword\", \"else\")) {\n                next();\n                alt = statement();\n            }\n            return new AST_If({\n                condition   : cond,\n                body        : body,\n                alternative : alt,\n            });\n        }\n\n        function is_alias() {\n            return is(\"name\") || is(\"string\") || is_identifier_string(S.token.value);\n        }\n\n        function make_string(token) {\n            return new AST_String({\n                start: token,\n                quote: token.quote,\n                value: token.value,\n                end: token,\n            });\n        }\n\n        function as_path() {\n            var path = S.token;\n            expect_token(\"string\");\n            semicolon();\n            return make_string(path);\n        }\n\n        function export_() {\n            if (is(\"operator\", \"*\")) {\n                var key = S.token;\n                var alias = key;\n                next();\n                if (is(\"name\", \"as\")) {\n                    next();\n                    if (!is_alias()) expect_token(\"name\");\n                    alias = S.token;\n                    next();\n                }\n                expect_token(\"name\", \"from\");\n                return new AST_ExportForeign({\n                    aliases: [ make_string(alias) ],\n                    keys: [ make_string(key) ],\n                    path: as_path(),\n                });\n            }\n            if (is(\"punc\", \"{\")) {\n                next();\n                var aliases = [];\n                var keys = [];\n                while (is_alias()) {\n                    var key = S.token;\n                    next();\n                    keys.push(key);\n                    if (is(\"name\", \"as\")) {\n                        next();\n                        if (!is_alias()) expect_token(\"name\");\n                        aliases.push(S.token);\n                        next();\n                    } else {\n                        aliases.push(key);\n                    }\n                    if (!is(\"punc\", \"}\")) expect(\",\");\n                }\n                expect(\"}\");\n                if (is(\"name\", \"from\")) {\n                    next();\n                    return new AST_ExportForeign({\n                        aliases: aliases.map(make_string),\n                        keys: keys.map(make_string),\n                        path: as_path(),\n                    });\n                }\n                semicolon();\n                return new AST_ExportReferences({\n                    properties: keys.map(function(token, index) {\n                        if (!is_token(token, \"name\")) token_error(token, \"Name expected\");\n                        var sym = _make_symbol(AST_SymbolExport, token);\n                        sym.alias = make_string(aliases[index]);\n                        return sym;\n                    }),\n                });\n            }\n            if (is(\"keyword\", \"default\")) {\n                next();\n                var start = S.token;\n                var body = export_default_decl();\n                if (body) {\n                    body.start = start;\n                    body.end = prev();\n                } else {\n                    handle_regexp();\n                    body = expression();\n                    semicolon();\n                }\n                return new AST_ExportDefault({ body: body });\n            }\n            return new AST_ExportDeclaration({ body: export_decl() });\n        }\n\n        function maybe_named(def, expr) {\n            if (expr.name) {\n                expr = new def(expr);\n                expr.name = new (def === AST_DefClass ? AST_SymbolDefClass : AST_SymbolDefun)(expr.name);\n            }\n            return expr;\n        }\n\n        function export_default_decl() {\n            if (is(\"name\", \"async\")) {\n                if (!is_token(peek(), \"keyword\", \"function\")) return;\n                next();\n                next();\n                if (!is(\"operator\", \"*\")) return maybe_named(AST_AsyncDefun, function_(AST_AsyncFunction));\n                next();\n                return maybe_named(AST_AsyncGeneratorDefun, function_(AST_AsyncGeneratorFunction));\n            } else if (is(\"keyword\")) switch (S.token.value) {\n              case \"class\":\n                next();\n                return maybe_named(AST_DefClass, class_(AST_ClassExpression));\n              case \"function\":\n                next();\n                if (!is(\"operator\", \"*\")) return maybe_named(AST_Defun, function_(AST_Function));\n                next();\n                return maybe_named(AST_GeneratorDefun, function_(AST_GeneratorFunction));\n            }\n        }\n\n        var export_decl = embed_tokens(function() {\n            if (is(\"name\")) switch (S.token.value) {\n              case \"async\":\n                next();\n                expect_token(\"keyword\", \"function\");\n                if (!is(\"operator\", \"*\")) return function_(AST_AsyncDefun);\n                next();\n                return function_(AST_AsyncGeneratorDefun);\n              case \"let\":\n                next();\n                var node = let_();\n                semicolon();\n                return node;\n            } else if (is(\"keyword\")) switch (S.token.value) {\n              case \"class\":\n                next();\n                return class_(AST_DefClass);\n              case \"const\":\n                next();\n                var node = const_();\n                semicolon();\n                return node;\n              case \"function\":\n                next();\n                if (!is(\"operator\", \"*\")) return function_(AST_Defun);\n                next();\n                return function_(AST_GeneratorDefun);\n              case \"var\":\n                next();\n                var node = var_();\n                semicolon();\n                return node;\n            }\n            unexpected();\n        });\n\n        function import_() {\n            var all = null;\n            var def = as_symbol(AST_SymbolImport, true);\n            var props = null;\n            var cont;\n            if (def) {\n                def.key = new AST_String({\n                    start: def.start,\n                    value: \"\",\n                    end: def.end,\n                });\n                if (cont = is(\"punc\", \",\")) next();\n            } else {\n                cont = !is(\"string\");\n            }\n            if (cont) {\n                if (is(\"operator\", \"*\")) {\n                    var key = S.token;\n                    next();\n                    expect_token(\"name\", \"as\");\n                    all = as_symbol(AST_SymbolImport);\n                    all.key = make_string(key);\n                } else {\n                    expect(\"{\");\n                    props = [];\n                    while (is_alias()) {\n                        var alias;\n                        if (is_token(peek(), \"name\", \"as\")) {\n                            var key = S.token;\n                            next();\n                            next();\n                            alias = as_symbol(AST_SymbolImport);\n                            alias.key = make_string(key);\n                        } else {\n                            alias = as_symbol(AST_SymbolImport);\n                            alias.key = new AST_String({\n                                start: alias.start,\n                                value: alias.name,\n                                end: alias.end,\n                            });\n                        }\n                        props.push(alias);\n                        if (!is(\"punc\", \"}\")) expect(\",\");\n                    }\n                    expect(\"}\");\n                }\n            }\n            if (all || def || props) expect_token(\"name\", \"from\");\n            return new AST_Import({\n                all: all,\n                default: def,\n                path: as_path(),\n                properties: props,\n            });\n        }\n\n        function block_() {\n            expect(\"{\");\n            var a = [];\n            while (!is(\"punc\", \"}\")) {\n                if (is(\"eof\")) expect(\"}\");\n                a.push(statement());\n            }\n            next();\n            return a;\n        }\n\n        function switch_body_() {\n            expect(\"{\");\n            var a = [], branch, cur, default_branch, tmp;\n            while (!is(\"punc\", \"}\")) {\n                if (is(\"eof\")) expect(\"}\");\n                if (is(\"keyword\", \"case\")) {\n                    if (branch) branch.end = prev();\n                    cur = [];\n                    branch = new AST_Case({\n                        start      : (tmp = S.token, next(), tmp),\n                        expression : expression(),\n                        body       : cur\n                    });\n                    a.push(branch);\n                    expect(\":\");\n                } else if (is(\"keyword\", \"default\")) {\n                    if (branch) branch.end = prev();\n                    if (default_branch) croak(\"More than one default clause in switch statement\");\n                    cur = [];\n                    branch = new AST_Default({\n                        start : (tmp = S.token, next(), expect(\":\"), tmp),\n                        body  : cur\n                    });\n                    a.push(branch);\n                    default_branch = branch;\n                } else {\n                    if (!cur) unexpected();\n                    cur.push(statement());\n                }\n            }\n            if (branch) branch.end = prev();\n            next();\n            return a;\n        }\n\n        function try_() {\n            var body = block_(), bcatch = null, bfinally = null;\n            if (is(\"keyword\", \"catch\")) {\n                var start = S.token;\n                next();\n                var name = null;\n                if (is(\"punc\", \"(\")) {\n                    next();\n                    name = maybe_destructured(AST_SymbolCatch);\n                    expect(\")\");\n                }\n                bcatch = new AST_Catch({\n                    start   : start,\n                    argname : name,\n                    body    : block_(),\n                    end     : prev()\n                });\n            }\n            if (is(\"keyword\", \"finally\")) {\n                var start = S.token;\n                next();\n                bfinally = new AST_Finally({\n                    start : start,\n                    body  : block_(),\n                    end   : prev()\n                });\n            }\n            if (!bcatch && !bfinally)\n                croak(\"Missing catch/finally blocks\");\n            return new AST_Try({\n                body     : body,\n                bcatch   : bcatch,\n                bfinally : bfinally\n            });\n        }\n\n        function vardefs(type, no_in) {\n            var a = [];\n            for (;;) {\n                var start = S.token;\n                var name = maybe_destructured(type);\n                var value = null;\n                if (is(\"operator\", \"=\")) {\n                    next();\n                    value = maybe_assign(no_in);\n                } else if (!no_in && (type === AST_SymbolConst || name instanceof AST_Destructured)) {\n                    croak(\"Missing initializer in declaration\");\n                }\n                a.push(new AST_VarDef({\n                    start : start,\n                    name  : name,\n                    value : value,\n                    end   : prev()\n                }));\n                if (!is(\"punc\", \",\"))\n                    break;\n                next();\n            }\n            return a;\n        }\n\n        function is_vardefs() {\n            var token = peek();\n            return is_token(token, \"name\") || is_token(token, \"punc\", \"[\") || is_token(token, \"punc\", \"{\");\n        }\n\n        var const_ = function(no_in) {\n            return new AST_Const({\n                start       : prev(),\n                definitions : vardefs(AST_SymbolConst, no_in),\n                end         : prev()\n            });\n        };\n\n        var let_ = function(no_in) {\n            return new AST_Let({\n                start       : prev(),\n                definitions : vardefs(AST_SymbolLet, no_in),\n                end         : prev()\n            });\n        };\n\n        var var_ = function(no_in) {\n            return new AST_Var({\n                start       : prev(),\n                definitions : vardefs(AST_SymbolVar, no_in),\n                end         : prev()\n            });\n        };\n\n        var new_ = function(allow_calls) {\n            var start = S.token;\n            expect_token(\"operator\", \"new\");\n            var call;\n            if (is(\"punc\", \".\") && is_token(peek(), \"name\", \"target\")) {\n                next();\n                next();\n                call = new AST_NewTarget();\n            } else {\n                var exp = expr_atom(false), args;\n                if (is(\"punc\", \"(\")) {\n                    next();\n                    args = expr_list(\")\", !options.strict);\n                } else {\n                    args = [];\n                }\n                call = new AST_New({ expression: exp, args: args });\n            }\n            call.start = start;\n            call.end = prev();\n            return subscripts(call, allow_calls);\n        };\n\n        function as_atom_node() {\n            var ret, tok = S.token, value = tok.value;\n            switch (tok.type) {\n              case \"num\":\n                if (isFinite(value)) {\n                    ret = new AST_Number({ value: value });\n                } else {\n                    ret = new AST_Infinity();\n                    if (value < 0) ret = new AST_UnaryPrefix({ operator: \"-\", expression: ret });\n                }\n                break;\n              case \"bigint\":\n                ret = new AST_BigInt({ value: value });\n                break;\n              case \"string\":\n                ret = new AST_String({ value: value, quote: tok.quote });\n                break;\n              case \"regexp\":\n                ret = new AST_RegExp({ value: value });\n                break;\n              case \"atom\":\n                switch (value) {\n                  case \"false\":\n                    ret = new AST_False();\n                    break;\n                  case \"true\":\n                    ret = new AST_True();\n                    break;\n                  case \"null\":\n                    ret = new AST_Null();\n                    break;\n                  default:\n                    unexpected();\n                }\n                break;\n              default:\n                unexpected();\n            }\n            next();\n            ret.start = ret.end = tok;\n            return ret;\n        }\n\n        var expr_atom = function(allow_calls) {\n            if (is(\"operator\", \"new\")) {\n                return new_(allow_calls);\n            }\n            var start = S.token;\n            if (is(\"punc\")) {\n                switch (start.value) {\n                  case \"`\":\n                    return subscripts(template(null), allow_calls);\n                  case \"(\":\n                    next();\n                    if (is(\"punc\", \")\")) {\n                        next();\n                        return arrow([], start);\n                    }\n                    var ex = expression(false, true);\n                    var len = start.comments_before.length;\n                    [].unshift.apply(ex.start.comments_before, start.comments_before);\n                    start.comments_before.length = 0;\n                    start.comments_before = ex.start.comments_before;\n                    start.comments_before_length = len;\n                    if (len == 0 && start.comments_before.length > 0) {\n                        var comment = start.comments_before[0];\n                        if (!comment.nlb) {\n                            comment.nlb = start.nlb;\n                            start.nlb = false;\n                        }\n                    }\n                    start.comments_after = ex.start.comments_after;\n                    ex.start = start;\n                    expect(\")\");\n                    var end = prev();\n                    end.comments_before = ex.end.comments_before;\n                    end.comments_after.forEach(function(comment) {\n                        ex.end.comments_after.push(comment);\n                        if (comment.nlb) S.token.nlb = true;\n                    });\n                    end.comments_after.length = 0;\n                    end.comments_after = ex.end.comments_after;\n                    ex.end = end;\n                    if (is(\"punc\", \"=>\")) return arrow(ex instanceof AST_Sequence ? ex.expressions : [ ex ], start);\n                    return subscripts(ex, allow_calls);\n                  case \"[\":\n                    return subscripts(array_(), allow_calls);\n                  case \"{\":\n                    return subscripts(object_(), allow_calls);\n                }\n                unexpected();\n            }\n            if (is(\"keyword\")) switch (start.value) {\n              case \"class\":\n                next();\n                var clazz = class_(AST_ClassExpression);\n                clazz.start = start;\n                clazz.end = prev();\n                return subscripts(clazz, allow_calls);\n              case \"function\":\n                next();\n                var func;\n                if (is(\"operator\", \"*\")) {\n                    next();\n                    func = function_(AST_GeneratorFunction);\n                } else {\n                    func = function_(AST_Function);\n                }\n                func.start = start;\n                func.end = prev();\n                return subscripts(func, allow_calls);\n            }\n            if (is(\"name\")) {\n                var sym = _make_symbol(AST_SymbolRef, start);\n                next();\n                if (sym.name == \"async\") {\n                    if (is(\"keyword\", \"function\")) {\n                        next();\n                        var func;\n                        if (is(\"operator\", \"*\")) {\n                            next();\n                            func = function_(AST_AsyncGeneratorFunction);\n                        } else {\n                            func = function_(AST_AsyncFunction);\n                        }\n                        func.start = start;\n                        func.end = prev();\n                        return subscripts(func, allow_calls);\n                    }\n                    if (is(\"name\") && is_token(peek(), \"punc\", \"=>\")) {\n                        start = S.token;\n                        sym = _make_symbol(AST_SymbolRef, start);\n                        next();\n                        return arrow([ sym ], start, true);\n                    }\n                    if (is(\"punc\", \"(\")) {\n                        var call = subscripts(sym, allow_calls);\n                        if (!is(\"punc\", \"=>\")) return call;\n                        var args = call.args;\n                        if (args[args.length - 1] instanceof AST_Spread) {\n                            args.rest = args.pop().expression;\n                        }\n                        return arrow(args, start, true);\n                    }\n                }\n                return is(\"punc\", \"=>\") ? arrow([ sym ], start) : subscripts(sym, allow_calls);\n            }\n            if (ATOMIC_START_TOKEN[S.token.type]) {\n                return subscripts(as_atom_node(), allow_calls);\n            }\n            unexpected();\n        };\n\n        function expr_list(closing, allow_trailing_comma, allow_empty, parser) {\n            if (!parser) parser = maybe_assign;\n            var first = true, a = [];\n            while (!is(\"punc\", closing)) {\n                if (first) first = false; else expect(\",\");\n                if (allow_trailing_comma && is(\"punc\", closing)) break;\n                if (allow_empty && is(\"punc\", \",\")) {\n                    a.push(new AST_Hole({ start: S.token, end: S.token }));\n                } else if (!is(\"operator\", \"...\")) {\n                    a.push(parser());\n                } else if (parser === maybe_assign) {\n                    a.push(new AST_Spread({\n                        start: S.token,\n                        expression: (next(), parser()),\n                        end: prev(),\n                    }));\n                } else {\n                    next();\n                    a.rest = parser();\n                    if (a.rest instanceof AST_DefaultValue) token_error(a.rest.start, \"Invalid rest parameter\");\n                    break;\n                }\n            }\n            expect(closing);\n            return a;\n        }\n\n        var array_ = embed_tokens(function() {\n            expect(\"[\");\n            return new AST_Array({\n                elements: expr_list(\"]\", !options.strict, true)\n            });\n        });\n\n        var create_accessor = embed_tokens(function() {\n            return function_(AST_Accessor);\n        });\n\n        var object_ = embed_tokens(function() {\n            expect(\"{\");\n            var first = true, a = [];\n            while (!is(\"punc\", \"}\")) {\n                if (first) first = false; else expect(\",\");\n                // allow trailing comma\n                if (!options.strict && is(\"punc\", \"}\")) break;\n                var start = S.token;\n                if (is(\"operator\", \"*\")) {\n                    next();\n                    var key = as_property_key();\n                    var gen_start = S.token;\n                    var gen = function_(AST_GeneratorFunction);\n                    gen.start = gen_start;\n                    gen.end = prev();\n                    a.push(new AST_ObjectMethod({\n                        start: start,\n                        key: key,\n                        value: gen,\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                if (is(\"operator\", \"...\")) {\n                    next();\n                    a.push(new AST_Spread({\n                        start: start,\n                        expression: maybe_assign(),\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                if (is_token(peek(), \"operator\", \"=\")) {\n                    var name = as_symbol(AST_SymbolRef);\n                    next();\n                    a.push(new AST_ObjectKeyVal({\n                        start: start,\n                        key: start.value,\n                        value: new AST_Assign({\n                            start: start,\n                            left: name,\n                            operator: \"=\",\n                            right: maybe_assign(),\n                            end: prev(),\n                        }),\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                if (is_token(peek(), \"punc\", \",\") || is_token(peek(), \"punc\", \"}\")) {\n                    a.push(new AST_ObjectKeyVal({\n                        start: start,\n                        key: start.value,\n                        value: as_symbol(AST_SymbolRef),\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                var key = as_property_key();\n                if (is(\"punc\", \"(\")) {\n                    var func_start = S.token;\n                    var func = function_(AST_Function);\n                    func.start = func_start;\n                    func.end = prev();\n                    a.push(new AST_ObjectMethod({\n                        start: start,\n                        key: key,\n                        value: func,\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                if (is(\"punc\", \":\")) {\n                    next();\n                    a.push(new AST_ObjectKeyVal({\n                        start: start,\n                        key: key,\n                        value: maybe_assign(),\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                if (start.type == \"name\") switch (key) {\n                  case \"async\":\n                    var is_gen = is(\"operator\", \"*\") && next();\n                    key = as_property_key();\n                    var func_start = S.token;\n                    var func = function_(is_gen ? AST_AsyncGeneratorFunction : AST_AsyncFunction);\n                    func.start = func_start;\n                    func.end = prev();\n                    a.push(new AST_ObjectMethod({\n                        start: start,\n                        key: key,\n                        value: func,\n                        end: prev(),\n                    }));\n                    continue;\n                  case \"get\":\n                    a.push(new AST_ObjectGetter({\n                        start: start,\n                        key: as_property_key(),\n                        value: create_accessor(),\n                        end: prev(),\n                    }));\n                    continue;\n                  case \"set\":\n                    a.push(new AST_ObjectSetter({\n                        start: start,\n                        key: as_property_key(),\n                        value: create_accessor(),\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                unexpected();\n            }\n            next();\n            return new AST_Object({ properties: a });\n        });\n\n        function as_property_key() {\n            var tmp = S.token;\n            switch (tmp.type) {\n              case \"operator\":\n                if (!KEYWORDS[tmp.value]) unexpected();\n              case \"num\":\n              case \"string\":\n              case \"name\":\n              case \"keyword\":\n              case \"atom\":\n                next();\n                return \"\" + tmp.value;\n              case \"punc\":\n                expect(\"[\");\n                var key = maybe_assign();\n                expect(\"]\");\n                return key;\n              default:\n                unexpected();\n            }\n        }\n\n        function as_name() {\n            var name = S.token.value;\n            expect_token(\"name\");\n            return name;\n        }\n\n        function _make_symbol(type, token) {\n            var name = token.value;\n            switch (name) {\n              case \"await\":\n                if (S.in_async) unexpected(token);\n                break;\n              case \"super\":\n                type = AST_Super;\n                break;\n              case \"this\":\n                type = AST_This;\n                break;\n              case \"yield\":\n                if (S.in_generator) unexpected(token);\n                break;\n            }\n            return new type({\n                name: \"\" + name,\n                start: token,\n                end: token,\n            });\n        }\n\n        function strict_verify_symbol(sym) {\n            if (sym.name == \"arguments\" || sym.name == \"eval\" || sym.name == \"let\")\n                token_error(sym.start, \"Unexpected \" + sym.name + \" in strict mode\");\n        }\n\n        function as_symbol(type, no_error) {\n            if (!is(\"name\")) {\n                if (!no_error) croak(\"Name expected\");\n                return null;\n            }\n            var sym = _make_symbol(type, S.token);\n            if (S.input.has_directive(\"use strict\") && sym instanceof AST_SymbolDeclaration) {\n                strict_verify_symbol(sym);\n            }\n            next();\n            return sym;\n        }\n\n        function maybe_destructured(type) {\n            var start = S.token;\n            if (is(\"punc\", \"[\")) {\n                next();\n                var elements = expr_list(\"]\", !options.strict, true, function() {\n                    return maybe_default(type);\n                });\n                return new AST_DestructuredArray({\n                    start: start,\n                    elements: elements,\n                    rest: elements.rest || null,\n                    end: prev(),\n                });\n            }\n            if (is(\"punc\", \"{\")) {\n                next();\n                var first = true, a = [], rest = null;\n                while (!is(\"punc\", \"}\")) {\n                    if (first) first = false; else expect(\",\");\n                    // allow trailing comma\n                    if (!options.strict && is(\"punc\", \"}\")) break;\n                    var key_start = S.token;\n                    if (is(\"punc\", \"[\") || is_token(peek(), \"punc\", \":\")) {\n                        var key = as_property_key();\n                        expect(\":\");\n                        a.push(new AST_DestructuredKeyVal({\n                            start: key_start,\n                            key: key,\n                            value: maybe_default(type),\n                            end: prev(),\n                        }));\n                        continue;\n                    }\n                    if (is(\"operator\", \"...\")) {\n                        next();\n                        rest = maybe_destructured(type);\n                        break;\n                    }\n                    var name = as_symbol(type);\n                    if (is(\"operator\", \"=\")) {\n                        next();\n                        name = new AST_DefaultValue({\n                            start: name.start,\n                            name: name,\n                            value: maybe_assign(),\n                            end: prev(),\n                        });\n                    }\n                    a.push(new AST_DestructuredKeyVal({\n                        start: key_start,\n                        key: key_start.value,\n                        value: name,\n                        end: prev(),\n                    }));\n                }\n                expect(\"}\");\n                return new AST_DestructuredObject({\n                    start: start,\n                    properties: a,\n                    rest: rest,\n                    end: prev(),\n                });\n            }\n            return as_symbol(type);\n        }\n\n        function maybe_default(type) {\n            var start = S.token;\n            var name = maybe_destructured(type);\n            if (!is(\"operator\", \"=\")) return name;\n            next();\n            return new AST_DefaultValue({\n                start: start,\n                name: name,\n                value: maybe_assign(),\n                end: prev(),\n            });\n        }\n\n        function template(tag) {\n            var start = tag ? tag.start : S.token;\n            var read = S.input.context().read_template;\n            var strings = [];\n            var expressions = [];\n            while (read(strings)) {\n                next();\n                expressions.push(expression());\n                if (!is(\"punc\", \"}\")) unexpected();\n            }\n            next();\n            return new AST_Template({\n                start: start,\n                expressions: expressions,\n                strings: strings,\n                tag: tag,\n                end: prev(),\n            });\n        }\n\n        function subscripts(expr, allow_calls) {\n            var start = expr.start;\n            var optional = null;\n            while (true) {\n                if (is(\"operator\", \"?\") && is_token(peek(), \"punc\", \".\")) {\n                    next();\n                    next();\n                    optional = expr;\n                }\n                if (is(\"punc\", \"[\")) {\n                    next();\n                    var prop = expression();\n                    expect(\"]\");\n                    expr = new AST_Sub({\n                        start: start,\n                        optional: optional === expr,\n                        expression: expr,\n                        property: prop,\n                        end: prev(),\n                    });\n                } else if (allow_calls && is(\"punc\", \"(\")) {\n                    next();\n                    expr = new AST_Call({\n                        start: start,\n                        optional: optional === expr,\n                        expression: expr,\n                        args: expr_list(\")\", !options.strict),\n                        end: prev(),\n                    });\n                } else if (optional === expr || is(\"punc\", \".\")) {\n                    if (optional !== expr) next();\n                    expr = new AST_Dot({\n                        start: start,\n                        optional: optional === expr,\n                        expression: expr,\n                        property: as_name(),\n                        end: prev(),\n                    });\n                } else if (is(\"punc\", \"`\")) {\n                    if (optional) croak(\"Invalid template on optional chain\");\n                    expr = template(expr);\n                } else {\n                    break;\n                }\n            }\n            if (optional) expr.terminal = true;\n            if (expr instanceof AST_Call && !expr.pure) {\n                var start = expr.start;\n                var comments = start.comments_before;\n                var i = HOP(start, \"comments_before_length\") ? start.comments_before_length : comments.length;\n                while (--i >= 0) {\n                    if (/[@#]__PURE__/.test(comments[i].value)) {\n                        expr.pure = true;\n                        break;\n                    }\n                }\n            }\n            return expr;\n        }\n\n        function maybe_unary(no_in) {\n            var start = S.token;\n            if (S.in_async && is(\"name\", \"await\")) {\n                if (S.in_funarg === S.in_function) croak(\"Invalid use of await in function argument\");\n                S.input.context().regex_allowed = true;\n                next();\n                return new AST_Await({\n                    start: start,\n                    expression: maybe_unary(no_in),\n                    end: prev(),\n                });\n            }\n            if (S.in_generator && is(\"name\", \"yield\")) {\n                if (S.in_funarg === S.in_function) croak(\"Invalid use of yield in function argument\");\n                S.input.context().regex_allowed = true;\n                next();\n                var exp = null;\n                var nested = false;\n                if (is(\"operator\", \"*\")) {\n                    next();\n                    exp = maybe_assign(no_in);\n                    nested = true;\n                } else if (is(\"punc\") ? !PUNC_AFTER_EXPRESSION[S.token.value] : !can_insert_semicolon()) {\n                    exp = maybe_assign(no_in);\n                }\n                return new AST_Yield({\n                    start: start,\n                    expression: exp,\n                    nested: nested,\n                    end: prev(),\n                });\n            }\n            if (is(\"operator\") && UNARY_PREFIX[start.value]) {\n                next();\n                handle_regexp();\n                var ex = make_unary(AST_UnaryPrefix, start, maybe_unary(no_in));\n                ex.start = start;\n                ex.end = prev();\n                return ex;\n            }\n            var val = expr_atom(true);\n            while (is(\"operator\") && UNARY_POSTFIX[S.token.value] && !has_newline_before(S.token)) {\n                val = make_unary(AST_UnaryPostfix, S.token, val);\n                val.start = start;\n                val.end = S.token;\n                next();\n            }\n            return val;\n        }\n\n        function make_unary(ctor, token, expr) {\n            var op = token.value;\n            switch (op) {\n              case \"++\":\n              case \"--\":\n                if (!is_assignable(expr))\n                    token_error(token, \"Invalid use of \" + op + \" operator\");\n                break;\n              case \"delete\":\n                if (expr instanceof AST_SymbolRef && S.input.has_directive(\"use strict\"))\n                    token_error(expr.start, \"Calling delete on expression not allowed in strict mode\");\n                break;\n            }\n            return new ctor({ operator: op, expression: expr });\n        }\n\n        var expr_op = function(left, min_precision, no_in) {\n            var op = is(\"operator\") ? S.token.value : null;\n            if (op == \"in\" && no_in) op = null;\n            var precision = op != null ? PRECEDENCE[op] : null;\n            if (precision != null && precision > min_precision) {\n                next();\n                var right = expr_op(maybe_unary(no_in), op == \"**\" ? precision - 1 : precision, no_in);\n                return expr_op(new AST_Binary({\n                    start    : left.start,\n                    left     : left,\n                    operator : op,\n                    right    : right,\n                    end      : right.end,\n                }), min_precision, no_in);\n            }\n            return left;\n        };\n\n        function expr_ops(no_in) {\n            return expr_op(maybe_unary(no_in), 0, no_in);\n        }\n\n        var maybe_conditional = function(no_in) {\n            var start = S.token;\n            var expr = expr_ops(no_in);\n            if (is(\"operator\", \"?\")) {\n                next();\n                var yes = maybe_assign();\n                expect(\":\");\n                return new AST_Conditional({\n                    start       : start,\n                    condition   : expr,\n                    consequent  : yes,\n                    alternative : maybe_assign(no_in),\n                    end         : prev()\n                });\n            }\n            return expr;\n        };\n\n        function is_assignable(expr) {\n            return expr instanceof AST_PropAccess && !expr.optional || expr instanceof AST_SymbolRef;\n        }\n\n        function to_destructured(node) {\n            if (node instanceof AST_Array) {\n                var rest = null;\n                if (node.elements[node.elements.length - 1] instanceof AST_Spread) {\n                    rest = to_destructured(node.elements.pop().expression);\n                    if (!(rest instanceof AST_Destructured || is_assignable(rest))) return node;\n                }\n                var elements = node.elements.map(to_destructured);\n                return all(elements, function(node) {\n                    return node instanceof AST_DefaultValue\n                        || node instanceof AST_Destructured\n                        || node instanceof AST_Hole\n                        || is_assignable(node);\n                }) ? new AST_DestructuredArray({\n                    start: node.start,\n                    elements: elements,\n                    rest: rest,\n                    end: node.end,\n                }) : node;\n            }\n            if (node instanceof AST_Assign) {\n                var name = to_destructured(node.left);\n                return name instanceof AST_Destructured || is_assignable(name) ? new AST_DefaultValue({\n                    start: node.start,\n                    name: name,\n                    value: node.right,\n                    end: node.end,\n                }) : node;\n            }\n            if (!(node instanceof AST_Object)) return node;\n            var rest = null;\n            if (node.properties[node.properties.length - 1] instanceof AST_Spread) {\n                rest = to_destructured(node.properties.pop().expression);\n                if (!(rest instanceof AST_Destructured || is_assignable(rest))) return node;\n            }\n            var props = [];\n            for (var i = 0; i < node.properties.length; i++) {\n                var prop = node.properties[i];\n                if (!(prop instanceof AST_ObjectKeyVal)) return node;\n                var value = to_destructured(prop.value);\n                if (!(value instanceof AST_DefaultValue || value instanceof AST_Destructured || is_assignable(value))) {\n                    return node;\n                }\n                props.push(new AST_DestructuredKeyVal({\n                    start: prop.start,\n                    key: prop.key,\n                    value: value,\n                    end: prop.end,\n                }));\n            }\n            return new AST_DestructuredObject({\n                start: node.start,\n                properties: props,\n                rest: rest,\n                end: node.end,\n            });\n        }\n\n        function maybe_assign(no_in) {\n            var start = S.token;\n            var left = maybe_conditional(no_in), val = S.token.value;\n            if (is(\"operator\") && ASSIGNMENT[val]) {\n                if (is_assignable(left) || val == \"=\" && (left = to_destructured(left)) instanceof AST_Destructured) {\n                    next();\n                    return new AST_Assign({\n                        start    : start,\n                        left     : left,\n                        operator : val,\n                        right    : maybe_assign(no_in),\n                        end      : prev()\n                    });\n                }\n                croak(\"Invalid assignment\");\n            }\n            return left;\n        }\n\n        function expression(no_in, maybe_arrow) {\n            var start = S.token;\n            var exprs = [];\n            while (true) {\n                if (maybe_arrow && is(\"operator\", \"...\")) {\n                    next();\n                    exprs.rest = maybe_destructured(AST_SymbolFunarg);\n                    break;\n                }\n                exprs.push(maybe_assign(no_in));\n                if (!is(\"punc\", \",\")) break;\n                next();\n                if (maybe_arrow && is(\"punc\", \")\") && is_token(peek(), \"punc\", \"=>\")) break;\n            }\n            return exprs.length == 1 && !exprs.rest ? exprs[0] : new AST_Sequence({\n                start: start,\n                expressions: exprs,\n                end: prev(),\n            });\n        }\n\n        function in_loop(cont) {\n            ++S.in_loop;\n            var ret = cont();\n            --S.in_loop;\n            return ret;\n        }\n\n        if (options.expression) {\n            handle_regexp();\n            var exp = expression();\n            expect_token(\"eof\");\n            return exp;\n        }\n\n        return function() {\n            var start = S.token;\n            var body = [];\n            if (options.module) {\n                S.in_async = true;\n                S.input.add_directive(\"use strict\");\n            }\n            S.input.push_directives_stack();\n            while (!is(\"eof\"))\n                body.push(statement(true));\n            S.input.pop_directives_stack();\n            var end = prev() || start;\n            var toplevel = options.toplevel;\n            if (toplevel) {\n                toplevel.body = toplevel.body.concat(body);\n                toplevel.end = end;\n            } else {\n                toplevel = new AST_Toplevel({ start: start, body: body, end: end });\n            }\n            return toplevel;\n        }();\n    }\n\n    m_ast.parse = parse; /// TODO: lwf\n    return {\n        is_identifier_string,\n        is_identifier_char,\n        is_surrogate_pair_head,\n        is_surrogate_pair_tail,\n        decode_escape_sequence,\n        tokenizer,\n        parse,\n        KEYWORDS,\n        RESERVED_WORDS,\n        KEYWORDS_BEFORE_EXPRESSION,\n        KEYWORDS_ATOM,\n        UNARY_POSTFIX,\n        PRECEDENCE \n    }\n});"]}