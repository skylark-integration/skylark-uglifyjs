{"version":3,"sources":["parse.js"],"names":["define","m_utils","m_ast","characters","defaults","find_if","makePredicate","configure_error_stack","HOP","all","AST_Accessor","AST_Array","AST_Arrow","AST_Assign","AST_AsyncFunction","AST_AsyncDefun","AST_AsyncArrow","AST_AsyncGeneratorFunction","AST_AsyncGeneratorDefun","AST_Await","AST_BigInt","AST_Binary","AST_BlockStatement","AST_Break","AST_Call","AST_Case","AST_Catch","AST_ClassExpression","AST_ClassGetter","AST_ClassInit","AST_ClassMethod","AST_ClassSetter","AST_Conditional","AST_Const","AST_Continue","AST_Debugger","AST_Default","AST_DefaultValue","AST_DefClass","AST_Definitions","AST_Defun","AST_Destructured","AST_DestructuredArray","AST_DestructuredKeyVal","AST_DestructuredObject","AST_Directive","AST_Do","AST_Dot","AST_EmptyStatement","AST_ExportDeclaration","AST_False","AST_Finally","AST_For","AST_ForIn","AST_ForOf","AST_Function","AST_Hole","AST_If","AST_Import","AST_Infinity","AST_IterationStatement","AST_Label","AST_LabeledStatement","AST_LabelRef","AST_Let","AST_New","AST_NewTarget","AST_Null","AST_Number","AST_Object","AST_ObjectGetter","AST_ObjectKeyVal","AST_ObjectMethod","AST_ObjectSetter","AST_PropAccess","AST_RegExp","AST_Return","AST_Sequence","AST_SimpleStatement","AST_Spread","AST_String","AST_Sub","AST_Super","AST_Switch","AST_SymbolCatch","AST_SymbolClass","AST_SymbolConst","AST_SymbolDeclaration","AST_SymbolDefClass","AST_SymbolDefun","AST_SymbolExport","AST_SymbolFunarg","AST_SymbolImport","AST_SymbolLambda","AST_SymbolLet","AST_SymbolRef","AST_SymbolVar","AST_Template","AST_This","AST_Throw","AST_Token","AST_Toplevel","AST_True","AST_Try","AST_UnaryPostfix","AST_UnaryPrefix","AST_Var","AST_VarDef","AST_While","AST_With","AST_Yield","RESERVED_WORDS","KEYWORDS_ATOM","KEYWORDS","join","KEYWORDS_BEFORE_EXPRESSION","RE_BIN_NUMBER","RE_HEX_NUMBER","RE_OCT_NUMBER","OPERATORS","NEWLINE_CHARS","OPERATOR_CHARS","PUNC_AFTER_EXPRESSION","PUNC_SEPARATORS","PUNC_BEFORE_EXPRESSION","PUNC_OPENERS","PUNC_CHARS","WHITESPACE_CHARS","NON_IDENTIFIER_CHARS","is_digit","code","is_identifier_char","ch","is_identifier_string","str","test","decode_escape_sequence","seq","slice","length","num","parseInt","isNaN","String","fromCharCode","JS_Parse_Error","message","filename","line","col","pos","this","js_error","is_token","token","type","val","value","prototype","Object","create","Error","constructor","name","EX_EOF","tokenizer","$TEXT","html5_comments","shebang","S","text","tokpos","tokline","tokcol","newline_before","regex_allowed","comments_before","directives","read_template","with_eof_error","strings","s","read","push","peek","next","prev_was_dot","charAt","signal_eof","in_string","forward","i","looking_at","substr","start_token","is_comment","UNARY_POSTFIX","ret","endline","endcol","endpos","nlb","file","raw","substring","comments_after","parse_error","err","is_octal","read_num","prefix","has_e","after_e","has_x","has_dot","pred","valid","next_token","has_directive","replace","match","exec","parseFloat","toLowerCase","read_escaped_char","p","read_string","quote_char","quote","tok","skip_line_comment","skip_multiline_comment","what","indexOf","read_name","hex","backslash","escaped","charCodeAt","toString","toUpperCase","read_regexp","source","prev_backslash","in_class","mods","regexp","RegExp","raw_source","e","read_operator","grow","op","bigger","eof_error","cont","x","ex","force_regexp","word","context","nc","add_directive","directive","push_directives_stack","pop_directives_stack","getPrototypeOf","UNARY_PREFIX","ASSIGNMENT","PRECEDENCE","a","b","j","ATOMIC_START_TOKEN","parse","options","bare_returns","expression","module","strict","toplevel","input","in_async","in_directives","in_funarg","in_function","in_generator","in_loop","labels","peeked","prev","is","croak","msg","ctx","token_error","token_to_string","undefined","unexpected","expect_token","expect","punc","has_newline_before","comment","can_insert_semicolon","semicolon","optional","parenthesized","exp","embed_tokens","parser","start","expr","apply","arguments","end","handle_regexp","statement","dir","body","simple_statement","function_","alias","key","is_alias","AST_ExportForeign","aliases","make_string","keys","path","as_path","map","AST_ExportReferences","properties","index","sym","_make_symbol","maybe_named","class_","AST_GeneratorDefun","AST_GeneratorFunction","AST_ExportDefault","export_decl","def","as_symbol","props","default","is_vardefs","node","let_","label","l","stat","pop","references","forEach","ref","block_","break_cont","const_","condition","await_token","init","var_","ctor","AST_ForAwaitOf","step","definitions","is_assignable","to_destructured","for_enum","obj","object","cond","alt","alternative","switch_body_","bcatch","bfinally","maybe_destructured","argname","ldef","thedef","TYPE","has_modifier","no_nlb","was_async","was_gen","parent","expr_atom","fixed","async","internal","as_property_key","gen_start","gen","static","private","AST_ClassInitBlock","func_start","func","maybe_assign","create_accessor","AST_ClassField","extends","to_funarg","rest","elements","left","right","prop","arrow","exprs","was_funarg","argnames","loop","is_strict","each_argname","strict_verify_symbol","expr_list","maybe_default","branch","cur","default_branch","tmp","vardefs","no_in","allow_calls","call","args","subscripts","template","len","unshift","comments_before_length","expressions","array_","object_","clazz","isFinite","operator","closing","allow_trailing_comma","allow_empty","first","is_gen","no_error","key_start","tag","property","terminal","pure","comments","maybe_unary","nested","make_unary","expr_op","min_precision","precision","maybe_conditional","yes","consequent","maybe_arrow","concat","is_surrogate_pair_head","is_surrogate_pair_tail"],"mappings":"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","file":"../parse.js","sourcesContent":["define([\n    \"./utils\",\n    \"./ast\"\n],function(m_utils,m_ast){\n    /***********************************************************************\n\n      A JavaScript tokenizer / parser / beautifier / compressor.\n      https://github.com/mishoo/UglifyJS\n\n      -------------------------------- (C) ---------------------------------\n\n                               Author: Mihai Bazon\n                             <mihai.bazon@gmail.com>\n                           http://mihai.bazon.net/blog\n\n      Distributed under the BSD license:\n\n        Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n        Parser based on parse-js (http://marijn.haverbeke.nl/parse-js/).\n\n        Redistribution and use in source and binary forms, with or without\n        modification, are permitted provided that the following conditions\n        are met:\n\n            * Redistributions of source code must retain the above\n              copyright notice, this list of conditions and the following\n              disclaimer.\n\n            * Redistributions in binary form must reproduce the above\n              copyright notice, this list of conditions and the following\n              disclaimer in the documentation and/or other materials\n              provided with the distribution.\n\n        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n        EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n        IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n        PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n        LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n        OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n        PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n        PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n        THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n        TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n        THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n        SUCH DAMAGE.\n\n     ***********************************************************************/\n\n    \"use strict\";\n\n    const {\n        characters,\n        defaults,\n        find_if,\n        makePredicate,\n        set_annotation,\n        configure_error_stack,\n        HOP,\n        all\n    } = m_utils;\n\n    const {\n        AST_Accessor,\n        AST_Array,\n        AST_Arrow,\n        AST_Assign,\n        AST_AsyncFunction,\n        AST_AsyncDefun,\n        AST_AsyncArrow,\n        AST_AsyncGeneratorFunction,\n        AST_AsyncGeneratorDefun,\n        AST_Await,\n        AST_BigInt,\n        AST_Binary,\n        AST_BlockStatement,\n        AST_Break,\n        AST_Call,\n        AST_Case,\n        AST_Catch,\n        AST_Chain,\n        AST_ClassExpression,\n        AST_ClassGetter,\n        AST_ClassInit,\n        AST_ClassMethod,\n        AST_ClassPrivateProperty,\n        AST_ClassProperty,\n        AST_ClassStaticBlock,\n        AST_ClassSetter,\n        AST_ConciseMethod,\n        AST_PrivateIn,\n        AST_PrivateGetter,\n        AST_PrivateMethod,\n        AST_PrivateSetter,\n        AST_Conditional,\n        AST_Const,\n        AST_Continue,\n        AST_Debugger,\n        AST_Default,\n        AST_DefaultAssign,\n        AST_DefaultValue,\n        AST_DefClass,\n        AST_Definitions,\n        AST_Defun,\n        AST_Destructured,\n        AST_DestructuredArray,\n        AST_DestructuredKeyVal,\n        AST_DestructuredObject,\n        AST_Destructuring,\n        AST_Directive,\n        AST_Do,\n        AST_Dot,\n        AST_DotHash,\n        AST_EmptyStatement,\n        AST_Expansion,\n        AST_Export,\n        AST_ExportDeclaration,\n        AST_False,\n        AST_Finally,\n        AST_For,\n        AST_ForIn,\n        AST_ForOf,\n        AST_Function,\n        AST_Hole,\n        AST_If,\n        AST_Import,\n        AST_ImportMeta,\n        AST_Infinity,\n        AST_IterationStatement,\n        AST_Label,\n        AST_LabeledStatement,\n        AST_LabelRef,\n        AST_Let,\n        AST_NameMapping,\n        AST_New,\n        AST_NewTarget,\n        AST_Node,\n        AST_Null,\n        AST_Number,\n        AST_Object,\n        AST_ObjectGetter,\n        AST_ObjectKeyVal,\n        AST_ObjectMethod,\n        AST_ObjectProperty,\n        AST_ObjectSetter,\n        AST_PrefixedTemplateString,\n        AST_PropAccess,\n        AST_RegExp,\n        AST_Return,\n        AST_Sequence,\n        AST_SimpleStatement,\n        AST_Spread,\n        AST_String,\n        AST_Sub,\n        AST_Super,\n        AST_Switch,\n        AST_SymbolCatch,\n        AST_SymbolClass,\n        AST_SymbolClassProperty,\n        AST_SymbolConst,\n        AST_SymbolDeclaration,\n        AST_SymbolDefClass,\n        AST_SymbolDefun,\n        AST_SymbolExport,\n        AST_SymbolExportForeign,\n        AST_SymbolFunarg,\n        AST_SymbolImport,\n        AST_SymbolImportForeign,\n        AST_SymbolLambda,\n        AST_SymbolLet,\n        AST_SymbolMethod,\n        AST_SymbolRef,\n        AST_SymbolVar,\n        AST_Template,\n        AST_TemplateSegment,\n        AST_TemplateString,\n        AST_This,\n        AST_SymbolPrivateProperty,\n        AST_Throw,\n        AST_Token,\n        AST_Toplevel,\n        AST_True,\n        AST_Try,\n        AST_TryBlock,\n        AST_UnaryPostfix,\n        AST_UnaryPrefix,\n        AST_Var,\n        AST_VarDef,\n        AST_While,\n        AST_With,\n        AST_Yield,\n        _INLINE,\n        _NOINLINE,\n        _PURE,\n        _KEY,\n        _MANGLEPROP,\n    } = m_ast;\n\n    var KEYWORDS = \"break case catch class const continue debugger default delete do else extends finally for function if in instanceof new return switch throw try typeof var void while with\";\n    var KEYWORDS_ATOM = \"false null true\";\n    var RESERVED_WORDS = [\n        \"abstract async await boolean byte char double enum export final float goto implements import int interface let long native package private protected public short static super synchronized this throws transient volatile yield\",\n        KEYWORDS_ATOM,\n        KEYWORDS,\n    ].join(\" \");\n    var KEYWORDS_BEFORE_EXPRESSION = \"return new delete throw else case\";\n\n    KEYWORDS = makePredicate(KEYWORDS);\n    RESERVED_WORDS = makePredicate(RESERVED_WORDS);\n    KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);\n    KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);\n\n    var RE_BIN_NUMBER = /^0b([01]+)$/i;\n    var RE_HEX_NUMBER = /^0x([0-9a-f]+)$/i;\n    var RE_OCT_NUMBER = /^0o?([0-7]+)$/i;\n\n    var OPERATORS = makePredicate([\n        \"in\",\n        \"instanceof\",\n        \"typeof\",\n        \"new\",\n        \"void\",\n        \"delete\",\n        \"++\",\n        \"--\",\n        \"+\",\n        \"-\",\n        \"!\",\n        \"~\",\n        \"&\",\n        \"|\",\n        \"^\",\n        \"*\",\n        \"/\",\n        \"%\",\n        \"**\",\n        \">>\",\n        \"<<\",\n        \">>>\",\n        \"<\",\n        \">\",\n        \"<=\",\n        \">=\",\n        \"==\",\n        \"===\",\n        \"!=\",\n        \"!==\",\n        \"?\",\n        \"=\",\n        \"+=\",\n        \"-=\",\n        \"/=\",\n        \"*=\",\n        \"%=\",\n        \"**=\",\n        \">>=\",\n        \"<<=\",\n        \">>>=\",\n        \"&=\",\n        \"|=\",\n        \"^=\",\n        \"&&\",\n        \"||\",\n        \"??\",\n        \"&&=\",\n        \"||=\",\n        \"??=\",\n    ]);\n\n    var NEWLINE_CHARS = \"\\n\\r\\u2028\\u2029\";\n    var OPERATOR_CHARS = \"+-*&%=<>!?|~^\";\n    var PUNC_OPENERS = \"[{(\";\n    var PUNC_SEPARATORS = \",;:\";\n    var PUNC_CLOSERS = \")}]\";\n    var PUNC_AFTER_EXPRESSION = PUNC_SEPARATORS + PUNC_CLOSERS;\n    var PUNC_BEFORE_EXPRESSION = PUNC_OPENERS + PUNC_SEPARATORS;\n    var PUNC_CHARS = PUNC_BEFORE_EXPRESSION + \"`\" + PUNC_CLOSERS;\n    var WHITESPACE_CHARS = NEWLINE_CHARS + \" \\u00a0\\t\\f\\u000b\\u200b\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\uFEFF\";\n    var NON_IDENTIFIER_CHARS = makePredicate(characters(\"./'\\\"#\" + OPERATOR_CHARS + PUNC_CHARS + WHITESPACE_CHARS));\n\n    NEWLINE_CHARS = makePredicate(characters(NEWLINE_CHARS));\n    OPERATOR_CHARS = makePredicate(characters(OPERATOR_CHARS));\n    PUNC_AFTER_EXPRESSION = makePredicate(characters(PUNC_AFTER_EXPRESSION));\n    PUNC_BEFORE_EXPRESSION = makePredicate(characters(PUNC_BEFORE_EXPRESSION));\n    PUNC_CHARS = makePredicate(characters(PUNC_CHARS));\n    WHITESPACE_CHARS = makePredicate(characters(WHITESPACE_CHARS));\n\n    /* -----[ Tokenizer ]----- */\n\n    function is_surrogate_pair_head(code) {\n        return code >= 0xd800 && code <= 0xdbff;\n    }\n\n    function is_surrogate_pair_tail(code) {\n        return code >= 0xdc00 && code <= 0xdfff;\n    }\n\n    function is_digit(code) {\n        return code >= 48 && code <= 57;\n    }\n\n    function is_identifier_char(ch) {\n        return !NON_IDENTIFIER_CHARS[ch];\n    }\n\n    function is_identifier_string(str) {\n        return /^[a-z_$][a-z0-9_$]*$/i.test(str);\n    }\n\n    function decode_escape_sequence(seq) {\n        switch (seq[0]) {\n          case \"b\": return \"\\b\";\n          case \"f\": return \"\\f\";\n          case \"n\": return \"\\n\";\n          case \"r\": return \"\\r\";\n          case \"t\": return \"\\t\";\n          case \"u\":\n            var code;\n            if (seq[1] == \"{\" && seq.slice(-1) == \"}\") {\n                code = seq.slice(2, -1);\n            } else if (seq.length == 5) {\n                code = seq.slice(1);\n            } else {\n                return;\n            }\n            var num = parseInt(code, 16);\n            if (num < 0 || isNaN(num)) return;\n            if (num < 0x10000) return String.fromCharCode(num);\n            if (num > 0x10ffff) return;\n            return String.fromCharCode((num >> 10) + 0xd7c0) + String.fromCharCode((num & 0x03ff) + 0xdc00);\n          case \"v\": return \"\\u000b\";\n          case \"x\":\n            if (seq.length != 3) return;\n            var num = parseInt(seq.slice(1), 16);\n            if (num < 0 || isNaN(num)) return;\n            return String.fromCharCode(num);\n          case \"\\r\":\n          case \"\\n\":\n            return \"\";\n          default:\n            if (seq == \"0\") return \"\\0\";\n            if (seq[0] >= \"0\" && seq[0] <= \"9\") return;\n            return seq;\n        }\n    }\n\n    function parse_js_number(num) {\n        var match;\n        if (match = RE_BIN_NUMBER.exec(num)) return parseInt(match[1], 2);\n        if (match = RE_HEX_NUMBER.exec(num)) return parseInt(match[1], 16);\n        if (match = RE_OCT_NUMBER.exec(num)) return parseInt(match[1], 8);\n        var val = parseFloat(num);\n        if (val == num) return val;\n    }\n\n    function JS_Parse_Error(message, filename, line, col, pos) {\n        this.message = message;\n        this.filename = filename;\n        this.line = line;\n        this.col = col;\n        this.pos = pos;\n    }\n    JS_Parse_Error.prototype = Object.create(Error.prototype);\n    JS_Parse_Error.prototype.constructor = JS_Parse_Error;\n    JS_Parse_Error.prototype.name = \"SyntaxError\";\n    configure_error_stack(JS_Parse_Error);\n\n    function js_error(message, filename, line, col, pos) {\n        throw new JS_Parse_Error(message, filename, line, col, pos);\n    }\n\n    function is_token(token, type, val) {\n        return token.type == type && (val == null || token.value == val);\n    }\n\n    var EX_EOF = {};\n\n    function tokenizer($TEXT, filename, html5_comments, shebang) {\n\n        var S = {\n            text            : $TEXT,\n            filename        : filename,\n            pos             : 0,\n            tokpos          : 0,\n            line            : 1,\n            tokline         : 0,\n            col             : 0,\n            tokcol          : 0,\n            newline_before  : false,\n            regex_allowed   : false,\n            comments_before : [],\n            directives      : Object.create(null),\n            read_template   : with_eof_error(\"Unterminated template literal\", function(strings) {\n                var s = \"\";\n                for (;;) {\n                    var ch = read();\n                    switch (ch) {\n                      case \"\\\\\":\n                        ch += read();\n                        break;\n                      case \"`\":\n                        strings.push(s);\n                        return;\n                      case \"$\":\n                        if (peek() == \"{\") {\n                            next();\n                            strings.push(s);\n                            S.regex_allowed = true;\n                            return true;\n                        }\n                    }\n                    s += ch;\n                }\n\n                function read() {\n                    var ch = next(true, true);\n                    return ch == \"\\r\" ? \"\\n\" : ch;\n                }\n            }),\n        };\n        var prev_was_dot = false;\n\n        function peek() {\n            return S.text.charAt(S.pos);\n        }\n\n        function next(signal_eof, in_string) {\n            var ch = S.text.charAt(S.pos++);\n            if (signal_eof && !ch)\n                throw EX_EOF;\n            if (NEWLINE_CHARS[ch]) {\n                S.col = 0;\n                S.line++;\n                if (!in_string) S.newline_before = true;\n                if (ch == \"\\r\" && peek() == \"\\n\") {\n                    // treat `\\r\\n` as `\\n`\n                    S.pos++;\n                    ch = \"\\n\";\n                }\n            } else {\n                S.col++;\n            }\n            return ch;\n        }\n\n        function forward(i) {\n            while (i-- > 0) next();\n        }\n\n        function looking_at(str) {\n            return S.text.substr(S.pos, str.length) == str;\n        }\n\n        function find_eol() {\n            var text = S.text;\n            for (var i = S.pos; i < S.text.length; ++i) {\n                if (NEWLINE_CHARS[text[i]]) return i;\n            }\n            return -1;\n        }\n\n        function find(what, signal_eof) {\n            var pos = S.text.indexOf(what, S.pos);\n            if (signal_eof && pos == -1) throw EX_EOF;\n            return pos;\n        }\n\n        function start_token() {\n            S.tokline = S.line;\n            S.tokcol = S.col;\n            S.tokpos = S.pos;\n        }\n\n        function token(type, value, is_comment) {\n            S.regex_allowed = type == \"operator\" && !UNARY_POSTFIX[value]\n                || type == \"keyword\" && KEYWORDS_BEFORE_EXPRESSION[value]\n                || type == \"punc\" && PUNC_BEFORE_EXPRESSION[value];\n            if (type == \"punc\" && value == \".\") prev_was_dot = true;\n            else if (!is_comment) prev_was_dot = false;\n            var ret = {\n                type    : type,\n                value   : value,\n                line    : S.tokline,\n                col     : S.tokcol,\n                pos     : S.tokpos,\n                endline : S.line,\n                endcol  : S.col,\n                endpos  : S.pos,\n                nlb     : S.newline_before,\n                file    : filename\n            };\n            if (/^(?:num|string|regexp)$/i.test(type)) {\n                ret.raw = $TEXT.substring(ret.pos, ret.endpos);\n            }\n            if (!is_comment) {\n                ret.comments_before = S.comments_before;\n                ret.comments_after = S.comments_before = [];\n            }\n            S.newline_before = false;\n            return new AST_Token(ret);\n        }\n\n        function skip_whitespace() {\n            while (WHITESPACE_CHARS[peek()])\n                next();\n        }\n\n        function read_while(pred) {\n            var ret = \"\", ch;\n            while ((ch = peek()) && pred(ch, ret)) ret += next();\n            return ret;\n        }\n\n        function parse_error(err) {\n            js_error(err, filename, S.tokline, S.tokcol, S.tokpos);\n        }\n\n        function is_octal(num) {\n            return /^0[0-7_]+$/.test(num);\n        }\n\n        function read_num(prefix) {\n            var has_e = false, after_e = false, has_x = false, has_dot = prefix == \".\";\n            var num = read_while(function(ch, str) {\n                switch (ch) {\n                  case \"x\": case \"X\":\n                    return has_x ? false : (has_x = true);\n                  case \"e\": case \"E\":\n                    return has_x ? true : has_e ? false : (has_e = after_e = true);\n                  case \"+\": case \"-\":\n                    return after_e;\n                  case (after_e = false, \".\"):\n                    return has_dot || has_e || has_x || is_octal(str) ? false : (has_dot = true);\n                }\n                return /[_0-9a-dfo]/i.test(ch);\n            });\n            if (prefix) num = prefix + num;\n            if (is_octal(num)) {\n                if (next_token.has_directive(\"use strict\")) parse_error(\"Legacy octal literals are not allowed in strict mode\");\n            } else {\n                num = num.replace(has_x ? /([1-9a-f]|.0)_(?=[0-9a-f])/gi : /([1-9]|.0)_(?=[0-9])/gi, \"$1\");\n            }\n            var valid = parse_js_number(num);\n            if (isNaN(valid)) parse_error(\"Invalid syntax: \" + num);\n            if (has_dot || has_e || peek() != \"n\") return token(\"num\", valid);\n            return token(\"bigint\", num.toLowerCase() + next());\n        }\n\n        function read_escaped_char(in_string) {\n            var seq = next(true, in_string);\n            if (seq >= \"0\" && seq <= \"7\") return read_octal_escape_sequence(seq);\n            if (seq == \"u\") {\n                var ch = next(true, in_string);\n                seq += ch;\n                if (ch != \"{\") {\n                    seq += next(true, in_string) + next(true, in_string) + next(true, in_string);\n                } else do {\n                    ch = next(true, in_string);\n                    seq += ch;\n                } while (ch != \"}\");\n            } else if (seq == \"x\") {\n                seq += next(true, in_string) + next(true, in_string);\n            }\n            var str = decode_escape_sequence(seq);\n            if (typeof str != \"string\") parse_error(\"Invalid escape sequence: \\\\\" + seq);\n            return str;\n        }\n\n        function read_octal_escape_sequence(ch) {\n            // Read\n            var p = peek();\n            if (p >= \"0\" && p <= \"7\") {\n                ch += next(true);\n                if (ch[0] <= \"3\" && (p = peek()) >= \"0\" && p <= \"7\")\n                    ch += next(true);\n            }\n\n            // Parse\n            if (ch === \"0\") return \"\\0\";\n            if (ch.length > 0 && next_token.has_directive(\"use strict\"))\n                parse_error(\"Legacy octal escape sequences are not allowed in strict mode\");\n            return String.fromCharCode(parseInt(ch, 8));\n        }\n\n        var read_string = with_eof_error(\"Unterminated string constant\", function(quote_char) {\n            var quote = next(), ret = \"\";\n            for (;;) {\n                var ch = next(true, true);\n                if (ch == \"\\\\\") ch = read_escaped_char(true);\n                else if (NEWLINE_CHARS[ch]) parse_error(\"Unterminated string constant\");\n                else if (ch == quote) break;\n                ret += ch;\n            }\n            var tok = token(\"string\", ret);\n            tok.quote = quote_char;\n            return tok;\n        });\n\n        function skip_line_comment(type) {\n            var regex_allowed = S.regex_allowed;\n            var i = find_eol(), ret;\n            if (i == -1) {\n                ret = S.text.substr(S.pos);\n                S.pos = S.text.length;\n            } else {\n                ret = S.text.substring(S.pos, i);\n                S.pos = i;\n            }\n            S.col = S.tokcol + (S.pos - S.tokpos);\n            S.comments_before.push(token(type, ret, true));\n            S.regex_allowed = regex_allowed;\n            return next_token;\n        }\n\n        var skip_multiline_comment = with_eof_error(\"Unterminated multiline comment\", function() {\n            var regex_allowed = S.regex_allowed;\n            var i = find(\"*/\", true);\n            var text = S.text.substring(S.pos, i).replace(/\\r\\n|\\r|\\u2028|\\u2029/g, \"\\n\");\n            // update stream position\n            forward(text.length /* doesn't count \\r\\n as 2 char while S.pos - i does */ + 2);\n            S.comments_before.push(token(\"comment2\", text, true));\n            S.regex_allowed = regex_allowed;\n            return next_token;\n        });\n\n        function read_name() {\n            var backslash = false, ch, escaped = false, name = peek() == \"#\" ? next() : \"\";\n            while (ch = peek()) {\n                if (!backslash) {\n                    if (ch == \"\\\\\") escaped = backslash = true, next();\n                    else if (is_identifier_char(ch)) name += next();\n                    else break;\n                } else {\n                    if (ch != \"u\") parse_error(\"Expecting UnicodeEscapeSequence -- uXXXX\");\n                    ch = read_escaped_char();\n                    if (!is_identifier_char(ch)) parse_error(\"Unicode char: \" + ch.charCodeAt(0) + \" is not valid in identifier\");\n                    name += ch;\n                    backslash = false;\n                }\n            }\n            if (KEYWORDS[name] && escaped) {\n                var hex = name.charCodeAt(0).toString(16).toUpperCase();\n                name = \"\\\\u\" + \"0000\".substr(hex.length) + hex + name.slice(1);\n            }\n            return name;\n        }\n\n        var read_regexp = with_eof_error(\"Unterminated regular expression\", function(source) {\n            var prev_backslash = false, ch, in_class = false;\n            while ((ch = next(true))) if (NEWLINE_CHARS[ch]) {\n                parse_error(\"Unexpected line terminator\");\n            } else if (prev_backslash) {\n                source += \"\\\\\" + ch;\n                prev_backslash = false;\n            } else if (ch == \"[\") {\n                in_class = true;\n                source += ch;\n            } else if (ch == \"]\" && in_class) {\n                in_class = false;\n                source += ch;\n            } else if (ch == \"/\" && !in_class) {\n                break;\n            } else if (ch == \"\\\\\") {\n                prev_backslash = true;\n            } else {\n                source += ch;\n            }\n            var mods = read_name();\n            try {\n                var regexp = new RegExp(source, mods);\n                regexp.raw_source = source;\n                return token(\"regexp\", regexp);\n            } catch (e) {\n                parse_error(e.message);\n            }\n        });\n\n        function read_operator(prefix) {\n            function grow(op) {\n                if (!peek()) return op;\n                var bigger = op + peek();\n                if (OPERATORS[bigger]) {\n                    next();\n                    return grow(bigger);\n                } else {\n                    return op;\n                }\n            }\n            return token(\"operator\", grow(prefix || next()));\n        }\n\n        function handle_slash() {\n            next();\n            switch (peek()) {\n              case \"/\":\n                next();\n                return skip_line_comment(\"comment1\");\n              case \"*\":\n                next();\n                return skip_multiline_comment();\n            }\n            return S.regex_allowed ? read_regexp(\"\") : read_operator(\"/\");\n        }\n\n        function handle_dot() {\n            next();\n            if (looking_at(\"..\")) return token(\"operator\", \".\" + next() + next());\n            return is_digit(peek().charCodeAt(0)) ? read_num(\".\") : token(\"punc\", \".\");\n        }\n\n        function read_word() {\n            var word = read_name();\n            if (prev_was_dot) return token(\"name\", word);\n            return KEYWORDS_ATOM[word] ? token(\"atom\", word)\n                : !KEYWORDS[word] ? token(\"name\", word)\n                : OPERATORS[word] ? token(\"operator\", word)\n                : token(\"keyword\", word);\n        }\n\n        function with_eof_error(eof_error, cont) {\n            return function(x) {\n                try {\n                    return cont(x);\n                } catch (ex) {\n                    if (ex === EX_EOF) parse_error(eof_error);\n                    else throw ex;\n                }\n            };\n        }\n\n        function next_token(force_regexp) {\n            if (force_regexp != null)\n                return read_regexp(force_regexp);\n            if (shebang && S.pos == 0 && looking_at(\"#!\")) {\n                start_token();\n                forward(2);\n                skip_line_comment(\"comment5\");\n            }\n            for (;;) {\n                skip_whitespace();\n                start_token();\n                if (html5_comments) {\n                    if (looking_at(\"<!--\")) {\n                        forward(4);\n                        skip_line_comment(\"comment3\");\n                        continue;\n                    }\n                    if (looking_at(\"-->\") && S.newline_before) {\n                        forward(3);\n                        skip_line_comment(\"comment4\");\n                        continue;\n                    }\n                }\n                var ch = peek();\n                if (!ch) return token(\"eof\");\n                var code = ch.charCodeAt(0);\n                switch (code) {\n                  case 34: case 39: return read_string(ch);\n                  case 46: return handle_dot();\n                  case 47:\n                    var tok = handle_slash();\n                    if (tok === next_token) continue;\n                    return tok;\n                }\n                if (is_digit(code)) return read_num();\n                if (PUNC_CHARS[ch]) return token(\"punc\", next());\n                if (looking_at(\"=>\")) return token(\"punc\", next() + next());\n                if (OPERATOR_CHARS[ch]) return read_operator();\n                if (code == 35 || code == 92 || !NON_IDENTIFIER_CHARS[ch]) return read_word();\n                break;\n            }\n            parse_error(\"Unexpected character '\" + ch + \"'\");\n        }\n\n        next_token.context = function(nc) {\n            if (nc) S = nc;\n            return S;\n        };\n\n        next_token.add_directive = function(directive) {\n            S.directives[directive] = true;\n        }\n\n        next_token.push_directives_stack = function() {\n            S.directives = Object.create(S.directives);\n        }\n\n        next_token.pop_directives_stack = function() {\n            S.directives = Object.getPrototypeOf(S.directives);\n        }\n\n        next_token.has_directive = function(directive) {\n            return !!S.directives[directive];\n        }\n\n        return next_token;\n    }\n\n    /* -----[ Parser (constants) ]----- */\n\n    var UNARY_PREFIX = makePredicate(\"typeof void delete -- ++ ! ~ - +\");\n\n    var UNARY_POSTFIX = makePredicate(\"-- ++\");\n\n    var ASSIGNMENT = makePredicate(\"= += -= /= *= %= **= >>= <<= >>>= &= |= ^= &&= ||= ??=\");\n\n    var PRECEDENCE = function(a, ret) {\n        for (var i = 0; i < a.length;) {\n            var b = a[i++];\n            for (var j = 0; j < b.length; j++) {\n                ret[b[j]] = i;\n            }\n        }\n        return ret;\n    }([\n        [\"??\"],\n        [\"||\"],\n        [\"&&\"],\n        [\"|\"],\n        [\"^\"],\n        [\"&\"],\n        [\"==\", \"===\", \"!=\", \"!==\"],\n        [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n        [\">>\", \"<<\", \">>>\"],\n        [\"+\", \"-\"],\n        [\"*\", \"/\", \"%\"],\n        [\"**\"],\n    ], {});\n\n    var ATOMIC_START_TOKEN = makePredicate(\"atom bigint num regexp string\");\n\n    /* -----[ Parser ]----- */\n\n    function parse($TEXT, options) {\n        options = defaults(options, {\n            bare_returns   : false,\n            expression     : false,\n            filename       : null,\n            html5_comments : true,\n            module         : false,\n            shebang        : true,\n            strict         : false,\n            toplevel       : null,\n        }, true);\n\n        var S = {\n            input         : typeof $TEXT == \"string\"\n                            ? tokenizer($TEXT, options.filename, options.html5_comments, options.shebang)\n                            : $TEXT,\n            in_async      : false,\n            in_directives : true,\n            in_funarg     : -1,\n            in_function   : 0,\n            in_generator  : false,\n            in_loop       : 0,\n            labels        : [],\n            peeked        : null,\n            prev          : null,\n            token         : null,\n        };\n\n        S.token = next();\n\n        function is(type, value) {\n            return is_token(S.token, type, value);\n        }\n\n        function peek() {\n            return S.peeked || (S.peeked = S.input());\n        }\n\n        function next() {\n            S.prev = S.token;\n            if (S.peeked) {\n                S.token = S.peeked;\n                S.peeked = null;\n            } else {\n                S.token = S.input();\n            }\n            S.in_directives = S.in_directives && (\n                S.token.type == \"string\" || is(\"punc\", \";\")\n            );\n            return S.token;\n        }\n\n        function prev() {\n            return S.prev;\n        }\n\n        function croak(msg, line, col, pos) {\n            var ctx = S.input.context();\n            js_error(msg,\n                     ctx.filename,\n                     line != null ? line : ctx.tokline,\n                     col != null ? col : ctx.tokcol,\n                     pos != null ? pos : ctx.tokpos);\n        }\n\n        function token_error(token, msg) {\n            croak(msg, token.line, token.col);\n        }\n\n        function token_to_string(type, value) {\n            return type + (value === undefined ? \"\" : \" «\" + value + \"»\");\n        }\n\n        function unexpected(token) {\n            if (token == null) token = S.token;\n            token_error(token, \"Unexpected token: \" + token_to_string(token.type, token.value));\n        }\n\n        function expect_token(type, val) {\n            if (is(type, val)) return next();\n            token_error(S.token, \"Unexpected token: \" + token_to_string(S.token.type, S.token.value) + \", expected: \" + token_to_string(type, val));\n        }\n\n        function expect(punc) {\n            return expect_token(\"punc\", punc);\n        }\n\n        function has_newline_before(token) {\n            return token.nlb || !all(token.comments_before, function(comment) {\n                return !comment.nlb;\n            });\n        }\n\n        function can_insert_semicolon() {\n            return !options.strict\n                && (is(\"eof\") || is(\"punc\", \"}\") || has_newline_before(S.token));\n        }\n\n        function semicolon(optional) {\n            if (is(\"punc\", \";\")) next();\n            else if (!optional && !can_insert_semicolon()) expect(\";\");\n        }\n\n        function parenthesized() {\n            expect(\"(\");\n            var exp = expression();\n            expect(\")\");\n            return exp;\n        }\n\n        function embed_tokens(parser) {\n            return function() {\n                var start = S.token;\n                var expr = parser.apply(null, arguments);\n                var end = prev();\n                expr.start = start;\n                expr.end = end;\n                return expr;\n            };\n        }\n\n        function handle_regexp() {\n            if (is(\"operator\", \"/\") || is(\"operator\", \"/=\")) {\n                S.peeked = null;\n                S.token = S.input(S.token.value.substr(1)); // force regexp\n            }\n        }\n\n        var statement = embed_tokens(function(toplevel) {\n            handle_regexp();\n            switch (S.token.type) {\n              case \"string\":\n                var dir = S.in_directives;\n                var body = expression();\n                if (dir) {\n                    if (body instanceof AST_String) {\n                        var value = body.start.raw.slice(1, -1);\n                        S.input.add_directive(value);\n                        body.value = value;\n                    } else {\n                        S.in_directives = dir = false;\n                    }\n                }\n                semicolon();\n                return dir ? new AST_Directive(body) : new AST_SimpleStatement({ body: body });\n              case \"num\":\n              case \"bigint\":\n              case \"regexp\":\n              case \"operator\":\n              case \"atom\":\n                return simple_statement();\n\n              case \"name\":\n                switch (S.token.value) {\n                  case \"async\":\n                    if (is_token(peek(), \"keyword\", \"function\")) {\n                        next();\n                        next();\n                        if (!is(\"operator\", \"*\")) return function_(AST_AsyncDefun);\n                        next();\n                        return function_(AST_AsyncGeneratorDefun);\n                    }\n                    break;\n                  case \"await\":\n                    if (S.in_async) return simple_statement();\n                    break;\n                  case \"export\":\n                    if (!toplevel && options.module !== \"\") unexpected();\n                    next();\n                    return export_();\n                  case \"import\":\n                    var token = peek();\n                    if (token.type == \"punc\" && /^[(.]$/.test(token.value)) break;\n                    if (!toplevel && options.module !== \"\") unexpected();\n                    next();\n                    return import_();\n                  case \"let\":\n                    if (is_vardefs()) {\n                        next();\n                        var node = let_();\n                        semicolon();\n                        return node;\n                    }\n                    break;\n                  case \"yield\":\n                    if (S.in_generator) return simple_statement();\n                    break;\n                }\n                return is_token(peek(), \"punc\", \":\")\n                    ? labeled_statement()\n                    : simple_statement();\n\n              case \"punc\":\n                switch (S.token.value) {\n                  case \"{\":\n                    return new AST_BlockStatement({\n                        start : S.token,\n                        body  : block_(),\n                        end   : prev()\n                    });\n                  case \"[\":\n                  case \"(\":\n                  case \"`\":\n                    return simple_statement();\n                  case \";\":\n                    S.in_directives = false;\n                    next();\n                    return new AST_EmptyStatement();\n                  default:\n                    unexpected();\n                }\n\n              case \"keyword\":\n                switch (S.token.value) {\n                  case \"break\":\n                    next();\n                    return break_cont(AST_Break);\n\n                  case \"class\":\n                    next();\n                    return class_(AST_DefClass);\n\n                  case \"const\":\n                    next();\n                    var node = const_();\n                    semicolon();\n                    return node;\n\n                  case \"continue\":\n                    next();\n                    return break_cont(AST_Continue);\n\n                  case \"debugger\":\n                    next();\n                    semicolon();\n                    return new AST_Debugger();\n\n                  case \"do\":\n                    next();\n                    var body = in_loop(statement);\n                    expect_token(\"keyword\", \"while\");\n                    var condition = parenthesized();\n                    semicolon(true);\n                    return new AST_Do({\n                        body      : body,\n                        condition : condition,\n                    });\n\n                  case \"while\":\n                    next();\n                    return new AST_While({\n                        condition : parenthesized(),\n                        body      : in_loop(statement),\n                    });\n\n                  case \"for\":\n                    next();\n                    return for_();\n\n                  case \"function\":\n                    next();\n                    if (!is(\"operator\", \"*\")) return function_(AST_Defun);\n                    next();\n                    return function_(AST_GeneratorDefun);\n\n                  case \"if\":\n                    next();\n                    return if_();\n\n                  case \"return\":\n                    if (S.in_function == 0 && !options.bare_returns)\n                        croak(\"'return' outside of function\");\n                    next();\n                    var value = null;\n                    if (is(\"punc\", \";\")) {\n                        next();\n                    } else if (!can_insert_semicolon()) {\n                        value = expression();\n                        semicolon();\n                    }\n                    return new AST_Return({ value: value });\n\n                  case \"switch\":\n                    next();\n                    return new AST_Switch({\n                        expression : parenthesized(),\n                        body       : in_loop(switch_body_),\n                    });\n\n                  case \"throw\":\n                    next();\n                    if (has_newline_before(S.token))\n                        croak(\"Illegal newline after 'throw'\");\n                    var value = expression();\n                    semicolon();\n                    return new AST_Throw({ value: value });\n\n                  case \"try\":\n                    next();\n                    return try_();\n\n                  case \"var\":\n                    next();\n                    var node = var_();\n                    semicolon();\n                    return node;\n\n                  case \"with\":\n                    if (S.input.has_directive(\"use strict\")) {\n                        croak(\"Strict mode may not include a with statement\");\n                    }\n                    next();\n                    return new AST_With({\n                        expression : parenthesized(),\n                        body       : statement(),\n                    });\n                }\n            }\n            unexpected();\n        });\n\n        function labeled_statement() {\n            var label = as_symbol(AST_Label);\n            if (!all(S.labels, function(l) {\n                return l.name != label.name;\n            })) {\n                // ECMA-262, 12.12: An ECMAScript program is considered\n                // syntactically incorrect if it contains a\n                // LabelledStatement that is enclosed by a\n                // LabelledStatement with the same Identifier as label.\n                croak(\"Label \" + label.name + \" defined twice\");\n            }\n            expect(\":\");\n            S.labels.push(label);\n            var stat = statement();\n            S.labels.pop();\n            if (!(stat instanceof AST_IterationStatement)) {\n                // check for `continue` that refers to this label.\n                // those should be reported as syntax errors.\n                // https://github.com/mishoo/UglifyJS/issues/287\n                label.references.forEach(function(ref) {\n                    if (ref instanceof AST_Continue) {\n                        token_error(ref.label.start, \"Continue label `\" + label.name + \"` must refer to IterationStatement\");\n                    }\n                });\n            }\n            return new AST_LabeledStatement({ body: stat, label: label });\n        }\n\n        function simple_statement() {\n            var body = expression();\n            semicolon();\n            return new AST_SimpleStatement({ body: body });\n        }\n\n        function break_cont(type) {\n            var label = null, ldef;\n            if (!can_insert_semicolon()) {\n                label = as_symbol(AST_LabelRef, true);\n            }\n            if (label != null) {\n                ldef = find_if(function(l) {\n                    return l.name == label.name;\n                }, S.labels);\n                if (!ldef) token_error(label.start, \"Undefined label \" + label.name);\n                label.thedef = ldef;\n            } else if (S.in_loop == 0) croak(type.TYPE + \" not inside a loop or switch\");\n            semicolon();\n            var stat = new type({ label: label });\n            if (ldef) ldef.references.push(stat);\n            return stat;\n        }\n\n        function has_modifier(name, no_nlb) {\n            if (!is(\"name\", name)) return;\n            var token = peek();\n            if (!token) return;\n            if (is_token(token, \"operator\", \"=\")) return;\n            if (token.type == \"punc\" && /^[(;}]$/.test(token.value)) return;\n            if (no_nlb && has_newline_before(token)) return;\n            return next();\n        }\n\n        function class_(ctor) {\n            var was_async = S.in_async;\n            var was_gen = S.in_generator;\n            S.input.push_directives_stack();\n            S.input.add_directive(\"use strict\");\n            var name;\n            if (ctor === AST_DefClass) {\n                name = as_symbol(AST_SymbolDefClass);\n            } else {\n                name = as_symbol(AST_SymbolClass, true);\n            }\n            var parent = null;\n            if (is(\"keyword\", \"extends\")) {\n                next();\n                handle_regexp();\n                parent = expr_atom(true);\n            }\n            expect(\"{\");\n            var props = [];\n            while (!is(\"punc\", \"}\")) {\n                if (is(\"punc\", \";\")) {\n                    next();\n                    continue;\n                }\n                var start = S.token;\n                var fixed = !!has_modifier(\"static\");\n                var async = has_modifier(\"async\", true);\n                if (is(\"operator\", \"*\")) {\n                    next();\n                    var internal = is(\"name\") && /^#/.test(S.token.value);\n                    var key = as_property_key();\n                    var gen_start = S.token;\n                    var gen = function_(async ? AST_AsyncGeneratorFunction : AST_GeneratorFunction);\n                    gen.start = gen_start;\n                    gen.end = prev();\n                    props.push(new AST_ClassMethod({\n                        start: start,\n                        static: fixed,\n                        private: internal,\n                        key: key,\n                        value: gen,\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                if (fixed && is(\"punc\", \"{\")) {\n                    props.push(new AST_ClassInit({\n                        start: start,\n                        value: new AST_ClassInitBlock({\n                            start: start,\n                            body: block_(),\n                            end: prev(),\n                        }),\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                var internal = is(\"name\") && /^#/.test(S.token.value);\n                var key = as_property_key();\n                if (is(\"punc\", \"(\")) {\n                    var func_start = S.token;\n                    var func = function_(async ? AST_AsyncFunction : AST_Function);\n                    func.start = func_start;\n                    func.end = prev();\n                    props.push(new AST_ClassMethod({\n                        start: start,\n                        static: fixed,\n                        private: internal,\n                        key: key,\n                        value: func,\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                if (async) unexpected(async);\n                var value = null;\n                if (is(\"operator\", \"=\")) {\n                    next();\n                    S.in_async = false;\n                    S.in_generator = false;\n                    value = maybe_assign();\n                    S.in_generator = was_gen;\n                    S.in_async = was_async;\n                } else if (!(is(\"punc\", \";\") || is(\"punc\", \"}\"))) {\n                    var type = null;\n                    switch (key) {\n                      case \"get\":\n                        type = AST_ClassGetter;\n                        break;\n                      case \"set\":\n                        type = AST_ClassSetter;\n                        break;\n                    }\n                    if (type) {\n                        props.push(new type({\n                            start: start,\n                            static: fixed,\n                            private: is(\"name\") && /^#/.test(S.token.value),\n                            key: as_property_key(),\n                            value: create_accessor(),\n                            end: prev(),\n                        }));\n                        continue;\n                    }\n                }\n                semicolon();\n                props.push(new AST_ClassField({\n                    start: start,\n                    static: fixed,\n                    private: internal,\n                    key: key,\n                    value: value,\n                    end: prev(),\n                }));\n            }\n            next();\n            S.input.pop_directives_stack();\n            S.in_generator = was_gen;\n            S.in_async = was_async;\n            return new ctor({\n                extends: parent,\n                name: name,\n                properties: props,\n            });\n        }\n\n        function for_() {\n            var await_token = is(\"name\", \"await\") && next();\n            expect(\"(\");\n            var init = null;\n            if (await_token || !is(\"punc\", \";\")) {\n                init = is(\"keyword\", \"const\")\n                    ? (next(), const_(true))\n                    : is(\"name\", \"let\") && is_vardefs()\n                    ? (next(), let_(true))\n                    : is(\"keyword\", \"var\")\n                    ? (next(), var_(true))\n                    : expression(true);\n                var ctor;\n                if (await_token) {\n                    expect_token(\"name\", \"of\");\n                    ctor = AST_ForAwaitOf;\n                } else if (is(\"operator\", \"in\")) {\n                    next();\n                    ctor = AST_ForIn;\n                } else if (is(\"name\", \"of\")) {\n                    next();\n                    ctor = AST_ForOf;\n                }\n                if (ctor) {\n                    if (init instanceof AST_Definitions) {\n                        if (init.definitions.length > 1) {\n                            token_error(init.start, \"Only one variable declaration allowed in for..in/of loop\");\n                        }\n                        if (ctor !== AST_ForIn && init.definitions[0].value) {\n                            token_error(init.definitions[0].value.start, \"No initializers allowed in for..of loop\");\n                        }\n                    } else if (!(is_assignable(init) || (init = to_destructured(init)) instanceof AST_Destructured)) {\n                        token_error(init.start, \"Invalid left-hand side in for..in/of loop\");\n                    }\n                    return for_enum(ctor, init);\n                }\n            }\n            return regular_for(init);\n        }\n\n        function regular_for(init) {\n            expect(\";\");\n            var test = is(\"punc\", \";\") ? null : expression();\n            expect(\";\");\n            var step = is(\"punc\", \")\") ? null : expression();\n            expect(\")\");\n            return new AST_For({\n                init      : init,\n                condition : test,\n                step      : step,\n                body      : in_loop(statement)\n            });\n        }\n\n        function for_enum(ctor, init) {\n            handle_regexp();\n            var obj = expression();\n            expect(\")\");\n            return new ctor({\n                init   : init,\n                object : obj,\n                body   : in_loop(statement)\n            });\n        }\n\n        function to_funarg(node) {\n            if (node instanceof AST_Array) {\n                var rest = null;\n                if (node.elements[node.elements.length - 1] instanceof AST_Spread) {\n                    rest = to_funarg(node.elements.pop().expression);\n                }\n                return new AST_DestructuredArray({\n                    start: node.start,\n                    elements: node.elements.map(to_funarg),\n                    rest: rest,\n                    end: node.end,\n                });\n            }\n            if (node instanceof AST_Assign) return new AST_DefaultValue({\n                start: node.start,\n                name: to_funarg(node.left),\n                value: node.right,\n                end: node.end,\n            });\n            if (node instanceof AST_DefaultValue) {\n                node.name = to_funarg(node.name);\n                return node;\n            }\n            if (node instanceof AST_DestructuredArray) {\n                node.elements = node.elements.map(to_funarg);\n                if (node.rest) node.rest = to_funarg(node.rest);\n                return node;\n            }\n            if (node instanceof AST_DestructuredObject) {\n                node.properties.forEach(function(prop) {\n                    prop.value = to_funarg(prop.value);\n                });\n                if (node.rest) node.rest = to_funarg(node.rest);\n                return node;\n            }\n            if (node instanceof AST_Hole) return node;\n            if (node instanceof AST_Object) {\n                var rest = null;\n                if (node.properties[node.properties.length - 1] instanceof AST_Spread) {\n                    rest = to_funarg(node.properties.pop().expression);\n                }\n                return new AST_DestructuredObject({\n                    start: node.start,\n                    properties: node.properties.map(function(prop) {\n                        if (!(prop instanceof AST_ObjectKeyVal)) token_error(prop.start, \"Invalid destructuring assignment\");\n                        return new AST_DestructuredKeyVal({\n                            start: prop.start,\n                            key: prop.key,\n                            value: to_funarg(prop.value),\n                            end: prop.end,\n                        });\n                    }),\n                    rest: rest,\n                    end: node.end,\n                });\n            }\n            if (node instanceof AST_SymbolFunarg) return node;\n            if (node instanceof AST_SymbolRef) return new AST_SymbolFunarg(node);\n            if (node instanceof AST_Yield) return new AST_SymbolFunarg({\n                start: node.start,\n                name: \"yield\",\n                end: node.end,\n            });\n            token_error(node.start, \"Invalid arrow parameter\");\n        }\n\n        function arrow(exprs, start, async) {\n            var was_async = S.in_async;\n            var was_gen = S.in_generator;\n            S.in_async = async;\n            S.in_generator = false;\n            var was_funarg = S.in_funarg;\n            S.in_funarg = S.in_function;\n            var argnames = exprs.map(to_funarg);\n            var rest = exprs.rest || null;\n            if (rest) rest = to_funarg(rest);\n            S.in_funarg = was_funarg;\n            expect(\"=>\");\n            var body, value;\n            var loop = S.in_loop;\n            var labels = S.labels;\n            ++S.in_function;\n            S.input.push_directives_stack();\n            S.in_loop = 0;\n            S.labels = [];\n            if (is(\"punc\", \"{\")) {\n                S.in_directives = true;\n                body = block_();\n                value = null;\n            } else {\n                body = [];\n                handle_regexp();\n                value = maybe_assign();\n            }\n            var is_strict = S.input.has_directive(\"use strict\");\n            S.input.pop_directives_stack();\n            --S.in_function;\n            S.in_loop = loop;\n            S.labels = labels;\n            S.in_generator = was_gen;\n            S.in_async = was_async;\n            var node = new (async ? AST_AsyncArrow : AST_Arrow)({\n                start: start,\n                argnames: argnames,\n                rest: rest,\n                body: body,\n                value: value,\n                end: prev(),\n            });\n            if (is_strict) node.each_argname(strict_verify_symbol);\n            return node;\n        }\n\n        var function_ = function(ctor) {\n            var was_async = S.in_async;\n            var was_gen = S.in_generator;\n            var name;\n            if (/Defun$/.test(ctor.TYPE)) {\n                name = as_symbol(AST_SymbolDefun);\n                S.in_async = /^Async/.test(ctor.TYPE);\n                S.in_generator = /Generator/.test(ctor.TYPE);\n            } else {\n                S.in_async = /^Async/.test(ctor.TYPE);\n                S.in_generator = /Generator/.test(ctor.TYPE);\n                name = as_symbol(AST_SymbolLambda, true);\n            }\n            if (name && ctor !== AST_Accessor && !(name instanceof AST_SymbolDeclaration))\n                unexpected(prev());\n            expect(\"(\");\n            var was_funarg = S.in_funarg;\n            S.in_funarg = S.in_function;\n            var argnames = expr_list(\")\", !options.strict, false, function() {\n                return maybe_default(AST_SymbolFunarg);\n            });\n            S.in_funarg = was_funarg;\n            var loop = S.in_loop;\n            var labels = S.labels;\n            ++S.in_function;\n            S.in_directives = true;\n            S.input.push_directives_stack();\n            S.in_loop = 0;\n            S.labels = [];\n            var body = block_();\n            var is_strict = S.input.has_directive(\"use strict\");\n            S.input.pop_directives_stack();\n            --S.in_function;\n            S.in_loop = loop;\n            S.labels = labels;\n            S.in_generator = was_gen;\n            S.in_async = was_async;\n            var node = new ctor({\n                name: name,\n                argnames: argnames,\n                rest: argnames.rest || null,\n                body: body,\n            });\n            if (is_strict) {\n                if (name) strict_verify_symbol(name);\n                node.each_argname(strict_verify_symbol);\n            }\n            return node;\n        };\n\n        function if_() {\n            var cond = parenthesized(), body = statement(), alt = null;\n            if (is(\"keyword\", \"else\")) {\n                next();\n                alt = statement();\n            }\n            return new AST_If({\n                condition   : cond,\n                body        : body,\n                alternative : alt,\n            });\n        }\n\n        function is_alias() {\n            return is(\"name\") || is(\"string\") || is_identifier_string(S.token.value);\n        }\n\n        function make_string(token) {\n            return new AST_String({\n                start: token,\n                quote: token.quote,\n                value: token.value,\n                end: token,\n            });\n        }\n\n        function as_path() {\n            var path = S.token;\n            expect_token(\"string\");\n            semicolon();\n            return make_string(path);\n        }\n\n        function export_() {\n            if (is(\"operator\", \"*\")) {\n                var key = S.token;\n                var alias = key;\n                next();\n                if (is(\"name\", \"as\")) {\n                    next();\n                    if (!is_alias()) expect_token(\"name\");\n                    alias = S.token;\n                    next();\n                }\n                expect_token(\"name\", \"from\");\n                return new AST_ExportForeign({\n                    aliases: [ make_string(alias) ],\n                    keys: [ make_string(key) ],\n                    path: as_path(),\n                });\n            }\n            if (is(\"punc\", \"{\")) {\n                next();\n                var aliases = [];\n                var keys = [];\n                while (is_alias()) {\n                    var key = S.token;\n                    next();\n                    keys.push(key);\n                    if (is(\"name\", \"as\")) {\n                        next();\n                        if (!is_alias()) expect_token(\"name\");\n                        aliases.push(S.token);\n                        next();\n                    } else {\n                        aliases.push(key);\n                    }\n                    if (!is(\"punc\", \"}\")) expect(\",\");\n                }\n                expect(\"}\");\n                if (is(\"name\", \"from\")) {\n                    next();\n                    return new AST_ExportForeign({\n                        aliases: aliases.map(make_string),\n                        keys: keys.map(make_string),\n                        path: as_path(),\n                    });\n                }\n                semicolon();\n                return new AST_ExportReferences({\n                    properties: keys.map(function(token, index) {\n                        if (!is_token(token, \"name\")) token_error(token, \"Name expected\");\n                        var sym = _make_symbol(AST_SymbolExport, token);\n                        sym.alias = make_string(aliases[index]);\n                        return sym;\n                    }),\n                });\n            }\n            if (is(\"keyword\", \"default\")) {\n                next();\n                var start = S.token;\n                var body = export_default_decl();\n                if (body) {\n                    body.start = start;\n                    body.end = prev();\n                } else {\n                    handle_regexp();\n                    body = expression();\n                    semicolon();\n                }\n                return new AST_ExportDefault({ body: body });\n            }\n            return new AST_ExportDeclaration({ body: export_decl() });\n        }\n\n        function maybe_named(def, expr) {\n            if (expr.name) {\n                expr = new def(expr);\n                expr.name = new (def === AST_DefClass ? AST_SymbolDefClass : AST_SymbolDefun)(expr.name);\n            }\n            return expr;\n        }\n\n        function export_default_decl() {\n            if (is(\"name\", \"async\")) {\n                if (!is_token(peek(), \"keyword\", \"function\")) return;\n                next();\n                next();\n                if (!is(\"operator\", \"*\")) return maybe_named(AST_AsyncDefun, function_(AST_AsyncFunction));\n                next();\n                return maybe_named(AST_AsyncGeneratorDefun, function_(AST_AsyncGeneratorFunction));\n            } else if (is(\"keyword\")) switch (S.token.value) {\n              case \"class\":\n                next();\n                return maybe_named(AST_DefClass, class_(AST_ClassExpression));\n              case \"function\":\n                next();\n                if (!is(\"operator\", \"*\")) return maybe_named(AST_Defun, function_(AST_Function));\n                next();\n                return maybe_named(AST_GeneratorDefun, function_(AST_GeneratorFunction));\n            }\n        }\n\n        var export_decl = embed_tokens(function() {\n            if (is(\"name\")) switch (S.token.value) {\n              case \"async\":\n                next();\n                expect_token(\"keyword\", \"function\");\n                if (!is(\"operator\", \"*\")) return function_(AST_AsyncDefun);\n                next();\n                return function_(AST_AsyncGeneratorDefun);\n              case \"let\":\n                next();\n                var node = let_();\n                semicolon();\n                return node;\n            } else if (is(\"keyword\")) switch (S.token.value) {\n              case \"class\":\n                next();\n                return class_(AST_DefClass);\n              case \"const\":\n                next();\n                var node = const_();\n                semicolon();\n                return node;\n              case \"function\":\n                next();\n                if (!is(\"operator\", \"*\")) return function_(AST_Defun);\n                next();\n                return function_(AST_GeneratorDefun);\n              case \"var\":\n                next();\n                var node = var_();\n                semicolon();\n                return node;\n            }\n            unexpected();\n        });\n\n        function import_() {\n            var all = null;\n            var def = as_symbol(AST_SymbolImport, true);\n            var props = null;\n            var cont;\n            if (def) {\n                def.key = new AST_String({\n                    start: def.start,\n                    value: \"\",\n                    end: def.end,\n                });\n                if (cont = is(\"punc\", \",\")) next();\n            } else {\n                cont = !is(\"string\");\n            }\n            if (cont) {\n                if (is(\"operator\", \"*\")) {\n                    var key = S.token;\n                    next();\n                    expect_token(\"name\", \"as\");\n                    all = as_symbol(AST_SymbolImport);\n                    all.key = make_string(key);\n                } else {\n                    expect(\"{\");\n                    props = [];\n                    while (is_alias()) {\n                        var alias;\n                        if (is_token(peek(), \"name\", \"as\")) {\n                            var key = S.token;\n                            next();\n                            next();\n                            alias = as_symbol(AST_SymbolImport);\n                            alias.key = make_string(key);\n                        } else {\n                            alias = as_symbol(AST_SymbolImport);\n                            alias.key = new AST_String({\n                                start: alias.start,\n                                value: alias.name,\n                                end: alias.end,\n                            });\n                        }\n                        props.push(alias);\n                        if (!is(\"punc\", \"}\")) expect(\",\");\n                    }\n                    expect(\"}\");\n                }\n            }\n            if (all || def || props) expect_token(\"name\", \"from\");\n            return new AST_Import({\n                all: all,\n                default: def,\n                path: as_path(),\n                properties: props,\n            });\n        }\n\n        function block_() {\n            expect(\"{\");\n            var a = [];\n            while (!is(\"punc\", \"}\")) {\n                if (is(\"eof\")) expect(\"}\");\n                a.push(statement());\n            }\n            next();\n            return a;\n        }\n\n        function switch_body_() {\n            expect(\"{\");\n            var a = [], branch, cur, default_branch, tmp;\n            while (!is(\"punc\", \"}\")) {\n                if (is(\"eof\")) expect(\"}\");\n                if (is(\"keyword\", \"case\")) {\n                    if (branch) branch.end = prev();\n                    cur = [];\n                    branch = new AST_Case({\n                        start      : (tmp = S.token, next(), tmp),\n                        expression : expression(),\n                        body       : cur\n                    });\n                    a.push(branch);\n                    expect(\":\");\n                } else if (is(\"keyword\", \"default\")) {\n                    if (branch) branch.end = prev();\n                    if (default_branch) croak(\"More than one default clause in switch statement\");\n                    cur = [];\n                    branch = new AST_Default({\n                        start : (tmp = S.token, next(), expect(\":\"), tmp),\n                        body  : cur\n                    });\n                    a.push(branch);\n                    default_branch = branch;\n                } else {\n                    if (!cur) unexpected();\n                    cur.push(statement());\n                }\n            }\n            if (branch) branch.end = prev();\n            next();\n            return a;\n        }\n\n        function try_() {\n            var body = block_(), bcatch = null, bfinally = null;\n            if (is(\"keyword\", \"catch\")) {\n                var start = S.token;\n                next();\n                var name = null;\n                if (is(\"punc\", \"(\")) {\n                    next();\n                    name = maybe_destructured(AST_SymbolCatch);\n                    expect(\")\");\n                }\n                bcatch = new AST_Catch({\n                    start   : start,\n                    argname : name,\n                    body    : block_(),\n                    end     : prev()\n                });\n            }\n            if (is(\"keyword\", \"finally\")) {\n                var start = S.token;\n                next();\n                bfinally = new AST_Finally({\n                    start : start,\n                    body  : block_(),\n                    end   : prev()\n                });\n            }\n            if (!bcatch && !bfinally)\n                croak(\"Missing catch/finally blocks\");\n            return new AST_Try({\n                body     : body,\n                bcatch   : bcatch,\n                bfinally : bfinally\n            });\n        }\n\n        function vardefs(type, no_in) {\n            var a = [];\n            for (;;) {\n                var start = S.token;\n                var name = maybe_destructured(type);\n                var value = null;\n                if (is(\"operator\", \"=\")) {\n                    next();\n                    value = maybe_assign(no_in);\n                } else if (!no_in && (type === AST_SymbolConst || name instanceof AST_Destructured)) {\n                    croak(\"Missing initializer in declaration\");\n                }\n                a.push(new AST_VarDef({\n                    start : start,\n                    name  : name,\n                    value : value,\n                    end   : prev()\n                }));\n                if (!is(\"punc\", \",\"))\n                    break;\n                next();\n            }\n            return a;\n        }\n\n        function is_vardefs() {\n            var token = peek();\n            return is_token(token, \"name\") || is_token(token, \"punc\", \"[\") || is_token(token, \"punc\", \"{\");\n        }\n\n        var const_ = function(no_in) {\n            return new AST_Const({\n                start       : prev(),\n                definitions : vardefs(AST_SymbolConst, no_in),\n                end         : prev()\n            });\n        };\n\n        var let_ = function(no_in) {\n            return new AST_Let({\n                start       : prev(),\n                definitions : vardefs(AST_SymbolLet, no_in),\n                end         : prev()\n            });\n        };\n\n        var var_ = function(no_in) {\n            return new AST_Var({\n                start       : prev(),\n                definitions : vardefs(AST_SymbolVar, no_in),\n                end         : prev()\n            });\n        };\n\n        var new_ = function(allow_calls) {\n            var start = S.token;\n            expect_token(\"operator\", \"new\");\n            var call;\n            if (is(\"punc\", \".\") && is_token(peek(), \"name\", \"target\")) {\n                next();\n                next();\n                call = new AST_NewTarget();\n            } else {\n                var exp = expr_atom(false), args;\n                if (is(\"punc\", \"(\")) {\n                    next();\n                    args = expr_list(\")\", !options.strict);\n                } else {\n                    args = [];\n                }\n                call = new AST_New({ expression: exp, args: args });\n            }\n            call.start = start;\n            call.end = prev();\n            return subscripts(call, allow_calls);\n        };\n\n        function as_atom_node() {\n            var ret, tok = S.token, value = tok.value;\n            switch (tok.type) {\n              case \"num\":\n                if (isFinite(value)) {\n                    ret = new AST_Number({ value: value });\n                } else {\n                    ret = new AST_Infinity();\n                    if (value < 0) ret = new AST_UnaryPrefix({ operator: \"-\", expression: ret });\n                }\n                break;\n              case \"bigint\":\n                ret = new AST_BigInt({ value: value });\n                break;\n              case \"string\":\n                ret = new AST_String({ value: value, quote: tok.quote });\n                break;\n              case \"regexp\":\n                ret = new AST_RegExp({ value: value });\n                break;\n              case \"atom\":\n                switch (value) {\n                  case \"false\":\n                    ret = new AST_False();\n                    break;\n                  case \"true\":\n                    ret = new AST_True();\n                    break;\n                  case \"null\":\n                    ret = new AST_Null();\n                    break;\n                  default:\n                    unexpected();\n                }\n                break;\n              default:\n                unexpected();\n            }\n            next();\n            ret.start = ret.end = tok;\n            return ret;\n        }\n\n        var expr_atom = function(allow_calls) {\n            if (is(\"operator\", \"new\")) {\n                return new_(allow_calls);\n            }\n            var start = S.token;\n            if (is(\"punc\")) {\n                switch (start.value) {\n                  case \"`\":\n                    return subscripts(template(null), allow_calls);\n                  case \"(\":\n                    next();\n                    if (is(\"punc\", \")\")) {\n                        next();\n                        return arrow([], start);\n                    }\n                    var ex = expression(false, true);\n                    var len = start.comments_before.length;\n                    [].unshift.apply(ex.start.comments_before, start.comments_before);\n                    start.comments_before.length = 0;\n                    start.comments_before = ex.start.comments_before;\n                    start.comments_before_length = len;\n                    if (len == 0 && start.comments_before.length > 0) {\n                        var comment = start.comments_before[0];\n                        if (!comment.nlb) {\n                            comment.nlb = start.nlb;\n                            start.nlb = false;\n                        }\n                    }\n                    start.comments_after = ex.start.comments_after;\n                    ex.start = start;\n                    expect(\")\");\n                    var end = prev();\n                    end.comments_before = ex.end.comments_before;\n                    end.comments_after.forEach(function(comment) {\n                        ex.end.comments_after.push(comment);\n                        if (comment.nlb) S.token.nlb = true;\n                    });\n                    end.comments_after.length = 0;\n                    end.comments_after = ex.end.comments_after;\n                    ex.end = end;\n                    if (is(\"punc\", \"=>\")) return arrow(ex instanceof AST_Sequence ? ex.expressions : [ ex ], start);\n                    return subscripts(ex, allow_calls);\n                  case \"[\":\n                    return subscripts(array_(), allow_calls);\n                  case \"{\":\n                    return subscripts(object_(), allow_calls);\n                }\n                unexpected();\n            }\n            if (is(\"keyword\")) switch (start.value) {\n              case \"class\":\n                next();\n                var clazz = class_(AST_ClassExpression);\n                clazz.start = start;\n                clazz.end = prev();\n                return subscripts(clazz, allow_calls);\n              case \"function\":\n                next();\n                var func;\n                if (is(\"operator\", \"*\")) {\n                    next();\n                    func = function_(AST_GeneratorFunction);\n                } else {\n                    func = function_(AST_Function);\n                }\n                func.start = start;\n                func.end = prev();\n                return subscripts(func, allow_calls);\n            }\n            if (is(\"name\")) {\n                var sym = _make_symbol(AST_SymbolRef, start);\n                next();\n                if (sym.name == \"async\") {\n                    if (is(\"keyword\", \"function\")) {\n                        next();\n                        var func;\n                        if (is(\"operator\", \"*\")) {\n                            next();\n                            func = function_(AST_AsyncGeneratorFunction);\n                        } else {\n                            func = function_(AST_AsyncFunction);\n                        }\n                        func.start = start;\n                        func.end = prev();\n                        return subscripts(func, allow_calls);\n                    }\n                    if (is(\"name\") && is_token(peek(), \"punc\", \"=>\")) {\n                        start = S.token;\n                        sym = _make_symbol(AST_SymbolRef, start);\n                        next();\n                        return arrow([ sym ], start, true);\n                    }\n                    if (is(\"punc\", \"(\")) {\n                        var call = subscripts(sym, allow_calls);\n                        if (!is(\"punc\", \"=>\")) return call;\n                        var args = call.args;\n                        if (args[args.length - 1] instanceof AST_Spread) {\n                            args.rest = args.pop().expression;\n                        }\n                        return arrow(args, start, true);\n                    }\n                }\n                return is(\"punc\", \"=>\") ? arrow([ sym ], start) : subscripts(sym, allow_calls);\n            }\n            if (ATOMIC_START_TOKEN[S.token.type]) {\n                return subscripts(as_atom_node(), allow_calls);\n            }\n            unexpected();\n        };\n\n        function expr_list(closing, allow_trailing_comma, allow_empty, parser) {\n            if (!parser) parser = maybe_assign;\n            var first = true, a = [];\n            while (!is(\"punc\", closing)) {\n                if (first) first = false; else expect(\",\");\n                if (allow_trailing_comma && is(\"punc\", closing)) break;\n                if (allow_empty && is(\"punc\", \",\")) {\n                    a.push(new AST_Hole({ start: S.token, end: S.token }));\n                } else if (!is(\"operator\", \"...\")) {\n                    a.push(parser());\n                } else if (parser === maybe_assign) {\n                    a.push(new AST_Spread({\n                        start: S.token,\n                        expression: (next(), parser()),\n                        end: prev(),\n                    }));\n                } else {\n                    next();\n                    a.rest = parser();\n                    if (a.rest instanceof AST_DefaultValue) token_error(a.rest.start, \"Invalid rest parameter\");\n                    break;\n                }\n            }\n            expect(closing);\n            return a;\n        }\n\n        var array_ = embed_tokens(function() {\n            expect(\"[\");\n            return new AST_Array({\n                elements: expr_list(\"]\", !options.strict, true)\n            });\n        });\n\n        var create_accessor = embed_tokens(function() {\n            return function_(AST_Accessor);\n        });\n\n        var object_ = embed_tokens(function() {\n            expect(\"{\");\n            var first = true, a = [];\n            while (!is(\"punc\", \"}\")) {\n                if (first) first = false; else expect(\",\");\n                // allow trailing comma\n                if (!options.strict && is(\"punc\", \"}\")) break;\n                var start = S.token;\n                if (is(\"operator\", \"*\")) {\n                    next();\n                    var key = as_property_key();\n                    var gen_start = S.token;\n                    var gen = function_(AST_GeneratorFunction);\n                    gen.start = gen_start;\n                    gen.end = prev();\n                    a.push(new AST_ObjectMethod({\n                        start: start,\n                        key: key,\n                        value: gen,\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                if (is(\"operator\", \"...\")) {\n                    next();\n                    a.push(new AST_Spread({\n                        start: start,\n                        expression: maybe_assign(),\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                if (is_token(peek(), \"operator\", \"=\")) {\n                    var name = as_symbol(AST_SymbolRef);\n                    next();\n                    a.push(new AST_ObjectKeyVal({\n                        start: start,\n                        key: start.value,\n                        value: new AST_Assign({\n                            start: start,\n                            left: name,\n                            operator: \"=\",\n                            right: maybe_assign(),\n                            end: prev(),\n                        }),\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                if (is_token(peek(), \"punc\", \",\") || is_token(peek(), \"punc\", \"}\")) {\n                    a.push(new AST_ObjectKeyVal({\n                        start: start,\n                        key: start.value,\n                        value: as_symbol(AST_SymbolRef),\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                var key = as_property_key();\n                if (is(\"punc\", \"(\")) {\n                    var func_start = S.token;\n                    var func = function_(AST_Function);\n                    func.start = func_start;\n                    func.end = prev();\n                    a.push(new AST_ObjectMethod({\n                        start: start,\n                        key: key,\n                        value: func,\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                if (is(\"punc\", \":\")) {\n                    next();\n                    a.push(new AST_ObjectKeyVal({\n                        start: start,\n                        key: key,\n                        value: maybe_assign(),\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                if (start.type == \"name\") switch (key) {\n                  case \"async\":\n                    var is_gen = is(\"operator\", \"*\") && next();\n                    key = as_property_key();\n                    var func_start = S.token;\n                    var func = function_(is_gen ? AST_AsyncGeneratorFunction : AST_AsyncFunction);\n                    func.start = func_start;\n                    func.end = prev();\n                    a.push(new AST_ObjectMethod({\n                        start: start,\n                        key: key,\n                        value: func,\n                        end: prev(),\n                    }));\n                    continue;\n                  case \"get\":\n                    a.push(new AST_ObjectGetter({\n                        start: start,\n                        key: as_property_key(),\n                        value: create_accessor(),\n                        end: prev(),\n                    }));\n                    continue;\n                  case \"set\":\n                    a.push(new AST_ObjectSetter({\n                        start: start,\n                        key: as_property_key(),\n                        value: create_accessor(),\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                unexpected();\n            }\n            next();\n            return new AST_Object({ properties: a });\n        });\n\n        function as_property_key() {\n            var tmp = S.token;\n            switch (tmp.type) {\n              case \"operator\":\n                if (!KEYWORDS[tmp.value]) unexpected();\n              case \"num\":\n              case \"string\":\n              case \"name\":\n              case \"keyword\":\n              case \"atom\":\n                next();\n                return \"\" + tmp.value;\n              case \"punc\":\n                expect(\"[\");\n                var key = maybe_assign();\n                expect(\"]\");\n                return key;\n              default:\n                unexpected();\n            }\n        }\n\n        function as_name() {\n            var name = S.token.value;\n            expect_token(\"name\");\n            return name;\n        }\n\n        function _make_symbol(type, token) {\n            var name = token.value;\n            switch (name) {\n              case \"await\":\n                if (S.in_async) unexpected(token);\n                break;\n              case \"super\":\n                type = AST_Super;\n                break;\n              case \"this\":\n                type = AST_This;\n                break;\n              case \"yield\":\n                if (S.in_generator) unexpected(token);\n                break;\n            }\n            return new type({\n                name: \"\" + name,\n                start: token,\n                end: token,\n            });\n        }\n\n        function strict_verify_symbol(sym) {\n            if (sym.name == \"arguments\" || sym.name == \"eval\" || sym.name == \"let\")\n                token_error(sym.start, \"Unexpected \" + sym.name + \" in strict mode\");\n        }\n\n        function as_symbol(type, no_error) {\n            if (!is(\"name\")) {\n                if (!no_error) croak(\"Name expected\");\n                return null;\n            }\n            var sym = _make_symbol(type, S.token);\n            if (S.input.has_directive(\"use strict\") && sym instanceof AST_SymbolDeclaration) {\n                strict_verify_symbol(sym);\n            }\n            next();\n            return sym;\n        }\n\n        function maybe_destructured(type) {\n            var start = S.token;\n            if (is(\"punc\", \"[\")) {\n                next();\n                var elements = expr_list(\"]\", !options.strict, true, function() {\n                    return maybe_default(type);\n                });\n                return new AST_DestructuredArray({\n                    start: start,\n                    elements: elements,\n                    rest: elements.rest || null,\n                    end: prev(),\n                });\n            }\n            if (is(\"punc\", \"{\")) {\n                next();\n                var first = true, a = [], rest = null;\n                while (!is(\"punc\", \"}\")) {\n                    if (first) first = false; else expect(\",\");\n                    // allow trailing comma\n                    if (!options.strict && is(\"punc\", \"}\")) break;\n                    var key_start = S.token;\n                    if (is(\"punc\", \"[\") || is_token(peek(), \"punc\", \":\")) {\n                        var key = as_property_key();\n                        expect(\":\");\n                        a.push(new AST_DestructuredKeyVal({\n                            start: key_start,\n                            key: key,\n                            value: maybe_default(type),\n                            end: prev(),\n                        }));\n                        continue;\n                    }\n                    if (is(\"operator\", \"...\")) {\n                        next();\n                        rest = maybe_destructured(type);\n                        break;\n                    }\n                    var name = as_symbol(type);\n                    if (is(\"operator\", \"=\")) {\n                        next();\n                        name = new AST_DefaultValue({\n                            start: name.start,\n                            name: name,\n                            value: maybe_assign(),\n                            end: prev(),\n                        });\n                    }\n                    a.push(new AST_DestructuredKeyVal({\n                        start: key_start,\n                        key: key_start.value,\n                        value: name,\n                        end: prev(),\n                    }));\n                }\n                expect(\"}\");\n                return new AST_DestructuredObject({\n                    start: start,\n                    properties: a,\n                    rest: rest,\n                    end: prev(),\n                });\n            }\n            return as_symbol(type);\n        }\n\n        function maybe_default(type) {\n            var start = S.token;\n            var name = maybe_destructured(type);\n            if (!is(\"operator\", \"=\")) return name;\n            next();\n            return new AST_DefaultValue({\n                start: start,\n                name: name,\n                value: maybe_assign(),\n                end: prev(),\n            });\n        }\n\n        function template(tag) {\n            var start = tag ? tag.start : S.token;\n            var read = S.input.context().read_template;\n            var strings = [];\n            var expressions = [];\n            while (read(strings)) {\n                next();\n                expressions.push(expression());\n                if (!is(\"punc\", \"}\")) unexpected();\n            }\n            next();\n            return new AST_Template({\n                start: start,\n                expressions: expressions,\n                strings: strings,\n                tag: tag,\n                end: prev(),\n            });\n        }\n\n        function subscripts(expr, allow_calls) {\n            var start = expr.start;\n            var optional = null;\n            while (true) {\n                if (is(\"operator\", \"?\") && is_token(peek(), \"punc\", \".\")) {\n                    next();\n                    next();\n                    optional = expr;\n                }\n                if (is(\"punc\", \"[\")) {\n                    next();\n                    var prop = expression();\n                    expect(\"]\");\n                    expr = new AST_Sub({\n                        start: start,\n                        optional: optional === expr,\n                        expression: expr,\n                        property: prop,\n                        end: prev(),\n                    });\n                } else if (allow_calls && is(\"punc\", \"(\")) {\n                    next();\n                    expr = new AST_Call({\n                        start: start,\n                        optional: optional === expr,\n                        expression: expr,\n                        args: expr_list(\")\", !options.strict),\n                        end: prev(),\n                    });\n                } else if (optional === expr || is(\"punc\", \".\")) {\n                    if (optional !== expr) next();\n                    expr = new AST_Dot({\n                        start: start,\n                        optional: optional === expr,\n                        expression: expr,\n                        property: as_name(),\n                        end: prev(),\n                    });\n                } else if (is(\"punc\", \"`\")) {\n                    if (optional) croak(\"Invalid template on optional chain\");\n                    expr = template(expr);\n                } else {\n                    break;\n                }\n            }\n            if (optional) expr.terminal = true;\n            if (expr instanceof AST_Call && !expr.pure) {\n                var start = expr.start;\n                var comments = start.comments_before;\n                var i = HOP(start, \"comments_before_length\") ? start.comments_before_length : comments.length;\n                while (--i >= 0) {\n                    if (/[@#]__PURE__/.test(comments[i].value)) {\n                        expr.pure = true;\n                        break;\n                    }\n                }\n            }\n            return expr;\n        }\n\n        function maybe_unary(no_in) {\n            var start = S.token;\n            if (S.in_async && is(\"name\", \"await\")) {\n                if (S.in_funarg === S.in_function) croak(\"Invalid use of await in function argument\");\n                S.input.context().regex_allowed = true;\n                next();\n                return new AST_Await({\n                    start: start,\n                    expression: maybe_unary(no_in),\n                    end: prev(),\n                });\n            }\n            if (S.in_generator && is(\"name\", \"yield\")) {\n                if (S.in_funarg === S.in_function) croak(\"Invalid use of yield in function argument\");\n                S.input.context().regex_allowed = true;\n                next();\n                var exp = null;\n                var nested = false;\n                if (is(\"operator\", \"*\")) {\n                    next();\n                    exp = maybe_assign(no_in);\n                    nested = true;\n                } else if (is(\"punc\") ? !PUNC_AFTER_EXPRESSION[S.token.value] : !can_insert_semicolon()) {\n                    exp = maybe_assign(no_in);\n                }\n                return new AST_Yield({\n                    start: start,\n                    expression: exp,\n                    nested: nested,\n                    end: prev(),\n                });\n            }\n            if (is(\"operator\") && UNARY_PREFIX[start.value]) {\n                next();\n                handle_regexp();\n                var ex = make_unary(AST_UnaryPrefix, start, maybe_unary(no_in));\n                ex.start = start;\n                ex.end = prev();\n                return ex;\n            }\n            var val = expr_atom(true);\n            while (is(\"operator\") && UNARY_POSTFIX[S.token.value] && !has_newline_before(S.token)) {\n                val = make_unary(AST_UnaryPostfix, S.token, val);\n                val.start = start;\n                val.end = S.token;\n                next();\n            }\n            return val;\n        }\n\n        function make_unary(ctor, token, expr) {\n            var op = token.value;\n            switch (op) {\n              case \"++\":\n              case \"--\":\n                if (!is_assignable(expr))\n                    token_error(token, \"Invalid use of \" + op + \" operator\");\n                break;\n              case \"delete\":\n                if (expr instanceof AST_SymbolRef && S.input.has_directive(\"use strict\"))\n                    token_error(expr.start, \"Calling delete on expression not allowed in strict mode\");\n                break;\n            }\n            return new ctor({ operator: op, expression: expr });\n        }\n\n        var expr_op = function(left, min_precision, no_in) {\n            var op = is(\"operator\") ? S.token.value : null;\n            if (op == \"in\" && no_in) op = null;\n            var precision = op != null ? PRECEDENCE[op] : null;\n            if (precision != null && precision > min_precision) {\n                next();\n                var right = expr_op(maybe_unary(no_in), op == \"**\" ? precision - 1 : precision, no_in);\n                return expr_op(new AST_Binary({\n                    start    : left.start,\n                    left     : left,\n                    operator : op,\n                    right    : right,\n                    end      : right.end,\n                }), min_precision, no_in);\n            }\n            return left;\n        };\n\n        function expr_ops(no_in) {\n            return expr_op(maybe_unary(no_in), 0, no_in);\n        }\n\n        var maybe_conditional = function(no_in) {\n            var start = S.token;\n            var expr = expr_ops(no_in);\n            if (is(\"operator\", \"?\")) {\n                next();\n                var yes = maybe_assign();\n                expect(\":\");\n                return new AST_Conditional({\n                    start       : start,\n                    condition   : expr,\n                    consequent  : yes,\n                    alternative : maybe_assign(no_in),\n                    end         : prev()\n                });\n            }\n            return expr;\n        };\n\n        function is_assignable(expr) {\n            return expr instanceof AST_PropAccess && !expr.optional || expr instanceof AST_SymbolRef;\n        }\n\n        function to_destructured(node) {\n            if (node instanceof AST_Array) {\n                var rest = null;\n                if (node.elements[node.elements.length - 1] instanceof AST_Spread) {\n                    rest = to_destructured(node.elements.pop().expression);\n                    if (!(rest instanceof AST_Destructured || is_assignable(rest))) return node;\n                }\n                var elements = node.elements.map(to_destructured);\n                return all(elements, function(node) {\n                    return node instanceof AST_DefaultValue\n                        || node instanceof AST_Destructured\n                        || node instanceof AST_Hole\n                        || is_assignable(node);\n                }) ? new AST_DestructuredArray({\n                    start: node.start,\n                    elements: elements,\n                    rest: rest,\n                    end: node.end,\n                }) : node;\n            }\n            if (node instanceof AST_Assign) {\n                var name = to_destructured(node.left);\n                return name instanceof AST_Destructured || is_assignable(name) ? new AST_DefaultValue({\n                    start: node.start,\n                    name: name,\n                    value: node.right,\n                    end: node.end,\n                }) : node;\n            }\n            if (!(node instanceof AST_Object)) return node;\n            var rest = null;\n            if (node.properties[node.properties.length - 1] instanceof AST_Spread) {\n                rest = to_destructured(node.properties.pop().expression);\n                if (!(rest instanceof AST_Destructured || is_assignable(rest))) return node;\n            }\n            var props = [];\n            for (var i = 0; i < node.properties.length; i++) {\n                var prop = node.properties[i];\n                if (!(prop instanceof AST_ObjectKeyVal)) return node;\n                var value = to_destructured(prop.value);\n                if (!(value instanceof AST_DefaultValue || value instanceof AST_Destructured || is_assignable(value))) {\n                    return node;\n                }\n                props.push(new AST_DestructuredKeyVal({\n                    start: prop.start,\n                    key: prop.key,\n                    value: value,\n                    end: prop.end,\n                }));\n            }\n            return new AST_DestructuredObject({\n                start: node.start,\n                properties: props,\n                rest: rest,\n                end: node.end,\n            });\n        }\n\n        function maybe_assign(no_in) {\n            var start = S.token;\n            var left = maybe_conditional(no_in), val = S.token.value;\n            if (is(\"operator\") && ASSIGNMENT[val]) {\n                if (is_assignable(left) || val == \"=\" && (left = to_destructured(left)) instanceof AST_Destructured) {\n                    next();\n                    return new AST_Assign({\n                        start    : start,\n                        left     : left,\n                        operator : val,\n                        right    : maybe_assign(no_in),\n                        end      : prev()\n                    });\n                }\n                croak(\"Invalid assignment\");\n            }\n            return left;\n        }\n\n        function expression(no_in, maybe_arrow) {\n            var start = S.token;\n            var exprs = [];\n            while (true) {\n                if (maybe_arrow && is(\"operator\", \"...\")) {\n                    next();\n                    exprs.rest = maybe_destructured(AST_SymbolFunarg);\n                    break;\n                }\n                exprs.push(maybe_assign(no_in));\n                if (!is(\"punc\", \",\")) break;\n                next();\n                if (maybe_arrow && is(\"punc\", \")\") && is_token(peek(), \"punc\", \"=>\")) break;\n            }\n            return exprs.length == 1 && !exprs.rest ? exprs[0] : new AST_Sequence({\n                start: start,\n                expressions: exprs,\n                end: prev(),\n            });\n        }\n\n        function in_loop(cont) {\n            ++S.in_loop;\n            var ret = cont();\n            --S.in_loop;\n            return ret;\n        }\n\n        if (options.expression) {\n            handle_regexp();\n            var exp = expression();\n            expect_token(\"eof\");\n            return exp;\n        }\n\n        return function() {\n            var start = S.token;\n            var body = [];\n            if (options.module) {\n                S.in_async = true;\n                S.input.add_directive(\"use strict\");\n            }\n            S.input.push_directives_stack();\n            while (!is(\"eof\"))\n                body.push(statement(true));\n            S.input.pop_directives_stack();\n            var end = prev() || start;\n            var toplevel = options.toplevel;\n            if (toplevel) {\n                toplevel.body = toplevel.body.concat(body);\n                toplevel.end = end;\n            } else {\n                toplevel = new AST_Toplevel({ start: start, body: body, end: end });\n            }\n            return toplevel;\n        }();\n    }\n\n    m_ast.parse = parse; /// TODO: lwf\n    return {\n        is_identifier_string,\n        is_identifier_char,\n        is_surrogate_pair_head,\n        is_surrogate_pair_tail,\n        decode_escape_sequence,\n        tokenizer,\n        parse,\n        KEYWORDS,\n        RESERVED_WORDS,\n        KEYWORDS_BEFORE_EXPRESSION,\n        KEYWORDS_ATOM,\n        UNARY_POSTFIX,\n        PRECEDENCE \n    }\n});"]}